\section{x86 Arithmetic Operations} 

  \begin{definition}[Size Specifier]
    In x86 assembly, the \textbf{size specifier} can be appended to this instruction mnemonic to specify the size of the operands. 
    \begin{enumerate} 
      \item \textbf{b} (byte) for 1 byte 
      \item \textbf{w} (word) for 2 bytes
      \item \textbf{l} (long) for 4 bytes 
      \item \textbf{q} (quad word) for 8 bytes
    \end{enumerate}
    Note that due to backwards compatibility, word means 2 bytes in instruction names. Furthermore, the maximum size is 8 bytes since that is the size of each register in x86\_64. 
  \end{definition}

  Like higher level programming languages, we can perform operations, do comparisons, and jump to different parts of the code. Instructions can be generally categorized into three types: 
  \begin{enumerate} 
    \item \textbf{Data Movement}: These instructions move data between memory and registers or between the registery and registery. Memory to memory transfer cannot be done with a single instruction. 
      \begin{lstlisting} 
        %reg = Mem[address]     # load data from memory into register
        Mem[address] = %reg     # store register data into memory
      \end{lstlisting}
    \item \textbf{Arithmetic Operation}: Perform arithmetic operation on register or memory data. 
      \begin{lstlisting} 
        %reg = %reg + Mem[address]     # add memory data to register
        %reg = %reg - Mem[address]     # subtract memory data from register
        %reg = %reg * Mem[address]     # multiply memory data to register
        %reg = %reg / Mem[address]     # divide memory data from register
      \end{lstlisting}
    \item \textbf{Control Flow}: What instruction to execute next. 
      \begin{lstlisting} 
        jmp label     # jump to label
        je label      # jump to label if equal
        jne label     # jump to label if not equal
        jg label      # jump to label if greater
        jl label      # jump to label if less
        call label    # call a function
        ret           # return from a function
      \end{lstlisting}
  \end{enumerate}

  Now unlike compiled languages, which are translated into machine code by a compiler, assembly code is translated into machine code through a two-step process. First, we \textbf{assemble} the assembly code into an \textbf{object file} by an \textbf{assembler}, and then we \textbf{link} the object file into an executable by a \textbf{linker}. Some common assemblers are \textbf{NASM} (Netwide Assembler) and \textbf{GAS/AS} (GNU Assembler), and common linkers are \textbf{ld} (GNU Linker) and \textbf{lld} (LLVM Linker), both installable with \textbf{sudo pacman -S nasm ld}. 

  \begin{definition}[mov]
    Let's talk about the \texttt{mov} instruction. A good diagram to see is the following: 
    \begin{center}  
      % \includegraphics[scale=0.5]{img/movq.png}
    \end{center} 
    Parantheses indicate that we are using a pointer dereference. 
  \end{definition}

  \begin{definition}[int]
    The \texttt{int} instruction is used to generate a software interrupt. It is often used to invoke a system call.
  \end{definition}

  \begin{definition}[ret]
    The \texttt{ret} instruction is used to return from a function. It returns the value in the \texttt{\%rax} register. 
  \end{definition}

  \begin{example}[Swap Function]
    In \textbf{gdb}, we may have a function that swaps two integers. 
    \begin{lstlisting} 
      swap:
        movq (%rdi), %rax
        movq (%rsi), %rdx
        movq %rdx, (%rdi)
        movq %rax, (%rsi)
        ret
    \end{lstlisting}
    which is the assembly code for the following C code.
    \begin{lstlisting} 
      void swap(long *xp, long *yp) {
        long t0 = *xp;
        long t1 = *yp;
        *xp = t1;
        *yp = t0;
      }
    \end{lstlisting}
  \end{example}

  Let's talk about moving instructions first. 

  \begin{definition}[mov]
    Let's talk about the \texttt{mov} instruction which copies data from the source to the destination (the data in the source still remains!) and has the syntax 
    \begin{equation}
      \texttt{mov\_ src, dest}
    \end{equation}
    \begin{enumerate}
      \item The source can be a register (\texttt{\%rsi}), a value (\texttt{\$0x4}), or a memory address (\texttt{0x4}).
      \item The destination can be a register or a memory address. 
      \item The \texttt{\_} is defined to be one of the size operands, which determine how big the data is. For example, we can call \texttt{movq} to move 8 bytes of data (which turns about to be the maximum size of a register). 
    \end{enumerate}
    A good diagram to see is the following: 
    \begin{center}  
      \includegraphics[scale=0.5]{img/movq.png}
    \end{center} 
  \end{definition}

  Even with just the mov instruction, we can look at a practical implementation of a C program in Assembly. 

  \begin{example}[Swap Function]
    Let us take a look at a function that swaps two integers. Let's see what they do. 
    \begin{enumerate}
      \item In C, we dereference both \texttt{xp} and \texttt{yp} (note that they are pointers to longs, so they store 8 bytes), and assign these two values to two temporary variables. Then, we assign the value of \texttt{yp} to \texttt{xp} and the value of \texttt{xp} to \texttt{yp}.
      \item In Assembly, we first take the registers \texttt{\%rdi} and \texttt{\%rsi}, which are the 1st and 2nd arguments of the function, dereference them with the parantheses, and store them in the temporary registers \texttt{\%rax} and \texttt{\%rdx}. Then, we store the value of \texttt{\%rdx} into the memory address of \texttt{\%rdi} and the value of \texttt{\%rax} into the memory address of \texttt{\%rsi}. Note that the input values (the actual of )
    \end{enumerate}

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      void swap(long *xp, long *yp) {
        long t0 = *xp;
        long t1 = *yp;
        *xp = t1;
        *yp = t0;
      }
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      swap:
        movq (%rdi), %rax
        movq (%rsi), %rdx
        movq %rdx, (%rdi)
        movq %rax, (%rsi)
        ret
    \end{lstlisting}
    \end{minipage}
  \end{example}

  \begin{definition}[movz and movs]
    The \texttt{movz} and \texttt{movs} instructions are used to move data from the source to the destination, but with zero and sign extension, respectively. It is used to copy from a smaller source value to a larger destination, with the syntax 
    \begin{align*}
      \texttt{movz\_\_ src, dest} \\ 
      \texttt{movs\_\_ src, dest} 
    \end{align*}
    where the first $\_$ is the size of the source and the second $\_$ is the size of the destination. 
    \begin{enumerate}
      \item The source can be from a memory or register. 
      \item The destination must be a register. 
    \end{enumerate}
  \end{definition}

  \begin{example}[Simple example with movz]
    Take a look at the code below. 
    \begin{lstlisting}
      movzbq %al, %rbx
    \end{lstlisting}
    The \texttt{\%al} represents the last byte of the \texttt{\%rax} register. It is 1 byte long. The \texttt{\%rbx} register is 8 bytes long, so we can fill in the rest of the 7 bytes with zeros. 
    \begin{center}  
      \includegraphics[scale=0.5]{img/movzbq.png}
    \end{center}
  \end{example}

  \begin{example}[Harder example with movs]
    Take a look at the code below. 
    \begin{lstlisting}
      movsbl (%rax), %ebx
    \end{lstlisting}
    You want to move the value at the memory address in \texttt{\%rax} into \texttt{\%ebx}. Since the source size is set to 1 byte, you take that byte, say it is \texttt{0x80}, from the memory, and then sign extend it (by a size of 4 bytes!) into \texttt{\%ebx}. Note that therefore, the first four bytes of \texttt{\%rbx} will not be affected since it's not a part of \texttt{\%ebx}. An exception to this is that in x86-64, any instruction that generates a 32-bit long word value for a register also sets the high-order 32 bits of the register to 0, so this ends up clearing the first 4 bytes to 0. 
    \begin{center}  
      \includegraphics[scale=0.5]{img/movsbl.png}
    \end{center}
  \end{example}

  Now we can talk about control transfer. Say that you have the following C and Assembly code. 
  
  \begin{figure}[H]
    \centering 
    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      int add(int x) {
        return x + 2; 
      }

      int main() {
        int a = 2; 
        int b = add(a); 
        return 0; 
      }
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      add: 
        movq %rdi, %rax 
        addq $2, %rax 
        ret 
      main:
        movq $3, $rdi 
        call add 
        movq $0, %rax 
        ret 
    \end{lstlisting}
    \end{minipage}
    \caption{A simple function. } 
    \label{fig:stack_example}
  \end{figure}

  If you go through the instructions, you see that in main, you first move \texttt{\$3} into the \texttt{\%rdi} register. Then, you call the \texttt{add} function, and within it you also have the \texttt{\%rdi} register. This is a conflict in the register, and we don't want to simply overwrite the value of \texttt{\%rdi} in the \texttt{main} function. Simply putting it to another register isn't a great idea since we can't always guarantee that it will be free. Therefore, we must use the memory itself. 

  Recall the stack, which we can think of as a giant array in which data gets pushed and popped in a last-in-first-out manner. The stack is used to store data and return addresses, and is used to manage function calls. Visually, we want to think of the elements getting pushed in from the bottom (upside down) towards lower memory addresses. 

  \begin{definition}[Stack Pointer]
    Note that every time we want to push or pop something from the stack, we must know \textit{where} to push or pop it. This is where the \textbf{stack pointer} comes in. It is a special register that always points to the top of the stack, and is used to keep track of the stack.
  \end{definition}

  \begin{definition}[Push and Pop]
    The \texttt{push} and \texttt{pop} instructions are used to push and pop data onto and off the stack, respectively. 
    \begin{align*}
      \texttt{push\_ src} && \texttt{rsp = rsp - 8; Mem[rsp] = src} \\
      \texttt{pop\_ dest} && \texttt{dest = Mem[rsp]; rsp = rsp + 8} 
    \end{align*}
    \begin{enumerate}
      \item When we push the source, we fetch the value at the source and store it at the memory address pointed to by the stack pointer \texttt{\%rsp}. Then, we decrement \texttt{\%rsp} by 8.
      \item When we pop from the stack, we fetch the value at the memory address pointed to by the stack pointer \texttt{\%rsp} and store it in the destination. Then, we increment \texttt{\%rsp} by 8.
    \end{enumerate}
    Note that no matter what the size of the operand, we always subtract 8 from the stack pointer. This is because the stack grows downwards, and we want to make sure that the next element is pushed into the next available space.
  \end{definition}

  Note that the register \texttt{\%rsp} is the stack pointer, which points to the top of the stack. The stack is used to store data and return addresses, and is used to manage function calls. 

  \begin{definition}[Push and Pop]
    The \texttt{push} and \texttt{pop} instructions are used to push and pop data onto and off the stack, respectively. 
    \begin{align*}
      \texttt{push\_ src} && \texttt{rsp = rsp - 8; Mem[rsp] = src} \\
      \texttt{pop\_ dest} && \texttt{dest = Mem[rsp]; rsp = rsp + 8} 
    \end{align*}
    The \texttt{\_} is a size operand, which determines how big the data is.
  \end{definition}

  \begin{definition}[Call and Ret]
    The \texttt{call} instruction pushes the return address onto the stack and jumps to the function. The \texttt{ret} instruction pops the return address from the stack and jumps to it.
  \end{definition}

  We also talked about how there is instruction code that is even below the stack that is stored. This is where all the machine code/assembly is stored, and we want to find out where we are currently at in this code. This is done with the program counter. 

  \begin{definition}[Program Counter, Instruction Pointer] 
    The \textbf{program counter}, or \textbf{instruction pointer}, is a special register \textbf{rip} that points to the current instruction in the program. It is used to keep track of the next instruction to be executed.
  \end{definition}

  Let's go through one long example to see in detail how this is calculated. 
  
  \begin{example}[Evaluating a Function]
    Say that we have the following C code. 
    \begin{lstlisting}
      int adder2(int a) {
        return a + 2; 
      }

      int main() {
        int x = 40; 
        x = adder2(x); 
        printf("x is: %d\n", x);
        return 0; 
      }
    \end{lstlisting}
    When we compile this program, we can view its full assembly code by calling \texttt{objdump -d a.out}. The output is quite long, so we will focus on the instruction for the \texttt{adder2} function. 
    \begin{figure}[H]
      \centering 
      \begin{lstlisting}
        0000000000400526 <adder2>:
        400526:       55                      push   %rbp
        400527:       48 89 e5                mov    %rsp,%rbp
        40052a:       89 7d fc                mov    %edi,-0x4(%rbp)
        40052d:       8b 45 fc                mov    -0x4(%rbp),%eax
        400530:       83 c0 02                add    $0x2,%eax
        400533:       5d                      pop    %rbp
        400534:       c3                      retq
      \end{lstlisting}
      \caption{The output of objdump for the \texttt{adder2} function. The leftmost column represents the addresses (in hex) of where the actual instructions lie. The second column represents the machine code that is being executed. The third column represents the assembly code.}
      \label{fig:adder2} 
    \end{figure}
    Note some things. Since \texttt{adder2} is taking in an integer input value, we want to load it into the lower 32 bits (4 bytes) of the \texttt{\%rdi} register, which is the first parameter. So we use \texttt{\%edi}. Likewise for the return value, we want to output an int so we use \texttt{\%eax} rather than \texttt{\%rax}. Let's go through some of the steps. 
    \begin{enumerate}
      \item By the time we get into calling \texttt{adder2}, we can take a look at the relevant registers. 

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_1.png}
        \end{center}
        \begin{enumerate}
          \item First, the \texttt{\%eax} is filled with garbage, which are leftovers from previous programs that haven't been overwritten yet. 
          \item Second, the \texttt{\%edi=0x28} since we have set \texttt{x=40} in \texttt{main}, before calling \texttt{adder2}, so it lingers on. 
          \item \texttt{\%rsp=0xd28} since that is where the top of the stack is. 
          \item \texttt{\%rbp=0xd40} 
          \item \texttt{\%rip=0x526} since that is where we are currently at in our instruction (we are about to do it, but haven't done it yet). 
        \end{enumerate}

      \item When we execute the first line of code, we simply push the value at \texttt{\%rbp} into the stack. The top of the stack gets decremeneted by 8 and the value at \texttt{\%rbp} is stored there. This means that the top of the stack is at \texttt{\%rsp=0xd20} and the next instruction will be at \texttt{\%rip=0x527}.  

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_2.png}
        \end{center}

      \item The reason we have pushed \texttt{\%rbp} onto the stack is that we want to save it before it gets overwritten by this next execution. We basically move the value of \texttt{\%rsp} into \texttt{\%rbp}, and the \texttt{\%rip} advances to the next instruction. \texttt{\%rip} moves to the next instruction. 

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_3.png}
        \end{center}

      \item Now we want to take our first argument \texttt{\%edi} and store it in memory. Note that since this is 4 bytes, we can move this value into memory that is 4 bytes below the stack (\texttt{-0x4(\%rbp)}). Note that the storing the value of \texttt{\%edi} into memory doesn't affect the stack pointer \texttt{\%rsp}. As far as the program is concerned, the top of this stack is still address \texttt{0xd20}. 

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_4.png}
        \end{center}

      \item The next instruction simply goes into memory 4 bytes below the stack pointer, takes the value there, and stores it into \texttt{\%eax}. This is the value of \texttt{\%edi} that we just stored. This may seem redundant since we are making a round trip to memory and back to ultimately move the value of \texttt{\%edi} into \texttt{\%eax}, but compilers are not smart and just follow these instructions. 

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_5.png}
        \end{center}

      \item Finally, we add the value \texttt{\$0x2} to \texttt{\%eax} and store it back into \texttt{\%eax}. 

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_6.png}
        \end{center}

      \item Finally, we pop the value at the top of the stack and store it into \texttt{\%rbp}. Note that this is \textit{not} the value \texttt{0x28}. It is simply the value that is stored at \texttt{\%rsp=0xd20}, which is \texttt{(\%rsp)=0xd40}. 

        \begin{center}
          \includegraphics[scale=0.5]{img/ex1_7.png}
        \end{center}

      \item Finally, we return the value with \texttt{retq}. 
    \end{enumerate}
  \end{example}

  Note that the final values in the registers \texttt{\%rsp} and \texttt{\%rip} are \texttt{0xd28} and \texttt{0x534}, respectively, which are the same values as when the function started executing! This is normal and expected behavior with the call stack, which just stores temporary variable sand data of each function as it executes a program. Once a function completes executing, the stack returns to the state it was in prior to the function call. Therefore, it is common to see the following two instructions at the beginning of a function: 
  \begin{lstlisting}
    push %rbp 
    mov %rsp, %rbp
  \end{lstlisting}
  and the following two at the end of a function 
  \begin{lstlisting}
    pop %rbp 
    retq
  \end{lstlisting}

  Now arithemtic operations are quite simple.

  \begin{definition}[Add, Subtract, Multiply]
    The \textbf{add} and \textbf{sub} instructions are used to add and subtract data from the destination. 
    \begin{align*}
      \texttt{add\_ src, dest} && \texttt{dest = dest + src} \\
      \texttt{sub\_ src, dest} && \texttt{dest = dest - src}
    \end{align*}
    The \textbf{imul} instruction is used to multiply data between the source and destination and store it in the destination.  
    \begin{align*}
      \texttt{imul\_ src, dest} && \texttt{dest = dest * src} 
    \end{align*}
    Again the \texttt{\_} is a size operand, which determines how big the data is. 
  \end{definition}

  \begin{definition}[Increment, Decrement]
    The \textbf{inc} and \textbf{dec} instructions are used to increment and decrement the value in the destination. 
    \begin{align*}
      \texttt{inc\_ dest} && \texttt{dest = dest + 1} \\
      \texttt{dec\_ dest} && \texttt{dest = dest - 1}
    \end{align*}
  \end{definition}

  \begin{definition}[Negative]
    The \textbf{neg} instruction is used to negate the value in the destination. 
    \begin{align*}
      \texttt{neg\_ dest} && \texttt{dest = -dest} 
    \end{align*}
  \end{definition}

  \begin{example}[Basic Arithmetic Function]
    The following represents the same program in C and in assembly. Let's go through each one: 
    \begin{enumerate}
      \item In C, we first initialize \texttt{a = 4}, then \texttt{b = 8}, add them together to get \texttt{c}, and then return \texttt{c}.
      \item In Assembly, we move the value $4$ to the \texttt{\%rax} register, then move the value $8$ to the \texttt{\%rbx} register, add the two values together to store it into \texttt{\%rax}, and then return the value in the \texttt{\%rax} register.
    \end{enumerate}
    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      int main() {
        int a = 4, b = 8; 
        int c = a + b; 
        return c; 
      }
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      main:
        movq $4, %rax
        movq $8, %rbx
        addq %rbx, %rax
        ret
    \end{lstlisting}
    \end{minipage}
    It is slightly different in Assembly since rather than storing $4$ in some intermediate register, we immediately store it in the return register. In a way it is more optimized, and this is what the compiler does for you so that as few registers are used. 
  \end{example}

  A shorthand way to do this is with \texttt{lea}, which stands for load effective address. 

  \begin{definition}[Load Effective Address]
    The \textbf{lea} instruction is used to load the effective address of the source into the destination. For now, we will focus on the arithmetic operations that it can do
    \begin{align*}
      \texttt{lea\_ (src1, src2), dest} && \texttt{dest = src1 + src2}  \\ 
      \texttt{lea\_ (src1, src2, scale), dest} && \texttt{dest = src1 + src2*scale}  \\ 
      \texttt{lea\_ const(src1, src2), dest} && \texttt{dest = src1 + src2 + const} \\ 
      \texttt{lea\_ const(src1, src2, scale), dest} && \texttt{dest = src1 + src2*scale + const}
    \end{align*}
    This is useful for doing arithmetic operations on the address of a variable.
  \end{definition}

  \begin{definition}[Bitwise]
    The \textbf{and}, \textbf{or}, \textbf{xor}, and \textbf{not} instructions are used to perform bitwise operations on the source and destination. 
    \begin{align*}
      \texttt{and src, dest} && \texttt{dest = dest \& src}  \\
      \texttt{or src, dest} && \texttt{dest = dest | src}  \\
      \texttt{xor src, dest} && \texttt{dest = dest \^ src}  \\
      \texttt{neg dest} && \texttt{dest = -dest}  \\
      \texttt{not dest} && \texttt{dest = $\sim$dest}  
    \end{align*}
  \end{definition}

  \begin{definition}[Arithmetic and Logical Bit Shift]
    The \texttt{sal} arithmetic instruction is used to shift the bits of the destination to the left by the number of bits specified in the source. The \texttt{shr} instruction is used to shift the bits of the destination to the right by the number of bits specified in the source.
    \begin{align*}
      \texttt{sal src, dest} && \texttt{dest = dest << src}  \\
      \texttt{shr src, dest} && \texttt{dest = dest >> src}
    \end{align*}
    The \texttt{sar} instruction is used to shift the bits of the destination to the right by the number of bits specified in the source, and fill the leftmost bits with the sign bit. The \texttt{shl} instruction is used to shift the bits of the destination to the left by the number of bits specified in the source, and fill the rightmost bits with zeros. 
    \begin{align*}
      \texttt{sar src, dest} && \texttt{dest = dest >> src}  \\
      \texttt{shl src, dest} && \texttt{dest = dest << src}
    \end{align*}
  \end{definition}

  \begin{example}[Harder Arithmetic Example]
    The following two codes are equivalent. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      long arith(long x, long y, long z) {
        long t1 = x + y; 
        long t2 = z + t1; 
        long t3 = x + 4; 
        long t4 = y * 48; 
        long t5 = t3 + t4;
        long rval = t2 * t5; 
        return rval; 
      }
      .
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      arith: 
        # rax/t1 = x + y
        leaq  (%rdi, %rsi), %rax
        # rax/t2 = z + t1
        addq  %rdx, %rax
        #rdx = 3 * y 
        leaq  (%rsi, %rsi, 2), %rdx
        #rdx/t4 = (3*y) * 16
        salq  $4, %rdx 
        #rcx/t5 = x + t4 + 4
        leaq  4(%rdi, %rdi), %rcx 
        # rax/rval = t5 * t2
        imulq %rcx, %rax 
        ret 
    \end{lstlisting}
    \end{minipage}
  \end{example}

  The final thing in our list is condition codes. 

  Sometimes, we want to move (really copy) some value to another register if some condition is met. This is where we use conditional moves. These conditions are met by the flags register, which is a special register that stores the status of the last operation. It is the value of these flags that determine whether all future conditional statements are met in assembly. 
  
  \begin{definition}[Condition Code Flags]
    The flags register in the x86 CPU keeps 4 \textit{condition code} flag bits internally. Think of these as status flags that are \textit{implicitly} set by the most recent arithmetic operation (think of it as side effects). Note that condition codes are NOT set by \texttt{lea} or \texttt{mov} instructions! 
    \begin{enumerate}
      \item \textbf{Zero Flag}: if the last operation resulted in a zero value.
      \item \textbf{Sign Flag}: if the last operation resulted in a negative value (i.e. the most significant bit is 1).
      \item \textbf{Overflow Flag}: if the last operation resulted in a signed overflow.
      \item \textbf{Carry Flag}: if the last operation resulted in a carry out of the most significant bit, i.e. an unsigned overflow. 
    \end{enumerate}
    Every operation may or may not changes these flags to test for zero or nonzero, positive or negative, or overflow conditions, and combinations of these flags express the full range of conditions and cases, e.g. for signed and unsigned values. 
  \end{definition}

  \begin{example}[Zero Flag]
    If the code below was just run, then ZF would be set to 1. 
    \begin{lstlisting}
      movq $2, %rax 
      subq $2, %rax
    \end{lstlisting}
  \end{example}

  \begin{example}[Sign Flag]
    If the code below was just run, then SF would be set to 1. 
    \begin{lstlisting}
      movq $2, %rax 
      subq $4, %rax
    \end{lstlisting}
  \end{example}

  \begin{example}[Overflow Flag]
    If either code below was just run, then OF would be set to 1. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      movq $0x7fffffffffffffff, %rax 
      addq $1, %rax
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      movq 0x8000000000000000, %rax 
      addq 0xffffffffffffffff, %rax
    \end{lstlisting}
    \end{minipage}
    This is because in the left in signed arithmetic, we have a positive + positive = negative (result is \texttt{0x8000000000000000}), which is a signed overflow. Furthermore, in the right we have negative + negative = positive (result is \texttt{0x7fffffffffffffff}). 
  \end{example}

  \begin{example}[Carry Flag]
    If the code below was just run, then CF would be set to 1. 
    \begin{lstlisting}
      movq $0xffffffffffffffff, %rax 
      addq $1, %rax
    \end{lstlisting}
    This is because the result is $0x0$, which is a carry out of the most significant bit and an unsigned overflow.
  \end{example}

  It would be tedious to always set these flags manually, so there are two methods that can be used to \textit{explicitly} set these flags. 

  \begin{definition}[Compare]
    The \textbf{cmp} instruction is used to perform a subtraction between the source and destination, and set the flags accordingly, but it does not store the result.
    \begin{align*}
      \texttt{cmp\_ src, dest} && \texttt{dest - src} 
    \end{align*}
    The following flags are set if the conditions are met: 
    \begin{enumerate}
      \item \textbf{ZF = 1} if \texttt{dest == src} 
      \item \textbf{SF = 1} if \texttt{dest < src} (MSB is 1) 
      \item \textbf{OF = 1} if signed overflow 
      \item \textbf{CF = 1} if unsigned overflow
    \end{enumerate}
  \end{definition}

  \begin{definition}[Test]
    The \textbf{test} instruction is used to perform a bitwise AND operation between the source and destination, and set the flags accordingly. 
    \begin{align*}
      \texttt{test\_ src, dest} && \texttt{dest \& src} 
    \end{align*}
    The following flags are set if the conditions are met. Note that you can't have carry out (CF) or overflow (OF) if these flags are set. 
    \begin{enumerate}
      \item \textbf{ZF = 1} if \texttt{dest \& src == 0} 
      \item \textbf{SF = 1} if \texttt{dest \& src < 0} (MSB is 1) 
    \end{enumerate}
  \end{definition}

  \begin{example}[Compare] 
    Assuming that \texttt{\%al = 0x80} and \texttt{\%bl = 0x81}, which flags are set when we execute \texttt{cmpb \%al, \%bl}? Well we must first compute 
    \begin{equation}
      \texttt{\%bl - \%al = 0x81 - 0x80 = 0x81 + $\sim$ 0x80 + 1 = 0x81 + 0x7F + 1 = 0x101 = 0x01}
    \end{equation}
    \begin{enumerate}
      \item CF=1 since the result is greater than 0xFF (i.e. larger than byte) 
      \item ZF=0 since the result is not 0 
      \item SF=0 since the MSB is 0, i.e. there is unsigned overflow
      \item OF=0 since there is no signed overflow
    \end{enumerate}
  \end{example}

  For conditional moves and jumps later shown, it basically uses these explicit sets and always compares them to $0$. We will see what this means later. 

  Finally, we can actually set a byte in a register to 1 or 0 based on the value of a flag. 

  \begin{definition}[Set]
    
  \end{definition}

  We can then talk about conditional moves and jumps.  

  \begin{definition}[Equality with 0]
    The \texttt{test} instruction is used to perform a bitwise AND operation between the source and destination, and set the flags accordingly. 
    \begin{align*}
      \texttt{test\_ src, dest} && \texttt{dest \& src} 
    \end{align*}
    The \texttt{sete} instruction is used to set the destination to 1 if the zero flag is set, and 0 otherwise. 
    \begin{align*}
      \texttt{sete\_ dest} && \texttt{dest = (ZF == 1) ? 1 : 0} 
    \end{align*}
    The \texttt{cmovne} instruction is used to move the source to the destination if the zero flag is not set. 
    \begin{align*}
      \texttt{cmovne\_ src, dest} && \texttt{dest = (ZF == 0) ? src : dest} 
    \end{align*}
  \end{definition}


  \begin{definition}[Jump]
    There are several jump instructions, but essentially they are used to jump to another part of the code. We can use the following mnemonic to jump to a label. 

    \begin{figure}[H]
      \centering 
      \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
        \hline
        \textbf{Letter} & \textbf{Word} \\ \hline
        j & jump \\ \hline
        n & not \\ \hline
        e & equal \\ \hline
        s & signed \\ \hline
        g & greater (signed interpretation) \\ \hline
        l & less (signed interpretation) \\ \hline
        a & above (unsigned interpretation) \\ \hline
        b & below (unsigned interpretation) \\ \hline
        \end{tabular}
        \caption{Letter to Word Mapping}
        \label{table:letter_word_mapping}
      \end{table}
      \caption{Mnemonic for Jump Instructions} 
      \label{fig:jump_instructions_mnemonic}
    \end{figure}

    For completeness, we include all the jump instructions. 
      
    \begin{figure}[H]
      \centering 
      \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Signed Comparison} & \textbf{Unsigned Comparison} & \textbf{Description} \\ \hline
        je (jz) & & jump if equal (==) or jump if zero \\ \hline
        jne (jnz) & & jump if not equal (!=) \\ \hline
        js & & jump if negative \\ \hline
        jns & & jump if non-negative \\ \hline
        jg (jnle) & ja (jnbe) & jump if greater (>) \\ \hline
        jge (jnl) & jae (jnb) & jump if greater than or equal (>=) \\ \hline
        jl (jnge) & jb (jnae) & jump if less (<) \\ \hline
        jle (jng) & jbe (jna) & jump if less than or equal (<=) \\ \hline
        \end{tabular}
        \caption{Comparison Instructions in Assembly}
        \label{table:comparison_instructions}
      \end{table}
      \caption{All jump instructions} 
      \label{fig:jump_instructions_all}
    \end{figure}
  \end{definition}

  \begin{definition}[int]
    The \texttt{int} instruction is used to generate a software interrupt. It is often used to invoke a system call.
  \end{definition}

  \begin{definition}[ret]
    The \texttt{ret} instruction is used to return from a function. It returns the value in the \texttt{\%rax} register. 
  \end{definition}

  Now we can have a basic idea of how if statements can be used as a sequence of conditionals and jump operators. Let's first look at the \textbf{goto} version of C. 

  \begin{definition}[Goto Syntax]
    The goto version processes instructions sequentially as long as there is no jump. This is useful because compilers translating code into assembly designate a jump when a condition is true. Contrast this behavior with the structure of an if statement, where a "jump" (to the else) occurs when conditions are not true. The goto form captures this difference in logic.
  \end{definition}

  \begin{figure}[H]
    \centering 
    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      int getSmallest(int x, int y) {
        int smallest;
        if ( x > y ) { //if (conditional)
          smallest = y; //then statement
        }
        else {
          smallest = x; //else statement
        }
        return smallest;
      }
      .
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      int getSmallest(int x, int y) {
        int smallest;

        if (x <= y ) { //if (!conditional)
          goto else_statement;
        }
        smallest = y; //then statement
        goto done;

      else_statement:
        smallest = x; //else statement

      done:
        return smallest;
      }      
    \end{lstlisting}
    \end{minipage}
    \caption{C vs GoTo code of the same function. While GoTo code allows us to view C more like assmebly, it is generally not readable and is not considered best practice. } 
    \label{fig:c_vs_goto}
  \end{figure}

  Now let's see how if statements are implemented by taking a look at this function straight up in assembly. 

  \begin{figure}[H]
    \centering 
    \noindent\begin{minipage}{.4\textwidth}
    \begin{lstlisting}[]{Code}
      int getSmallest(int x, int y) {
        int smallest;
        if ( x > y ) { //if (conditional)
          smallest = y; //then statement
        }
        else {
          smallest = x; //else statement
        }
        return smallest;
      }
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.59\textwidth}
    \begin{lstlisting}[]{Output}
      Dump of assembler code for function getSmallest:
      0x40059a <+4>:   mov    %edi,-0x14(%rbp)
      0x40059d <+7>:   mov    %esi,-0x18(%rbp)
      0x4005a0 <+10>:  mov    -0x14(%rbp),%eax
      0x4005a3 <+13>:  cmp    -0x18(%rbp),%eax
      0x4005a6 <+16>:  jle    0x4005b0 <getSmallest+26>
      0x4005a8 <+18>:  mov    -0x18(%rbp),%eax
      0x4005ae <+24>:  jmp    0x4005b9 <getSmallest+35>
      0x4005b0 <+26>:  mov    -0x14(%rbp),%eax
      0x4005b9 <+35>:  pop    %rbp
      0x4005ba <+36>:  retq
    \end{lstlisting}
    \end{minipage}
    \caption{Assembly code of a simple if statement} 
    \label{fig:if_statement}
  \end{figure}

  Again, note that since we are working with int types, the respective parameter registers are \texttt{\%edi} and \texttt{\%esi}, the respective lower 32-bits of the registers \texttt{\%rdi} and \texttt{\%rsi}. Let's walk through this again. 
  \begin{enumerate}
    \item The first mov instruction copies the value located in register \%edi (the first parameter, x) and places it at memory location \%rbp-0x14 on the call stack. The instruction pointer (\%rip) is set to the address of the next instruction, or 0x40059d.
    \item The second mov instruction copies the value located in register \%esi (the second parameter, y) and places it at memory location \%rbp-0x18 on the call stack. The instruction pointer (\%rip) updates to point to the address of the next instruction, or 0x4005a0.
    \item The third mov instruction copies x to register \%eax. Register \%rip updates to point to the address of the next instruction in sequence.
    \item The cmp instruction compares the value at location \%rbp-0x18 (the second parameter, y) to x and sets appropriate condition code flag registers. Register \%rip advances to the address of the next instruction, or 0x4005a6.
    \item The jle instruction at address 0x4005a6 indicates that if x is less than or equal to y, the next instruction that should execute should be at location <getSmallest+26> and that \%rip should be set to address 0x4005b0. Otherwise, \%rip is set to the next instruction in sequence, or 0x4005a8.
  \end{enumerate}

  With the \texttt{cmov} instruction, this can be a lot shorter. With the gcc compiler with level 1 optimizations turned on, we can see that a lot of redundancies are turned off. 

  \begin{figure}[H]
    \centering 
    \begin{lstlisting}
      <getSmallest>:
      0x400546 <+0>: cmp    %esi,%edi      #compare x and y
      0x400548 <+2>: mov    %esi,%eax      #copy y to %eax
      0x40054a <+4>: cmovle %edi,%eax      #if (x<=y) copy x to %eax
      0x40054d <+7>: retq                  #return %eax
    \end{lstlisting}
    \caption{Compiled with \texttt{gcc -01 -o getSmallest getSmallest.c} } 
    \label{fig:if_statement_optimized}
  \end{figure}

  Like if statements, loops in assembly can be implementing using jump functions that revisit some instruction address based on the result on an evaluated condition. Let's take a look at a basic loop function. 

  \begin{figure}[H]
    \centering 
    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      int sumUp(int n) {
        int total = 0;
        int i = 1;

        while (i <= n) {  
          total += i;   
          i++; 
        }
        return total;
      }
      .
      .
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      Dump of assembler code for function sumUp:
      0x400526 <+0>:   push   %rbp
      0x400527 <+1>:   mov    %rsp,%rbp
      0x40052a <+4>:   mov    %edi,-0x14(%rbp)
      0x40052d <+7>:   mov    $0x0,-0x8(%rbp)
      0x400534 <+14>:  mov    $0x1,-0x4(%rbp)
      0x40053b <+21>:  jmp    0x400547 <sumUp+33>
      0x40053d <+23>:  mov    -0x4(%rbp),%eax
      0x400540 <+26>:  add    %eax,-0x8(%rbp)
      0x400543 <+29>:  add    $0x1,-0x4(%rbp)
      0x400547 <+33>:  mov    -0x4(%rbp),%eax
      0x40054a <+36>:  cmp    -0x14(%rbp),%eax
      0x40054d <+39>:  jle    0x40053d <sumUp+23>
      0x40054f <+41>:  mov    -0x8(%rbp),%eax
      0x400552 <+44>:  pop    %rbp
      0x400553 <+45>:  retq
    \end{lstlisting}
    \end{minipage}
    \caption{Simple loop function in C and assembly. } 
    \label{fig:loop_function}
  \end{figure}

  Finally, we want to let the reader know the convention of calle and caller saved registers. The compiler tries to pick these registers, and by convention in x86, we have the following. 

  \begin{figure}[H]
    \centering 
    \includegraphics[scale=0.4]{img/caller_callee_save.png}
    \caption{Caller save and callee save registers. } 
    \label{fig:caller_callee_save}
  \end{figure}

  So far, we've traced through simple functions in assembly. In this section, we discuss the interaction between multiple functions in assembly in the context of a larger program. We also introduce some new instructions involved with function management. 

  \begin{definition}[Leave]
    The \textbf{leave} instruction is used to deallocate the current stack frame. For example, the leaveq instruction is a shorthand that the compiler uses to restore the stack and frame pointers as it prepares to leave a function. When the callee function finishes execution, leaveq ensures that the frame pointer is restored to its previous value. It is equivalent to the following two instructions: 
    \begin{align*}
      \texttt{leaveq} && \texttt{movq \%rbp, \%rsp} \\
                      && \texttt{popq \%rbp}
    \end{align*}
  \end{definition}

  \begin{definition}[Call and Return]
    The \textbf{call} instruction is used to call a function and the \textbf{ret} to return from a function. The callq and retq instructions play a prominent role in the process where one function calls another. Both instructions modify the instruction pointer (register \%rip). 

    \begin{enumerate}
      \item When the caller function executes the callq instruction, the current value of \%rip is saved on the stack to represent the return address, or the program address at which the caller resumes executing once the callee function finishes. The callq instruction also replaces the value of \%rip with the address of the callee function. 
        \begin{align*}
          \texttt{callq addr <fname>} && \texttt{push \%rip} \\
                                      && \texttt{mov addr, \%rip}
        \end{align*}
      \item The retq instruction restores the value of \%rip to the value saved on the stack, ensuring that the program resumes execution at the program address specified in the caller function. Any value returned by the callee is stored in \%rax or one of its component registers (e.g., \%eax). The retq instruction is usually the last instruction that executes in any function.
        \begin{align*}
          \texttt{retq} && \texttt{pop \%rip} \\
        \end{align*}
    \end{enumerate}
  \end{definition}

  Let's work through an example to solidify our knowledge. 

  \begin{example}[Calling Functions in Assembly]
    Let's take the following code and trace through main. 
    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.25\textwidth}
      \begin{lstlisting}[]{Code}
        #include <stdio.h>

        int assign(void) {
            int y = 40;
            return y;
        }

        int adder(void) {
            int a;
            return a + 2;
        }

        int main(void) {
            int x;
            assign();
            x = adder();
            printf("x is: %d\n", x);
            return 0;
        }
        .
        .
        .
        .
        .
        .
        .
        .
        .
        .
        .
        .
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.74\textwidth}
      \begin{lstlisting}[]{Output}
        0000000000400526 <assign>:
          400526:       55                      push   %rbp
          400527:       48 89 e5                mov    %rsp,%rbp
          40052a:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%rbp)
          400531:       8b 45 fc                mov    -0x4(%rbp),%eax
          400534:       5d                      pop    %rbp
          400535:       c3                      retq

        0000000000400536 <adder>:
          400536:       55                      push   %rbp
          400537:       48 89 e5                mov    %rsp,%rbp
          40053a:       8b 45 fc                mov    -0x4(%rbp),%eax
          40053d:       83 c0 02                add    $0x2,%eax
          400540:       5d                      pop    %rbp
          400541:       c3                      retq

        0000000000400542 <main>:
          400542:       55                      push   %rbp
          400543:       48 89 e5                mov    %rsp,%rbp
          400546:       48 83 ec 10             sub    $0x10,%rsp
          40054a:       e8 e3 ff ff ff          callq  400526 <assign>
          40054f:       e8 d2 ff ff ff          callq  400536 <adder>
          400554:       89 45 fc                mov    %eax,-0x4(%rbp)
          400557:       8b 45 fc                mov    -0x4(%rbp),%eax
          40055a:       89 c6                   mov    %eax,%esi
          40055c:       bf 04 06 40 00          mov    $0x400604,%edi
          400561:       b8 00 00 00 00          mov    $0x0,%eax
          400566:       e8 95 fe ff ff          callq  400400 <printf@plt>
          40056b:       b8 00 00 00 00          mov    $0x0,%eax
          400570:       c9                      leaveq
          400571:       c3                      retq
      \end{lstlisting}
      \end{minipage}
      \caption{C code and its assembly equivalent. Main function calls two other functions. } 
      \label{fig:calling_functions}
    \end{figure}

    Let's trace through what happens here in detail. This will be long. 

    \begin{enumerate}
      \item \texttt{\%rbp} is the base pointer that is initialized to something. Before we even begin main, say that we have the following initializations, where \texttt{\%eax}, \texttt{\%edi} is garbage. \texttt{\%rsp} denotes where on the stack we are right before calling to main, \textbf{\%rbp} is the base pointer to the current program, and \textbf{\%rip} should be the address of the first instruction in main. Again since we work with integers we use the lower 32-bits of the registers. \texttt{\%rip} now points to the next instruction. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide1.png}
        \end{center}  

      \item Now we start the main function. By calling main, the base pointer \texttt{\%rbp} of the stack outside of the main frame will be overwritten by the base of the main stack frame, so we must save it for when main is done. Therefore, we push it onto the stack where \texttt{\%rsp} is pointing. \texttt{\%rip} now points to the next instruction. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide2.png}
        \end{center}

      \item Then we actually change the location of the base pointer to the top of the stack, which now includes the first instruction in main. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide3.png}
        \end{center} 

      \item Now we manually change the stack pointer and have it grow by two bytes (\texttt{0x10}). Therefore, \texttt{\%rsp} is decremented by \texttt{0x10} and \texttt{\%rip} points to the next instruction at \texttt{0x54a}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide4.png}
        \end{center}
        
      \item Now the next instruction pointed at by \texttt{\%rip} is the \texttt{callq} instruction, which tells to go to the address of the \texttt{assign} function. We by default first update \texttt{\%rip} to point to the next instruction at \texttt{0x55f}. However, this should not be the actual next instruction that we execute since we are calling another function. Rather, we want to update \texttt{\%rip} to address \texttt{0x526} where \texttt{assign} is located at, but after completion we also want to know that we want to execute the instruction after it at address \texttt{0x55f}. Therefore, we should \textit{save} address \texttt{0x55f} onto the stack and then update \texttt{\%rip} to point to \texttt{0x526}. This is what we refer to as a \textbf{return address}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide5.png}
        \end{center}

      \item \texttt{\%rip} is incremented to the next address. We step into the \texttt{assign} function, which is now a new stack frame, so the first thing we do is save the base pointer of the main stack frame onto the stack since we must immediately update it with the base pointer of the assign stack frame, which is where \texttt{\%rsp} is pointing to. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide6.png}
        \end{center}

      \item \texttt{\%rip} is incremented to the next address. We then update the base pointer to the top of the stack. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide7.png}
        \end{center}

      \item Now we want to move the number \texttt{0x28} (40) into the memory location \texttt{-0x4(\%rbp)} of the stack, which is 4 bytes above the frame pointer, which is also the stack pointer. It is common that the frame pointer is used to reference locations on the stack. Note that this does not update the stack pointer.  
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide8.png}
        \end{center}

      \item Now we take the same address where we stored \texttt{0x28} to and move it into \texttt{\%eax}, effectively loading 40 onto the return value. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide9.png}
        \end{center}

      \item We see that we will return this value soon, but before we do, we want to make sure that when the assign stack frame gets deleted (not really, but overwritten), we want to restore the base pointer of the main stack frame. We have already saved this before at \texttt{\%rsp}, which hasn't changed since we only worked with displacements from the base pointer. We retrieve the main stack pointer data and load it back into \texttt{\%rbp}. Note that this increments \texttt{\%rsp} by 8 bytes, shrinking the stack, and we are technically out of the assign stack frame. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide10.png}
        \end{center} 

      \item Note that at this point, since \texttt{\%rbp} was popped off, the next value that is at the top of the stack is the address \texttt{\%rip} that we store earlier, which points to the next execution in main. When \texttt{retq} executes, this value at the top of the stack is popped into \texttt{\%rip}, allowing main to continue executing within the main stack frame. Note that the return value is stored in \texttt{\%eax}.
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide11.png}
        \end{center}

      \item Now we execute the next instruction in \texttt{\%rip} which is a call to the \texttt{adder} function. \texttt{\%rip} is automatically updated to the next address at \texttt{0x554}, but since this is a \texttt{callq} instruction, we first want to store this \texttt{\%rip} into the stack so we can come back to it, and then update \texttt{\%rip} to the first instruction in \texttt{adder}, which is address \texttt{0x536}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide12.png}
        \end{center}

      \item Since we are in the adder function, this creates a new stack frame and we must update \texttt{\%rbp}. Again, we don't want to overwrite the base pointer of main, so we save it onto the stack by pushing \texttt{\%rbp}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide13.png}
        \end{center}

      \item Then we update \texttt{\%rbp} to the current stack pointer. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide14.png}
        \end{center}

      \item This part is a bit tricky. Note that the value of \texttt{0x28} still lives at \texttt{0xd1c}, which is conveniently at address \texttt{-0x4(\%rbp)}. Therefore, when we call \texttt{int a;} in that corresponding line in \texttt{adder}, we can actually add 2 to it, though it seems like there was no value assigned to it. This is just a trick though. So, we can take these remnant value and store it into \texttt{\%eax}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide15.png}
        \end{center}

      \item We then add 2 to it. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide16.png}
        \end{center}

      \item Now we are almost done, so we pop the base pointer of the main stack frame, at \texttt{0xd40}, back into \texttt{\%rbp}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide17.png}
        \end{center}

      \item We now return the value in \texttt{\%eax} and pop the base pointer of the adder stack frame, which simply updates the instruction pointer \texttt{\%rip} back to the next instruction in main. This is equivalent to \texttt{pop \%rip}, which is equivalent to moving the stack pointer \texttt{\%rsp} into \texttt{\%rip} and then shrinking the stack by 8 bytes \texttt{subq \$8, \%rsp}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide18.png}
        \end{center}

      \item Now it is relatively straightforward since we do the rest in main (except for the print statement). The current value in \texttt{\%eax} represents the return value of adder. We want to put this in the variable \texttt{x}, which we have already allocated some memory for right above the base pointer in the main stack frame. We move it there. Note that right after, it places this right back into \texttt{\%eax}.
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide19.png}
        \end{center}

      \item the mov instruction at address 0x55a copies the value in \texttt{\%eax} (or 0x2A) to register \texttt{\%esi}, which is the 32-bit component register associated with \texttt{\%rsi} and typically stores the second parameter to a function. We can see why since this will be put into a print statement, which is a function, and \texttt{x = \%esi} is the second argument of \texttt{printf}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide21.png}
        \end{center}

      \item Now we want to retrieve the first argument of the print function. The address at \texttt{\$0x400604} is some address in the code segment memory that holds the string \texttt{"x is \%d\textbackslash n"}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide22.png}
        \end{center}

      \item Then we move $0$ into the \texttt{\%eax} register to clear it. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide23.png}
        \end{center} 

      \item We then call the \texttt{printf} function, which we won't trace through but it outputs to stdout.  
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide24.png}
        \end{center}

      \item The print function might have returned something, but we don't care. We want to main function to return 0, so we move 0 into \texttt{\%eax}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide25.png}
        \end{center}

      \item Finally we execute \texttt{leaveq}, which prepares the stack for returning from the function call. It essentially moves the base pointer back to the stack pointer and then pops the base pointer off the stack. The new \texttt{\%rbp} is the original base pointer of whatever was outside the main function, \texttt{0x830}. 
        \begin{center}
          \includegraphics[scale=0.5]{img/Slide26.png}
        \end{center}

      \item Finally, we execute \texttt{retq}, which pops the return address off the stack and puts it into \texttt{\%rip}. 
    \end{enumerate}
  \end{example}

  We have omitted the details of caller and callee saved registers, but they do exist and are important for the general implementations. 

  For arrays, there's not anything new here. Let's go over some code and follow through it. 

  \begin{lstlisting}
    int sumArray(int *array, int length) {
      int i, total = 0;
      for (i = 0; i < length; i++) {
        total += array[i];
      }
      return total;
    }
  \end{lstlisting}

  This function takes the address of an array and the length of it and sums up all the elements in the array. 

  \begin{lstlisting}
    0x400686 <+0>:	push %rbp                   # save %rbp
    0x400687 <+1>:	mov  %rsp,%rbp              # update %rbp (new stack frame)
    0x40068a <+4>:	mov  %rdi,-0x18(%rbp)       # copy array to %rbp-0x18
    0x40068e <+8>:	mov  %esi,-0x1c(%rbp)       # copy length to %rbp-0x1c
    0x400691 <+11>:	movl $0x0,-0x4(%rbp)        # copy 0 to %rbp-0x4 (total)
    0x400698 <+18>:	movl $0x0,-0x8(%rbp)        # copy 0 to %rbp-0x8 (i)
    0x40069f <+25>:	jmp  0x4006be <sumArray+56> # goto <sumArray+56>
    0x4006a1 <+27>:	mov  -0x8(%rbp),%eax        # copy i to %eax
    0x4006a4 <+30>:	cltq                        # convert i to a 64-bit integer
    0x4006a6 <+32>:	lea  0x0(,%rax,4),%rdx      # copy i*4 to %rdx
    0x4006ae <+40>:	mov  -0x18(%rbp),%rax       # copy array to %rax
    0x4006b2 <+44>:	add  %rdx,%rax              # compute array+i*4, store in %rax
    0x4006b5 <+47>:	mov  (%rax),%eax            # copy array[i] to %eax
    0x4006b7 <+49>:	add  %eax,-0x4(%rbp)        # add %eax to total
    0x4006ba <+52>:	addl $0x1,-0x8(%rbp)        # add 1 to i (i+=1)
    0x4006be <+56>:	mov  -0x8(%rbp),%eax        # copy i to %eax
    0x4006c1 <+59>:	cmp  -0x1c(%rbp),%eax       # compare i to length
    0x4006c4 <+62>:	jl   0x4006a1 <sumArray+27> # if i<length goto <sumArray+27>
    0x4006c6 <+64>:	mov  -0x4(%rbp),%eax        # copy total to %eax
    0x4006c9 <+67>:	pop  %rbp                   # prepare to leave the function
    0x4006ca <+68>:	retq                        # return total
  \end{lstlisting}


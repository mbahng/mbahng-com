\section{Composition} 

  Sometimes, inheritance may not be the right way. There can be a lot of independent properties of a certain class that we would like to model, so we can have child classes across different cross sections. 

  \begin{example}[Visible, Solid, and Movable Objects]
    The example in \href{https://en.wikipedia.org/wiki/Composition_over_inheritance#Example}{Wikipedia} summarizes it nicely. Say you have some an interface to represent any object in the game, and you define three subtypes describing the properties it has. 

    \begin{lstlisting}
      class Object {
      public:
        virtual void update() {}
        virtual void draw() {}
        virtual void collide(Object objects[]) {}
      };

      class Visible : public Object
      {
          Model* model;

      public:
          virtual void draw() override {
              // code to draw a model at the position of this object
          }
      };

      class Solid : public Object
      {
      public:
          virtual void collide(Object objects[]) override {
              // code to check for and react to collisions with other objects
          }
      };

      class Movable : public Object
      {
      public:
          virtual void update() override {
              // code to update the position of this object
          } 
      } 
    \end{lstlisting} 

    If we want to implement the following concrete classes: 
    \begin{enumerate}
      \item class \texttt{Player} which is \texttt{Solid}, \texttt{Movable}, and \texttt{Visible}, 
      \item class \texttt{Cloud}, which is \texttt{Movable} and \texttt{Visible} but not \texttt{Solid}, 
      \item class \texttt{Building} which is \texttt{Solid} and \texttt{Visible} but not \texttt{Movable}, 
      \item class \texttt{Trap} which is \texttt{Solid} but neither \texttt{Visible} not \texttt{Movable}. 
    \end{enumerate} 
    Multiple inheritance is dangerous as we've seen before since it can lead to the diamond problem. One solution to this is the create classes such as \texttt{VisibleAndSolid}, \texttt{VisibleAndMovable}, etc. for all combinations, but this leads to repetitive code. 
  \end{example}

  There must be a better way to organize this, and indeed composition comes to our rescue. The general idea is that rather than modeling the classes with \textit{is-a} relationships, it is better to compose what an object can do with a \textit{has-a} relationship. 

  \begin{definition}[Object Composition]
    \textbf{Object composition} is the principle that objects should contain instances of other classes that implement the desired functionality. 
  \end{definition} 

  \begin{definition}[Delegation]
    
  \end{definition}

  In fact, object composition is so popular that there is a popular saying of \textit{composition over inheritance}. It generally leads to more flexible and modular designs, leveraging the idea of building classes out of \textit{components} rather than trying to find some commonality between them and creating a family tree. 



\section{Program Lifecycle Phases}

  First, we review some definitions. More on program lifecycle phases \href{https://en.wikipedia.org/wiki/Program_lifecycle_phase}{here}. Programming languages are broadly classified into two types. \textbf{High-level languages} are the familiar programming languages that we work with today (that allow much more abstraction), while \textbf{low-level languages} are very close to the hardware, such as machine language and assembly language. Programmers write programs in \textbf{source code} (usually high-level languages), which are then inputted into \textbf{language processors} that translate them into \textbf{object code} (usually \textbf{machine code} consisting of binary). The duration in which the source code of the program is being edited is called the \textbf{edit time}, while the \textbf{compile time} is when the source code is translated into machine code by a language processor. There are three types of language processors.
  \begin{enumerate}
    \item A \textbf{compiler} is a language processor that reads the complete source program written in high-level language as a whole in one go and translates it into an equivalent program in machine language. The source code is translated to object code successfully if it is free of errors. The compiler specifies the errors at the end of the compilation with line numbers when there are any errors in the source code. The errors must be removed before the compiler can successfully recompile the source code again. (e.g. C, C++, C\#, Java)
    
    \item An \textbf{assmebler} is used to translate the program written in Assembly language (basically a low-level language with very strong correspondence between the instructions in the language and the machine code instructions) into machine code. The assembler is basically the 1st interface that is able to communicate humans with the machine. We need an assembler to fill the gap between human and machine so that they can communicate with each other. Code written in assembly language is some sort of mnemonics (instructions) like ADD, MUL, MUX, SUB, DIV, MOV and so on, and the assembler is basically able to convert these mnemonics into binary code.

    \item An \textbf{interpreter} translates a single statement of the source program into machine code and executes immediately before moving on to the next line. If there is an error in the statement, the interpreter terminates its translating at that statement and displays an error message. The interpreter moves on to the next line for execution only after the removal of the error. An interpreter directly executes instructions written source code without previously converting them to an object code or machine code. (e.g. Python, Pearl, JavaScript, Ruby)
  \end{enumerate}
  A quick compare and contrast.
  \begin{table}
  \centering
  \begin{tabular}{|p{7cm}|p{7cm}|}
  \hline
  \textbf{Compiler} & \textbf{Interpreter} \\
  \hline
  Takes more time to analyze source code but execution time is faster. & Takes less time to analyze source code but execution time is slower. \\
  \hline
  Debugging is harder since the compiler generates an error message after the entire scan. & Debugging is easier since the interpreter continues translating the program until an error is met. \\
  \hline
  Requires a lot of memory for generating object codes. & Requires less memory because no object code is generated. \\
  \hline
  Generates intermediate object code. & No intermediate object code is generated. \\
  \hline
  \end{tabular}
  \end{table}

  The result of a successful compilation is an executable, which is a program in the form of a file containing millions of lines of very simple machine code instructions (e.g. add 2 numbers or compare 2 numbers), also called \textbf{processor instructions}. This executable can be stored somewhere in the computer drive for future use or it may be copied immediately in a faster memory state, such as the RAM. The \textbf{load time} is when the OS takes the program's executable from storage and puts it into an active memory (e.g. RAM) in order to begin execution. 

  The CPU understands only a low level machine code language (aka native code), which is contained within the executable. The language of the machine code is hardwired into the design of the CPU hardware; it is not something that can be changed at will. Each family of compatible CPUs (e.g. the popular Intel x86 family) has its own, idiosyncratic machine code which is not compatible with the machine code of other CPU families. More information \href{https://web.stanford.edu/class/cs101/software-1.html}{here}. Once the instruction bytes are copied from storage to RAM, the CPU can run through the steps/lines at the rate of about 2 billion lines/steps per second. This execution phase, when the CPU executes the instructions until normal termination or a crash, is called the \textbf{runtime}.

\subsection{More on Executables}

  More specifically, an \textbf{executable} is a file that contains a list of instructions and data to cause a computer's CPU to perform indicated tasks, as opposed to the data files, which are fundamentally strings of data that must be interpreted (parsed) by a program to be meaningful. Executables usually have extension names $\texttt{.exe}$ or $\texttt{.bat}$, and they can generally be run (invoked) in two ways: 
  \begin{enumerate}
      \item The executable file can be run by simply double clicking on the file name, opening it, and having the user type commands in an interactive session of an interpter (like inputting commands in terminal window or a python shell).
      \item Alternatively, we can start writing a program, complete writing it, and then have this program compiled into an executable to be invoked.
  \end{enumerate}
  Some common examples of executables are:
  \begin{enumerate}
      \item python.exe - used to run python scripts that have the .py extension, located at 
      \[\texttt{C: \textbackslash Users\textbackslash bahng\textbackslash AppData\textbackslash Local\textbackslash Programs\textbackslash Python\textbackslash Python39}\]
      \item pythonw.exe - used to run .pyw files for GUI programs
      \item terminal.exe (on MacOS)
      \item cmd.exe (on Windows OS)
      \item py.exe - an executable used to run the python.exe executable like a shortcut, located at 
      \[\texttt{C:\textbackslash windows\textbackslash py.exe}\]
  \end{enumerate}

\subsection{Static vs Dynamic Languages}

  \textbf{Type-checking} is the process of checking and verifying the type of a construct (constant, variable, array, list, object) and its usage context. It helps in minimizing the possibility of type errors in the program, and type checking may occur either at compile-time (static checking) or at run-time (dynamic checking). 
  \begin{enumerate}
    \item \textbf{Statically-Typed Languages}: Since we type check during compilation, every detail about the variables and all the data types must be known before we do the compiling process. Once a variable is assigned a type, it can't be assigned to some other variable of a different type, and so the data type of a declared variable is fixed. This makes sense since in Java, C, C++, etc., the programmer must specify what the data type of each variable is by writing something like $\texttt{int myNum = 15}$.

    \item \textbf{Dynamically-Typed Languages}: Since we type-check during runtime, there is no need to specify the data type of each variable while writing code, which improves writing speed. These languages have the capability to identify the type of each variable during run-time, so we do not need to declare the data types of variables. In these languages, variables are bound to objects at run-time using assignment statements, and most modern languages (e.g. JavaScript, Python, PHP, etc.) are dynamically typed.
  \end{enumerate}


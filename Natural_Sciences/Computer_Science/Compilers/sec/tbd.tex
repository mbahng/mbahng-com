\section{Conversation with Patrick}

  The reason you define types and classes is to control how you interpret/encode data. Fundamentally all programming is manipulating bits. Safety measure on ourselves and convenience. 

  \begin{definition}[Object]
    An \textbf{object}\footnote{There is a bit of a circular definition with classes, but we'll ignore this for now.} $o$ is a run-time entity that packages both 
    \begin{enumerate}
      \item data, also called \textit{attributes}, and 
      \item the procedures---also called \textit{methods}---that operate on that data.
    \end{enumerate}
  \end{definition} 

  \begin{definition}[Signature]
    The \textbf{signature} of a method $f$ defines its name, parameters, and the return value.  
  \end{definition}

  \begin{definition}[Interface]
    An \textbf{interface} of an object $o$ is set of all signatures defined by its operations. The interface describes the set of requests to which an object can respond. 
  \end{definition} 

  \begin{definition}[Type]
    A \textbf{type} is the name of a particular interface. 
    \begin{enumerate}
      \item A type $A$ \textbf{subtype} of another $B$ if its interface contains the interface of $B$. 
      \item A type $B$ \textbf{supertype} of another $A$ if $A$'s interface contains the interface of $B$. 
    \end{enumerate}
  \end{definition} 

  Note that while we have talked about interfaces through signatures, we haven't actually described how the functions are actually \textit{implemented}. In object-oriented design, we want to decouple these two concepts, and objects are known only through their interfaces. 

  \begin{definition}[Implementation]
    An \textbf{implementation} of 
    \begin{enumerate}
      \item a method $f$ describes the actual computations done within the function. 
      \item an object $o$ describes the implementations of all of its methods
    \end{enumerate}
  \end{definition}

  \begin{example}[Multiplication]
    A function that multiplies two numbers might have a signature that looks like
    \begin{lstlisting}
      int multiply(int x, int y)
    \end{lstlisting} 
    But the implementations may differ. 
    
    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        int multiply(int x, int y) {
          return x * y;
        }
        .
        .
        .
        .
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        int multiply(int x, int y) {
          int res = 0; 
          for (int i = 0; i < y; i++) {
            res += x
          } 
          return res;
        }
      \end{lstlisting}
    \end{minipage}
  \end{example} 

  \begin{definition}[Class]
    A \textbf{class} $C(a_1, \ldots, a_n, m_1, \ldots, m_k)$ is defines an object's interface and implementation. Objects are created by \textbf{instantiating} a class, and the object is said to be an \textbf{instance} of the class. 
    \begin{enumerate}
      \item An \textbf{abstract class} is a class whose primary purpose is to define an interface and defers some or all of its implementation to subclasses. An abstract class cannot be instantiated. Its methods are called \textbf{abstract operations}, which is an operation that declares a signature but doesn't implement it.\footnotemark
      \item A \textbf{concrete class} is a class which has no abstract operations and can be instantiated. 
    \end{enumerate}
    
    \begin{figure}[H]
      \centering 
      {\hbadness=10000
      \begin{tikzpicture}
        \begin{class}[text width=8cm]{className}{0,0}
          \attribute{name : attribute type}
          \attribute{name : attrribute type = default value}
          \operation{method(parameter list) : type of value returned}
        \end{class}
      \end{tikzpicture}
      }
      \caption{Class diagram depicts classes, their internal structure and operations, and the static relationships between them. The top box is the class name, the middle contains the attributes, and the bottom contains the methods.} 
      \label{fig:class_diagram}
    \end{figure}

    \footnotetext{In this sense, an abstract class is closer to an interface than an actual class, and we should view it as such.}
  \end{definition}


  This is why when you look at Python's docs, you see \textit{type} hierarchy that defines interfaces (e.g. \texttt{numbers.Real}), which are abstract base classes.\footnote{Python models interfaces with ABCs. }


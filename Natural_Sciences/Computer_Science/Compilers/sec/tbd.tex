\section{Jan 7} 

  Will be working in tiger. 
  \begin{enumerate}
    \item \textit{Lexer}. Convert a sequence of characters into a sequence of tokens. Need to talk about DFA, NFA, and regular expressions.  
    \item \textit{Parsing}. Building the abstract syntax tree. e.g. LL parsing (what we are doing) vs LR parsing. MLyac. Trees make everything explicit and so is easier to work with. 
    \item \textit{Type Checking}. 
    \item \textit{IR}. Top of the mountain. 
    \item \textit{Instruction Selection}. 
    \item \textit{Liveness Analysis}. Data flow analysis, which is at the core of a lot of optimization. 
    \item \textit{Register Allocation}. This gives the MIPS assembly, which is text. 
  \end{enumerate}

  Expression evaluates to a value, while a statement is ...
  SMl-NJ, sort of functional.

\section{Regular Expressions} 

  \begin{example}
    The syntax for all numbers might look something like 
    \begin{lstlisting}
      0 | (-? [1-9][0-9])
    \end{lstlisting}
  \end{example}

  To compute on regular expressions (i.e. matching a string with a regular expression), it is generally hard. 

  A little side track to DFA. Can we turn regular expressions into DFA? Yes. We do it through NFA.  

\section{Lexers}

\section{Jan 14} 

  Last time, we found out that regexs are hard to compute, so we need DFAs and NFAs to compute. We can turn an NFA into a DFA. We like NFAs since it's easier to convert a regex into an NFA and then into a DFA. This allows us to write a nice declarative.  

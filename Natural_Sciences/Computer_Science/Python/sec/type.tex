\section{Types} 

  The development of the Python type hierarchy is a bit involved and requires you to know both implementation details and history. During the early days of Python 2, the language had both \textit{types} and \textit{classes}. Types were built-in objects implemented in C, and classes were what you built when using a \texttt{class} statement. These two were named differently because you couldn't mix these; classes could not extend types. However, this difference was artificial and ultimately a limitation in the language implementation. Starting with Python 2.2, the developers of Python have slowly moved towards unifying the two concepts, which the difference completely done in Python 3. Built-in types are now labeled classes, and you can extend them at will. Since we are working in Python 3, they are interchangeable.  

  \begin{theorem}[Types and Classes]
    In Python 3, types and classes mean the same thing. 
  \end{theorem} 

  Let's do a bit of review on classes. 

  \begin{definition}[Class] 
    A \textbf{class} is a template for creating objects, which support \textit{attributes} to store some state and \textit{methods} that may or may not modify the state. The object that is created from a class is called a \textbf{class instance}. 

    \begin{lstlisting}
      class ClassName: 
        ...  
    \end{lstlisting}
  \end{definition}

  \begin{example}[Animal Class Definition]
    A class can be instantiated with the following. 

    \begin{figure}[H]
      \centering 
      \begin{lstlisting}
        class Animal: 
            def __init__(self, name):
                self.name = name
            
            def speak(self):
                return f"{self.name} makes a sound"
      \end{lstlisting} 
      \caption{} 
      \label{fig:animal_class}
    \end{figure}
  \end{example}  

\subsection{Dunder Methods}

  It is important to have good tools to analyze the class itself and the instance. These are mainly stored in \textit{dunder (double underscore)} methods, also called \textit{magic methods}. 

  \begin{definition}[Class and Type Information]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Functions} & \textbf{Description} \\
        \hline 
        \texttt{hasattr(obj, "attr\_name")} & checks if an object has a specific attribute \\
        \hline
        \texttt{isinstance(obj, ClassA)} & checks if an object is an instance of a class \\
        \hline
        \texttt{issubclass(ClassA, ClassB)} & checks if one class is a subclass of another \\
        \hline
        \texttt{type(obj)} & returns the type/class of an object \\
        \hline
        \texttt{dir(obj)} & lists all attributes and methods of an object \\
        \hline
        \texttt{vars(obj)} & returns the \_\_dict\_\_ of an object \\
        \hline
        \texttt{obj.\_\_dict\_\_} & dictionary containing the object's attributes \\
        \hline
        \texttt{obj.\_\_class\_\_} & reference to the object's class \\
        \hline
        \texttt{ClassA.\_\_name\_\_} & name of the class \\
        \hline
        \texttt{ClassA.\_\_module\_\_} & module where the class was defined \\
        \hline
        \texttt{ClassA.\_\_bases\_\_} & tuple of base classes \\
        \hline
        \texttt{ClassA.\_\_mro\_\_} & method resolution order tuple \\
        \hline
        \texttt{\_\_getattr\_\_(self, name)} & called when attribute doesn't exist \\
        \hline
        \texttt{\_\_setattr\_\_(self, name, value)} & called when setting attributes \\
        \hline
        \texttt{\_\_delattr\_\_(self, name)} & called when deleting attributes \\
        \hline
        \texttt{\_\_getattribute\_\_(self, name)} & called for all attribute access \\
        \hline
      \end{tabular}
      \caption{Class instances (objects) are marked with \texttt{obj} and Class definitions with \texttt{ClassA}.}
      \label{tab:functions_for_classes}
    \end{table}
  \end{definition}

  \begin{definition}[Documentation and Metadata]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Attributes} & \textbf{Description} \\
        \hline 
        \texttt{obj.\_\_doc\_\_} & docstring of the class or method \\
        \hline
        \texttt{obj.\_\_annotations\_\_} & type annotations dictionary \\
        \hline
      \end{tabular}
      \caption{Documentation and metadata attributes for classes and objects.}
      \label{tab:documentation_metadata}
    \end{table}
  \end{definition}

  \begin{definition}[Object Lifecycle]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_init\_\_(self, ...)} & constructor method \\
        \hline
        \texttt{\_\_new\_\_(cls, ...)} & object creation method (called before \_\_init\_\_) \\
        \hline
        \texttt{\_\_del\_\_(self)} & destructor method \\
        \hline
      \end{tabular}
      \caption{Methods that control object creation and destruction.}
      \label{tab:object_lifecycle}
    \end{table}
  \end{definition}

  \begin{definition}[String Representation]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_str\_\_(self)} & informal string representation (used by str()) \\
        \hline
        \texttt{\_\_repr\_\_(self)} & official string representation (used by repr()) \\
        \hline
      \end{tabular}
      \caption{Methods for string representation of objects.}
      \label{tab:string_representation}
    \end{table}
  \end{definition}

  \begin{definition}[Comparison and Hashing]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_eq\_\_(self, other)} & equality comparison (==) \\
        \hline
        \texttt{\_\_lt\_\_(self, other)} & less than comparison (<) \\
        \hline
        \texttt{\_\_gt\_\_(self, other)} & greater than comparison (>) \\
        \hline
        \texttt{\_\_le\_\_(self, other)} & less than or equal (<=) \\
        \hline
        \texttt{\_\_ge\_\_(self, other)} & greater than or equal (>=) \\
        \hline
        \texttt{\_\_ne\_\_(self, other)} & not equal (!=) \\
        \hline
        \texttt{\_\_hash\_\_(self)} & hash value for the object \\
        \hline
      \end{tabular}
      \caption{Methods for object comparison and hashing.}
      \label{tab:comparison_hashing}
    \end{table}
  \end{definition}

  \begin{definition}[Container-like Behavior]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_len\_\_(self)} & length of the object \\
        \hline
        \texttt{\_\_getitem\_\_(self, key)} & get item by index/key (obj[key]) \\
        \hline
        \texttt{\_\_setitem\_\_(self, key, value)} & set item by index/key (obj[key] = value) \\
        \hline
        \texttt{\_\_delitem\_\_(self, key)} & delete item by index/key (del obj[key]) \\
        \hline
        \texttt{\_\_iter\_\_(self)} & makes object iterable \\
        \hline
        \texttt{\_\_contains\_\_(self, item)} & supports 'in' operator \\
        \hline
      \end{tabular}
      \caption{Methods that make objects behave like containers.}
      \label{tab:container_behavior}
    \end{table}
  \end{definition}

  \begin{definition}[Mathematical Operations] 
    Most of the math operators in Python (\texttt{+}, \texttt{-}, ...) actually call some dunder method. We can define these dunder methods in order to use mathematical operations on class objects, e.g. \texttt{a + b}. 

    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_add\_\_(self, other)} & called when we evaluate \texttt{self + other} \\
        \hline
        \texttt{\_\_sub\_\_(self, other)} & called when we evaluate \texttt{self - other} \\
        \hline
        \texttt{\_\_mul\_\_(self, other)} & called when we evaluate \texttt{self * other} \\
        \hline
        \texttt{\_\_truediv\_\_(self, other)} & called when we evaluate \texttt{self / other} \\
        \hline
        \texttt{\_\_floordiv\_\_(self, other)} & called when we evaluate \texttt{self // other} \\
        \hline
        \texttt{\_\_mod\_\_(self, other)} & called when we evaluate \texttt{self \% other} \\
        \hline
        \texttt{\_\_pow\_\_(self, other)} & called when we evaluate \texttt{self ** other} \\
        \hline
        \texttt{\_\_and\_\_(self, other)} & called when we evaluate \texttt{self \& other} \\
        \hline
        \texttt{\_\_or\_\_(self, other)} & called when we evaluate \texttt{self | other} \\
        \hline
        \texttt{\_\_xor\_\_(self, other)} & called when we evaluate \texttt{self \^{} other} \\
        \hline
        \texttt{\_\_lshift\_\_(self, other)} & called when we evaluate \texttt{self << other} \\
        \hline
        \texttt{\_\_rshift\_\_(self, other)} & called when we evaluate \texttt{self >> other} \\
        \hline
        \texttt{\_\_neg\_\_(self)} & called when we evaluate \texttt{-self} \\
        \hline
        \texttt{\_\_pos\_\_(self)} & called when we evaluate \texttt{+self} \\
        \hline
        \texttt{\_\_abs\_\_(self)} & called when we evaluate \texttt{abs(self)} \\
        \hline
        \texttt{\_\_invert\_\_(self)} & called when we evaluate \texttt{\~{}self} \\
        \hline
        \texttt{\_\_round\_\_(self, ndigits)} & called when we evaluate \texttt{round(self)} \\
        \hline
        \texttt{\_\_floor\_\_(self)} & called when we evaluate \texttt{math.floor(self)} \\
        \hline
        \texttt{\_\_ceil\_\_(self)} & called when we evaluate \texttt{math.ceil(self)} \\
        \hline
        \texttt{\_\_trunc\_\_(self)} & called when we evaluate \texttt{math.trunc(self)} \\
        \hline
      \end{tabular}
      \caption{Methods for mathematical operations on objects.}
      \label{tab:mathematical_operations}
    \end{table}

    Note that in the abstract algebraic sense, \texttt{a + b} is really just a binary operation and may not be commutative. There are also \textit{reverse versions} of the binary operations, e.g. \texttt{\_\_radd\_\_}, that are called when the left operand doesn't support the operation. There are also \textit{in-place versions} like \texttt{\_\_iadd\_\_()} for operations like \texttt{+=}.  
  \end{definition}

\subsection{Encapsulation} 

  
 
\subsection{Inheritance and Method Resolution Order} 

  Conceptually, we might think of certain types a subset of another type. Therefore, it makes sense to design some \textit{hierarchy} of these types where children can extend the functionality of their parents. This is the conceptual idea of inheritance, which is a convenient way of designing code. In fact, if we had infinite coding power where we don't care about maintainability or the DRY (don't repeat yourself) principle, then you wouldn't need inheritance. 

  \begin{definition}[Class Inheritance]
    A \textbf{child class} can inherit the attributes and methods of the parent class, and in general should \textit{extend} the functionality of the base class. Here is the minimal example. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P: 
            ... 
          class B(A): 
            ...
        \end{lstlisting}
        \caption{Inheritance with 1 parent class and 1 child class.}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P1: ... 
          class P2: ...
          class P3: ... 
          class C(P1, P2, P3): ...
        \end{lstlisting}
        \caption{Multiple inheritance with 3 parent and 1 child class.}
      \end{subfigure}
      \caption{}
    \end{figure}
  \end{definition}


  A more directly practical advantage of coding is that we can take advantage of the \textit{method resolution order (MRO)}. Let's introduce what this is slowly with a sequence of examples. 

  \begin{example}[Methods of Parent are Accessible from Child]
    Consider the two classes. 
    \begin{lstlisting}
      class Animal: 
        def __init__(self, name): 
          self.name = name 

        def speak(self): 
          print("Rah") # generic animal sound

      class Dog(Animal): 
        ...
    \end{lstlisting} 
    The only way \texttt{Dog} is connected to \texttt{Animal} is that it is declared as a subclass of \texttt{Animal}. It may not look like \texttt{Dog} even has a constructor method, but in fact we can access both the \texttt{\_\_init\_\_} and \texttt{speak} methods! 
    \begin{lstlisting} 
      >>> x = Dog("wolfy") 
      >>> x.speak() 
      "Rah"
    \end{lstlisting}
  \end{example} 

  So we have found out that subclasses can access parent class methods by default. But what if we have \textit{multiple} parent classes?  

  \begin{example}[Method Resolution with Multiple Parent Classes]
    Say that we have the same \texttt{Animal} class as defined above, but with the following hierarchy. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Animal: 
            def __init__(self, name):
              print("Animal constructor called.")
              self.name = name
            
            def speak(self):
              return f"{self.name} makes a sound"  

          class Flyer(Animal):  
            def __init__(self, name): 
              print("Flyer constructor called") 

          class Swimmer(Animal): 
            def __init__(self, name): 
              print("Swimmer constructor called") 
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Duck1(Flyer, Swimmer): 
            ... 

          class Duck2(Swimmer, Flyer): 
            ...

          class Duck3(Flyer, Swimmer): 
            def __init__(self, name): 
              print("Duck constructor called")
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \caption{}
    \end{figure}

    Interesting, so it seems like if the child class supports its own constructor, then it will call its own constructor, and if not, then it will look at the constructors of the parent classes, \textit{in the order in which they were specified} when defining the child class. 
      
    \begin{lstlisting}
      >>> Duck1("duck1")
      Flyer constructor called
      >>> Duck2("duck2")
      Swimmer constructor called
      >>> Duck3("duck3")
      Duck constructor called
    \end{lstlisting} 
  \end{example} 

  So when a subclass is instantiated, the child class somehow knows where to look first for an implementation of a method to call, then next, then next, etc. This ordering is extremely useful, though can be a double-edged sword.   

  \begin{definition}[Method Resolution Order]
    The \textbf{method resolution order (MRO)} of a given class \texttt{C} is a sequence of classes that Python looks through to find an implementation of any method. 
    \begin{enumerate}
      \item It is a tuple that can be retrieved with \texttt{C.\_\_mro\_\_} (this is a class method). 
      \item The actual way that the MRO is computed is with the \href{https://docs.python.org/3/howto/mro.html}{C3 Algorithm}, starting from Python 2.3.
    \end{enumerate}
  \end{definition}

  \begin{example}[MROs of Ducks]
    The MROs of the Duck classes confirms our suspicion. Generally, we go from the most specific class to the broadest class, which is always \texttt{object} in Python. 

    \begin{lstlisting}
      >>> print(Duck1.__mro__)
      (<class '__main__.Duck1'>, <class '__main__.Flyer'>, <class '__main__.Swimmer'>, <class '__main__.Animal'>, <class 'object'>)

      >>> print(Duck2.__mro__)
      (<class '__main__.Duck2'>, <class '__main__.Swimmer'>, <class '__main__.Flyer'>, <class '__main__.Animal'>, <class 'object'>)

      >>> print(Duck3.__mro__)
      (<class '__main__.Duck3'>, <class '__main__.Flyer'>, <class '__main__.Swimmer'>, <class '__main__.Animal'>, <class 'object'>)
    \end{lstlisting}
  \end{example} 

  In most cases, when you are trying to call a method from a parent class, you are most likely trying to find the next class in the MRO that implements this method, which may not be the direct parent.\footnote{\href{https://stackoverflow.com/questions/222877/what-does-super-do-in-python-difference-between-super-init-and-expl}{https://stackoverflow.com/questions/222877/what-does-super-do-in-python-difference-between-super-init-and-expl}}. So rather than explicitly hard-coding something like this 

  \begin{lstlisting}
    class P: 
      def method(self): 
        ...

    class C(P): 
      def method(self): 
        P.method(self) 
        ...
  \end{lstlisting} 

  You might have heard that you should use something called \texttt{super()}. 

  \begin{definition}[Superclass] 
    The \textbf{superclass \texttt{S} with respect to a method \texttt{m}} of a class \texttt{C} is the next class in the MRO that actually implements the method \texttt{m}. This can be gotten by calling \texttt{super()}.\footnote{Note that unlike other sources, I distinguish the superclass and the parent class. The superclass is with respect to a method, and the parent class does not need to specify a method.}
  \end{definition} 

  The MRO is useful when calling methods not explicitly defined in our child class (but defined in some parent class), but ultimately, the whole point of having child classes is so that we can \textit{extend} our parent classes. For example, the first thing we must always do with an object is to instantiate it---through the constructor. There are three general ways that we can implement the constructor of child class \texttt{C} with parent class \texttt{P}. 

  \begin{enumerate}
    \item Do not define the constructor on \texttt{C}. Then, the MRO will just call the constructor of the parent class. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P: 
            def __init__(self, name): 
              self.name = name
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class C(P): 
            ...
            .
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \caption{}
    \end{figure}

    \item Define the constructor on \texttt{C}, but do not call the parent's constructor. This allows you to completely override the parent constructor, but this is a bad idea for two reasons. First, if you are really just re-implementing the same thing that the parent constructor has done, then you are better off doing (3). If you truly need to override the \textit{whole} parent constructor, then perhaps you are not truly extending the parent class, and class inheritance is not the right approach. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P: 
            def __init__(self, name): 
              self.name = name
          .
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class C(P): 
            def __init__(self, name, breed): 
              self.name = name 
              self.breed = breed
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \caption{}
    \end{figure}

    \item Define the constructor on \texttt{C}. In the child constructor, call the parent's constructor to set up all of the parent's attributes, and then add your own or do some postprocessing after. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P: 
            def __init__(self, name): 
              self.name = name
          .
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class C(P): 
            def __init__(self, name, breed): 
              super().__init__(name)
              self.breed = breed
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \caption{}
    \end{figure}
  \end{enumerate}

  It's clear what the best choice is. Since we generally want to retain the class attributes (hence call parent constructor) and extend them (hence explicitly define the child constructor), we should by default opt for the third choice. 

  \begin{theorem}[Heuristic]
    In the beginning of your child constructor, you should almost always call \texttt{super().\_\_init\_\_(*args)}. 
  \end{theorem} 

  You might also notice that not implementing a constructor method at all is equivalent to just implementing a constructor method with only \texttt{super().\_\_init\_\_()}.\footnote{\href{https://stackoverflow.com/questions/61174178/why-is-python-super-used-in-the-childs-init-method}{https://stackoverflow.com/questions/61174178/why-is-python-super-used-in-the-childs-init-method}}. However, this is still bad for maintainability, and can be especially dangerous if there are keyword arguments that are passed on. 

  For the constructor, we've seen that we must always define \texttt{\_\_init\_\_()} and have it call the super's constructor. This generally comes from the fact that the attributes of a child class should be a strict superset of those of parent classes. For methods, we may either want a method \texttt{m()} of a child class to call super's method as well, along with doing additional things, or we might want to completely override it. Consider the animal class again. 
  \begin{lstlisting}
    class Animal: 
      def __init__(self, name):
        self.name = name
      
      def speak(self):
        return f"Rahhh" # generic animal sound
  \end{lstlisting} 

  Overriding and extending methods is straightforward. 

  \begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
      \centering
      \begin{lstlisting}
        class Dog(Animal): 
          def speak(self): 
            return "woof"
        .
      \end{lstlisting}
      \caption{To override, just redefine it, and the MRO will view this implementation first.}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.48\textwidth}
      \centering
      \begin{lstlisting}
        class Dog(Animal): 
          def speak(self): 
            return super().speak() + " said the dog."
      \end{lstlisting}
      \caption{To extend it, have it call the super's method first, and then do whatever you want after. }
    \end{subfigure}
    \caption{}
  \end{figure}

  Deleting any parent attribute or method is not a good idea and goes against the whole purpose of inheritance. If it must be done, here are the best methods I know. 

  \begin{theorem}[Deleting Attribute Belonging to Parent in Child]
    You can delete an attribute from the child class by calling \texttt{delattr(ChildClass, "attribute")}. 
    \begin{lstlisting}
      class P: 
        def __init__(self, name): 
          self.name = name  

      class C(P): 
        def __init__(self, name): 
          super().__init__(self, name) 
          delattr(C, "name") 
    \end{lstlisting}
  \end{theorem}

  \begin{theorem}[Deleting Method Belong to Parent in Child]
    You cannot delete a method that exists in the parent class from the child class, since the MRO will just be invoked. The best you can do is override it to throw an exception. 
  \end{theorem}

  \begin{example}[Modifying Attributes in Child Class]
    We begin with an \texttt{Animal} class.

    \begin{figure}[H]
      \centering 
      \begin{lstlisting}
        class Animal: 
            def __init__(self, name):
                self.name = name
            
            def speak(self):
                return f"Rahhh" # generic animal sound
      \end{lstlisting} 
      \caption{} 
    \end{figure}

    There is a \texttt{Dog} class that we would like to inherit from \texttt{Animal}. Let's go through a few ways we can design the attributes of the child class. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, name): 
              super().__init__(name) 
          .
        \end{lstlisting}
        \caption{Nothing is added. Since called the parent constructor, we still have access to the \texttt{name} attribute and \texttt{speak} method. }
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, name, breed): 
              super().__init__(name)
              self.breed = breed
        \end{lstlisting}
        \caption{We just want to add a new attribute called \texttt{breed}. Since called the parent constructor, we still have access to the \texttt{name} attribute and \texttt{speak} method. }
      \end{subfigure}

      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, id): 
              self.id = id
        \end{lstlisting}
        \caption{You don't even call the parent constructor, so you lose access to \texttt{name}. However, you still have access to the \texttt{speak()} method. This is not recommended.}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, name, breed): 
              super().__init__(name)  
              print(self.name)
              self.name = f"{name}_{breed}"
        \end{lstlisting}
        \caption{Say you want to override the name so that the breed is also included in it.}
      \end{subfigure}
      \caption{}
    \end{figure}
  \end{example}

\subsection{Interfaces and Abstract Base Classes} 

  Note that inheritance does two things. First, it allows us to reuse code since a child class inherits attributes/methods from a superclass. Second, we can extend or override parent functionality, which allows us to use different implementations of the same method. The fancy sounding term ``polymorphism'' is just a colloqial buzzword that refers to being able to treat objects of different types in the same way, mostly through calling a method with the same name. 

  \begin{definition}[Polymorphism]
    \textbf{Polymorphism} is the ability of objects of different types to be treated as instances of the same type through a common interface. It comes in many forms, including 
    \begin{enumerate}
      \item \textit{Subtype/Inclusion Polymorphism}. Basically what we did with inheritance. 
      \item \textit{Parameteric Polymorphism}. Allows function or data type to be written generically, so that it can handle values \textit{uniformly} without depending on their type. 
      \item \textit{Overriding}. 
      \item \textit{Overloading}. Taking the 
    \end{enumerate}
  \end{definition}

  With inheritance, we can create hierarchies of classes where child classes extend or override parent functionality. However, we are still short 

  At this point, we have defined the class hierarchy by taking the class names (more specifically, the \textit{fully qualified class name (FQCN)}) and explicitly defining a parent-child relationship (e.g. \texttt{Dog(Animal)}). As stated in \href{https://peps.python.org/pep-3119/}{PEP-3119}, in the domain of OOP, the uage patterns of interacting with an object can be divided into two basic categories. 
  \begin{enumerate}
    \item \textit{Invocation}. Interacting with an object by invoking its methods. 
    \item \textit{Inspection}. The ability for external code (outside of the object's methods) to examine the type or properties of that object, and make decisions on how to treat that object based on that information. 
  \end{enumerate}
  Both usage patterns 

\subsection{Interfaces and Abstract Base Classes} 

  Apparently need to know for PEP 3119. 

  But classes are limited? So we want to use interfaces (duck typing). 

    % - Implemented as ABCs in python. 
    % - A new module abc which serves as an “ABC support framework”. It defines a metaclass for use with ABCs and a decorator that can be used to define abstract methods. 
    % - PEP 3141 gives a hierarchy of the numbers.  
    % - ABCs have two points, one obtained by subclassing ("invasive"), one by registering (non-invasive). (https://stackoverflow.com/questions/3392352/python-abcs-registering-vs-subclassing) 
    % 

  PEP 3141 gives a hierarchy of the numbers. 

  \begin{definition}[Numeric ABCs] 
    The \texttt{numbers} module contains them. 
    \begin{enumerate}
      \item \texttt{numbers.Number} 
      \item \texttt{numbers.Complex} 
      \item \texttt{numbers.Real} 
      \item \texttt{numbers.Rational} 
      \item \texttt{numbers.Integral} 
    \end{enumerate}
  \end{definition}

\subsection{Type Hints}

  Type Hints - PEP 484 (3.5) 

\subsection{Protocols}

  Protocols - PEP 544 (3.7) 

\subsection{Type Checking}

  \begin{question}[To Do]
    Move some of these to general language notes. 
  \end{question}

  \begin{definition}[Type Checking]
    \textbf{Type checking} is the process of verifying that the types of values in a program are used consistently and correctly according to the language's type system rules. These include: 
    \begin{enumerate}
      \item Operations are valid for their operand types 
      \item Function/method calls match their signatures 
      \item Assignments are type-compatible (though this isn't necessary in Python) 
    \end{enumerate}
  \end{definition}

  The implementation of type checking differs for every language, and they generally fall into 3 different philosophies. 

  \begin{definition}[Nominal Typing]
    \textbf{Nominal typing} is a static typing system that determines that two types are equal/compatible if their fully qualified class names (FQCN) are equal. 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=C++]{Code}
          struct Cat {
              std::string name;
              int age;
          };

          void printCat(const Cat& c) {
              std::cout << "Cat: " << c.name << ", age " << c.age << "\n";
          }        
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[language=C++]{Output}
          struct Dog {
              std::string name;
              int age;
          };

          void printDog(const Dog& d) {
              std::cout << "Dog: " << d.name << ", age " << d.age << "\n";
          }
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}[language=C++]
        int main() {
            Cat kitty{"Whiskers", 3};
            Dog pup{"Buddy", 5};

            printCat(kitty); // works
            printDog(pup);   // works

            // printCat(pup); // error: cannot convert Dog to Cat (nominal typing)

            return 0;
        } 
      \end{lstlisting}
      \caption{C++ uses aspects of nominal typing.} 
      \label{fig:cpp_nominal}
    \end{figure}
  \end{definition}

  \begin{definition}[Structural Typing]
    \textbf{Structural typing} is a static typing system that determines that two types are equal/compatible if their structures (e.g. the attributes and methods it supports) are equal. The class name is immaterial. 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=php]{Code}
          type Cat = {
            name: string;
            age: number;
          };

          function printCat(c: Cat) {
            console.log(`Cat: ${c.name}, age ${c.age}`);
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          type Dog = {
            name: string;
            age: number;
          };

          function printDog(d: Dog) {
            console.log(`Dog: ${d.name}, age ${d.age}`);
          }
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}
        const kitty: Cat = { name: "Whiskers", age: 3 };
        const pup: Dog = { name: "Buddy", age: 5 };

        printCat(kitty); // works
        printDog(pup);   // works
        printCat(pup);   // also works (structural typing!)
      \end{lstlisting}
      \caption{Typescript uses aspects of structural typing.} 
      \label{fig:typescript_structural}
    \end{figure}
  \end{definition}

  \begin{definition}[Duck Typing]
    \textbf{Duck typing} is a dynamic typing system that determines that two types are equal/compatible is the \textit{accessed} structure (e.g. used attributes or called methods) are equal. The class name and the unused properties are immaterial.\footnote{If it walks like a duck and quacks like a duck, then it must be a duck.} 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=python]{Code}
          class Cat:
              def __init__(self, name, age):
                  self.name = name
                  self.age = age 

              def meow(self): 
                  print("meow")

          def print_cat(c):
              print(f"Cat: {c.name}, age {c.age}")
        \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          class Dog:
              def __init__(self, name, age):
                  self.name = name
                  self.age = age

              def bark(self): 
                  print("woof")

          def print_dog(d):
              print(f"Dog: {d.name}, age {d.age}")
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}
        kitty = Cat("Whiskers", 3)
        pup   = Dog("Buddy", 5)

        print_cat(kitty) # works
        print_dog(pup)   # works
        print_cat(pup)   # also works though structures are different
        pup.bark(), kitty.meow()       # works  
        pup.meow() # Error: 'Dog' object has no attribute 'meow'
      \end{lstlisting}
      \caption{Python uses duck typing: any object with the right attributes can be passed.} 
      \label{fig:python_duck}
    \end{figure}
  \end{definition} 

  Duck typing and structural typing are similar (and often confused) but distinct, and the preference for one over the other is controversial. The big difference is that duck typing is ``looser'' in that type checking happens at \textit{runtime}, whether an object has the required methods/properties when they are actually used. 

  We will start by going through all the types in Python. 

\subsection{Metaclasses} 

  Note that for every class, there are specific properties (in the colloquial sense) that it satisfies, e.g. it has an MRO accessible through \texttt{\_\_mro\_\_}, etc. If we wanted to change this behavior, for example 
  \begin{enumerate}
    \item add attributes or methods automatically, 
    \item enforce certain rules 
  \end{enumerate}
  then we would want to work with something that controls \textit{classes}, in the same way that classes control objects. This is where \textit{metaclasses} come in. 


\subsection{Factories}


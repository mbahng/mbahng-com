\section{Design Patterns} 

  At some point, you would have mastered the syntax and your main bottleneck will be how well you can design your repository. Chances are, you would either have specific needs or would see the same problems over and over again. The following \textit{design patterns} are general ways that you can structure your code to meet these needs or avoid these problems. 

  \begin{definition}[UML Diagram]
    A \textbf{UML (Unified Modeling Language) diagram} is a directed graph of nodes. 
    \begin{enumerate}
      \item Each node is a class $C$, labeled in a box, with attributes and methods. 
      \item A node can \textit{extend} a class, i.e. is a child class. 
      \item A node can \textit{implement} a class, i.e. is an implementation of an interface. 
    \end{enumerate}
  \end{definition} 

  In the Gang of 4's \textit{Design Patterns}, they go over 23 design patterns. I'll list them briefly here for a quick reference, but each subsection will go through in detail the following: 
  \begin{enumerate}
    \item The motivation behind this pattern. Mainly, when to use it, and what natural problems motivate this pattern.  
    \item The solution, which describes the elements that make up this design, their relationships, responsibilities, and collaborations. 
    \item The consequences, which are the results and trade-offs of applying the pattern. 
    \item A real-life example of when I had to use this pattern, with code and a UML diagram. 
  \end{enumerate}

\subsection{Creational Patterns} 

  How objects are instantiated. 

  \subsubsection{Singleton} 

    A class is a blueprint, so it should be the case that we would instantiate multiple objects from this class, right? Not always. There are times when we want just \textit{one} instance $o$ of a class $C$ to exist, and it is usually in the case when a bunch of other objects $o_1, \ldots, o_n$ need to interact with $o$ uniformly. 

    \begin{definition}[Singleton]
      In a \textbf{singleton pattern}, we want only one instance of a specific class to exist. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Logger]
      Say that you want to implement a simple logger. You want there to be only one logger object that writes to a central location. 

      \begin{lstlisting}
        class Logger:
          _instance = None
          
          def __new__(cls):
            if cls._instance is None:
              cls._instance = super().__new__(cls)
              cls._instance.logs = []  # Initialize logs only once
            return cls._instance
          
          def log(self, message):
            self.logs.append(message)
            print(f"[LOG] {message}")
          
          def show_all_logs(self):
            print("\n=== All Logs ===")
            for i, log in enumerate(self.logs, 1):
              print(f"{i}. {log}")
      \end{lstlisting}

      \noindent\begin{minipage}{.65\textwidth}
        \begin{lstlisting}[]{Code}
          # Usage example
          def main():
            # First logger instance
            logger1 = Logger()
            logger1.log("Application started")
            logger1.log("User logged in")
            
            # Second logger instance (same as first!)
            logger2 = Logger()
            logger2.log("Processing data")
            
            # Third instance from different part of code
            logger3 = Logger()
            logger3.log("Task completed")
            
            # All loggers are the same instance
            print(f"\nlogger1 is logger2: {logger1 is logger2}")
            print(f"logger2 is logger3: {logger2 is logger3}")
            
            # All share the same log history
            logger1.show_all_logs()

          if __name__ == "__main__":
            main() 
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.34\textwidth}
        \begin{lstlisting}[]{Output}
          [LOG] Application started
          [LOG] User logged in
          [LOG] Processing data
          [LOG] Task completed

          logger1 is logger2: True
          logger2 is logger3: True

          === All Logs ===
          1. Application started
          2. User logged in
          3. Processing data
          4. Task completed
          .
          .
          .
          .
          .
          .
          .
          .
          .
          .
          .
        \end{lstlisting}
      \end{minipage}
    \end{example}

  \subsubsection{Factory} 

    When a method returns one of several possible classes that share a common super class. You would want some kind of ``factory'' that can seamlessly generate new objects for you. We want to emphasize that this behavior is generally wanted at runtime. You should use it 
    \begin{enumerate}
      \item when you don't know ahead of time what class object you need. 
      \item when all of the potential classes are in the same subclass hierarchy. 
      \item to centralize class selection code. 
      \item when you don't want to use to have to know every subclass. 
      \item to encapsulate object creation. 
    \end{enumerate}

    \begin{definition}[Factory Pattern]
      In a \textbf{factory pattern}, you can create objects without specifying their exact class. It is characterized by the following. 
      \begin{enumerate}
        \item It is especially useful for creating objects at runtime. 
        \item It specifically avoids using a constructor and rather uses a factory method for object construction. 
        \item Factory methods can be specified in an interface and implemented by subclasses or implemented in a base class and optionally overridden by subclasses.
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Animal Factory]
      \begin{lstlisting}
        class Dog:
            def speak(self):
                return "Woof!"

        class Cat:
            def speak(self):
                return "Meow!"

        class AnimalFactory:
            @staticmethod
            def create_animal(animal_type):
                if animal_type == "dog":
                    return Dog()
                elif animal_type == "cat":
                    return Cat()

        # Usage
        animal = AnimalFactory.create_animal("dog")
        print(animal.speak())  # Woof! 
      \end{lstlisting}
    \end{example}

    \begin{example}[Case Study]
      \texttt{torch.randn()} is a factory method that generates torch tensors sampled element-wise from a standard Gaussian! 
    \end{example}

  \subsubsection{Builder} 

    Motivation. 

    \begin{definition}[Builder Pattern]
      In a \textbf{builder pattern}, we construct complex objects step by step. It is characterized by the following. 
      \begin{enumerate}
        \item It is used to create objects made from a bunch of other objects. 
        \item The creation of the parts are hidden from the client. 
        \item Unlike factory---where we just instantiate generic instances of a class---the builder gives us precise control of instantiation. 
        % \item The creation of these parts are independent of the main object. 
        % \item To builder knows the specifics and nobody else does. 
      \end{enumerate}
    \end{definition}

    Results. However, it has gotten a bit out of style recently. 

    \begin{example}[Pizza]
      \begin{lstlisting}
        class Pizza:
          def __init__(self):
            self.size = None
            self.cheese = False
            self.pepperoni = False
          
          def __str__(self):
            return f"{self.size} pizza, cheese: {self.cheese}, pepperoni: {self.pepperoni}"

        class PizzaBuilder:
          def __init__(self):
            self.pizza = Pizza()
          
          def set_size(self, size):
            self.pizza.size = size
            return self
          
          def add_cheese(self):
            self.pizza.cheese = True
            return self
          
          def add_pepperoni(self):
            self.pizza.pepperoni = True
            return self
          
          def build(self):
            return self.pizza

        # Usage
        pizza = PizzaBuilder().set_size("large").add_cheese().add_pepperoni().build()
        print(pizza)  # large pizza, cheese: True, pepperoni: True 
      \end{lstlisting}
    \end{example}

  \subsubsection{Prototype} 

    Motivation. 

    \begin{definition}[Prototype Pattern]
      In a \textbf{prototype pattern}, we create new objects by copying existing ones. It is characterized by the following. 
    \end{definition}

    Results. 

    \begin{example}[Document]
      \begin{lstlisting}
        import copy

        class Document:
            def __init__(self, title, content):
                self.title = title
                self.content = content
            
            def clone(self):
                return copy.deepcopy(self)
            
            def __str__(self):
                return f"Title: {self.title}, Content: {self.content}"

        # Usage
        original = Document("Report", "Q1 Sales Data")
        clone = original.clone()
        clone.title = "Report Copy"
        print(original)  # Title: Report, Content: Q1 Sales Data
        print(clone)     # Title: Report Copy, Content: Q1 Sales Data 
      \end{lstlisting}
    \end{example}

  \subsubsection{Abstract Factory}

    Motivation. 

    \begin{definition}[Abstract Factory Pattern]
      In an \textbf{abstract factory pattern}, it creates families of related objects without specifying their concrete class. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        from abc import ABC, abstractmethod

        # Abstract Products
        class Button(ABC):
            @abstractmethod
            def render(self):
                pass

        class Checkbox(ABC):
            @abstractmethod
            def render(self):
                pass

        # Concrete Products - Windows
        class WindowsButton(Button):
            def render(self):
                return "Rendering Windows button"

        class WindowsCheckbox(Checkbox):
            def render(self):
                return "Rendering Windows checkbox"

        # Concrete Products - Mac
        class MacButton(Button):
            def render(self):
                return "Rendering Mac button"

        class MacCheckbox(Checkbox):
            def render(self):
                return "Rendering Mac checkbox"

        # Abstract Factory
        class GUIFactory(ABC):
            @abstractmethod
            def create_button(self):
                pass
            
            @abstractmethod
            def create_checkbox(self):
                pass

        # Concrete Factories
        class WindowsFactory(GUIFactory):
            def create_button(self):
                return WindowsButton()
            
            def create_checkbox(self):
                return WindowsCheckbox()

        class MacFactory(GUIFactory):
            def create_button(self):
                return MacButton()
            
            def create_checkbox(self):
                return MacCheckbox()

        # Usage
        def create_ui(factory):
            button = factory.create_button()
            checkbox = factory.create_checkbox()
            print(button.render())
            print(checkbox.render())

        # Create Windows UI
        print("Windows UI:")
        create_ui(WindowsFactory())

        # Create Mac UI
        print("\nMac UI:")
        create_ui(MacFactory()) 
      \end{lstlisting}
    \end{example}

\subsection{Structural Patterns}

  How objects relate to each other. 

  \subsubsection{Adapter}

    Motivation. 

    \begin{definition}[Adapter Pattern]
      An \textbf{adapter pattern} converts one interface to another that clients expect. 
      \begin{enumerate}
        \item It allows classes to work together that on their own could not due to incompatible interfaces. It converts the interface of one class into something that may be used by another class. 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Sockets]
      \begin{lstlisting}
        class EuropeanSocket:
            def plug_in_eu(self):
                return "Providing 230V (EU)"

        class USASocket:
            def plug_in_usa(self):
                return "Providing 110V (USA)"

        class SocketAdapter:
            def __init__(self, socket):
                self.socket = socket
            
            def plug_in(self):
                if hasattr(self.socket, 'plug_in_eu'):
                    return self.socket.plug_in_eu()
                elif hasattr(self.socket, 'plug_in_usa'):
                    return self.socket.plug_in_usa()

        # Usage
        eu_socket = EuropeanSocket()
        usa_socket = USASocket()

        adapter1 = SocketAdapter(eu_socket)
        adapter2 = SocketAdapter(usa_socket)

        print(adapter1.plug_in())  # Providing 230V (EU)
        print(adapter2.plug_in())  # Providing 110V (USA) 
      \end{lstlisting}
    \end{example}

  \subsubsection{Bridge}

    Motivation. 

    \begin{definition}[Bridge Pattern]
      In a \textbf{bridge pattern}, it separates abstraction from implementation so they can vary independently. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        # Implementation
        class Color:
            def fill(self):
                pass

        class Red(Color):
            def fill(self):
                return "red"

        class Blue(Color):
            def fill(self):
                return "blue"

        # Abstraction
        class Shape:
            def __init__(self, color):
                self.color = color
            
            def draw(self):
                pass

        class Circle(Shape):
            def draw(self):
                return f"Drawing circle in {self.color.fill()}"

        class Square(Shape):
            def draw(self):
                return f"Drawing square in {self.color.fill()}"

        # Usage
        red = Red()
        blue = Blue()

        red_circle = Circle(red)
        blue_square = Square(blue)

        print(red_circle.draw())   # Drawing circle in red
        print(blue_square.draw())  # Drawing square in blue
      \end{lstlisting}
    \end{example}

  \subsubsection{Composite}

    Motivation. 

    \begin{definition}[Composite Pattern]
      In a \textbf{composite pattern}, we treat individual objects and compositions uniformly in a tree structure. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class Component:
            def show(self, indent=0):
                pass

        class File(Component):
            def __init__(self, name):
                self.name = name
            
            def show(self, indent=0):
                print("  " * indent + f"- {self.name}")

        class Folder(Component):
            def __init__(self, name):
                self.name = name
                self.children = []
            
            def add(self, component):
                self.children.append(component)
            
            def show(self, indent=0):
                print("  " * indent + f"+ {self.name}/")
                for child in self.children:
                    child.show(indent + 1)

        # Usage
        root = Folder("root")
        docs = Folder("documents")
        pics = Folder("pictures")

        docs.add(File("resume.pdf"))
        docs.add(File("report.docx"))
        pics.add(File("photo1.jpg"))

        root.add(docs)
        root.add(pics)
        root.add(File("readme.txt"))

        root.show() 
      \end{lstlisting}
    \end{example}

  \subsubsection{Decorator}

    Motivation. 

    \begin{definition}[Decorator]
      In a \textbf{decorator pattern}, we add functionality to objects dynamically. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Coffee]
      \begin{lstlisting}
        class Coffee:
            def cost(self):
                return 5

        class MilkDecorator:
            def __init__(self, coffee):
                self.coffee = coffee
            
            def cost(self):
                return self.coffee.cost() + 2

        class SugarDecorator:
            def __init__(self, coffee):
                self.coffee = coffee
            
            def cost(self):
                return self.coffee.cost() + 1

        # Usage
        coffee = Coffee()
        coffee_with_milk = MilkDecorator(coffee)
        coffee_with_milk_and_sugar = SugarDecorator(coffee_with_milk)
        print(coffee_with_milk_and_sugar.cost())  # 8 
      \end{lstlisting}
    \end{example}

  \subsubsection{Facade}

    Motivation. 

    \begin{definition}[Facade Pattern]
      In a \textbf{facade pattern}, it provides a simplified interface to a complex subsystem. It is characterized by the following. 
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class CPU:
            def freeze(self):
                print("CPU: Freezing...")
            
            def execute(self):
                print("CPU: Executing...")

        class Memory:
            def load(self):
                print("Memory: Loading data...")

        class HardDrive:
            def read(self):
                print("HardDrive: Reading...")

        class ComputerFacade:
            def __init__(self):
                self.cpu = CPU()
                self.memory = Memory()
                self.hard_drive = HardDrive()
            
            def start(self):
                print("Starting computer...")
                self.cpu.freeze()
                self.memory.load()
                self.hard_drive.read()
                self.cpu.execute()
                print("Computer started!")

        # Usage
        computer = ComputerFacade()
        computer.start()
        # Simple interface hides complex subsystem interactions 
      \end{lstlisting}
    \end{example}

  \subsubsection{Flyweight}

    Motivation. 

    \begin{definition}[Flyweight Pattern]
      In a \textbf{flyweight pattern}, we share some common state among multiple objects to save memory. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class TreeType:
            def __init__(self, name, color, texture):
                self.name = name
                self.color = color
                self.texture = texture
            
            def draw(self, x, y):
                print(f"Drawing {self.name} tree at ({x}, {y}) - {self.color}, {self.texture}")

        class TreeFactory:
            _tree_types = {}
            
            @classmethod
            def get_tree_type(cls, name, color, texture):
                key = (name, color, texture)
                if key not in cls._tree_types:
                    cls._tree_types[key] = TreeType(name, color, texture)
                    print(f"Creating new tree type: {name}")
                return cls._tree_types[key]

        class Tree:
            def __init__(self, x, y, tree_type):
                self.x = x
                self.y = y
                self.tree_type = tree_type
            
            def draw(self):
                self.tree_type.draw(self.x, self.y)

        # Usage
        factory = TreeFactory()
        trees = []

        # Reuses the same TreeType object for oak trees
        trees.append(Tree(1, 2, factory.get_tree_type("Oak", "green", "rough")))
        trees.append(Tree(3, 4, factory.get_tree_type("Oak", "green", "rough")))
        trees.append(Tree(5, 6, factory.get_tree_type("Pine", "dark green", "smooth")))

        for tree in trees:
            tree.draw() 
      \end{lstlisting}
    \end{example}

  \subsubsection{Proxy}

    Motivation. 

    \begin{definition}[Proxy Pattern]
      In a \textbf{proxy pattern}, we provide a placeholder or surrogate for another object to control access. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class RealImage:
            def __init__(self, filename):
                self.filename = filename
                self.load_from_disk()
            
            def load_from_disk(self):
                print(f"Loading image: {self.filename}")
            
            def display(self):
                print(f"Displaying image: {self.filename}")

        class ProxyImage:
            def __init__(self, filename):
                self.filename = filename
                self.real_image = None
            
            def display(self):
                if self.real_image is None:
                    self.real_image = RealImage(self.filename)
                self.real_image.display()

        # Usage
        image1 = ProxyImage("photo1.jpg")
        image2 = ProxyImage("photo2.jpg")

        image1.display()  # Loads and displays
        image1.display()  # Just displays (already loaded)
        image2.display()  # Loads and displays 
      \end{lstlisting}
    \end{example}

\subsection{Behavioral Patterns} 

  How objects communicate with each other. 

  \subsubsection{Strategy} 

    If you are coding some object that should have the following characteristics 
    \begin{align}
      a & \in \{a_1, a_2, a_3\} = A \\
      b & \in \{b_1, b_2\} = B \\
      c & \in \{c_1, c_2, c_3, c_4\} = C
    \end{align}
    and which characteristics it has determines the implementation of the method, then you should use the strategy pattern.

    \begin{definition}[Strategy Pattern] 
      In a \textbf{strategy pattern}, you can use a family of interchangeable algorithms. It is characterized by the following. 
      \begin{enumerate}
        \item It defines a family of algorithms (different implementations of a set of method), encapsulates each one, and makes them interchangeable. 
        \item This enables selecting an algorithm at runtime and let's them vary independently from clients that use it.\footnote{This is basically object composition. }
      \end{enumerate}
    \end{definition} 

    This pattern is good as it 
    \begin{enumerate}
      \item often reduces long lists of conditionals, 
      \item avoids duplicate code, 
      \item keeps class changes from forcing other class changes, and 
      \item can hide complicated/secret code from the user
    \end{enumerate}

    However, there may be an increased number of objects/classes. 

    \begin{example}[Overwatch]
      Say that you are redesigning Overwatch. We can characterize each hero in the following ways: 
      \begin{enumerate}
        \item \textit{Composition}: poking, brawling, diving.\footnote{https://www.youtube.com/watch?v=93nrrdo-w0M} If they are a poker, then they will deal a little damage. If they are a brawler, they will deal medium damage. If they are a diver, they will deal high damage. 
        \item \textit{Ability to Fly}: Can fly or cannot fly. If they can fly, their $z$-coordinate will increase by 10 units. If they cannot fly, then nothing will happen. 
        \item \textit{Role}: Tank, DPS, Support. Tanks will have the ability to raise a shield for defense. DPS have the ability to dodge attacks. Supports have the ability to heal themselves. 
      \end{enumerate}
      We start off with a class Hero and then want three attributes: 

      \begin{lstlisting}
        from abc import ABC, abstractmethod

        class Composition(ABC): 
          @abstractmethod
          def attack(self, other: "Hero"): pass 

        class Poker(Composition): 
          def attack(self, other): print(f"5 damage dealt to {other}")

        class Brawler(Composition): 
          def attack(self, other): print(f"10 damage dealt to {other}")

        class Diver(Composition): 
          def attack(self, other): print(f"20 damage dealt to {other}")

        class Fly(ABC): 
          @abstractmethod 
          def fly(self): pass 

        class CanFly(Fly): 
          def fly(self): print("Flying") 

        class CannotFly(Fly): 
          def fly(self): print("Cannot fly.") 

        class Role(ABC): 
          @abstractmethod 
          def defend(self): pass 

        class DPS(Role): 
          def defend(self): print("Dodging") 

        class Tank(Role): 
          def defend(self): print("Raising a shield")

        class Support(Role): 
          def defend(self): print("Healed myself")
      \end{lstlisting} 

      \begin{lstlisting}
        class Hero: 

          def __init__(self, comp, fly, role): 
            self.comp: Composition = comp 
            self.fly: Fly = fly 
            self.role: Role = role 

          def attack(self, other): return self.comp.attack(other)
          def fly(self): return self.fly.fly() 
          def defend(self): return self.role.defend()


        winston = Hero(Diver(), CannotFly(), Tank()) 
        widowmaker = Hero(Poker(), CannotFly(), DPS()) 

        winston.attack(widowmaker) 
        # 20 damage dealt to ...
      \end{lstlisting}
    \end{example}

  \subsubsection{Observer} 

    Motivation. 

    \begin{definition}[Observer Pattern]
      In an \textbf{observer pattern}, objects subscribe to events and get notified when they occur. Its is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[News Publisher]
      \begin{lstlisting}
        class NewsPublisher:
            def __init__(self):
                self.subscribers = []
            
            def subscribe(self, subscriber):
                self.subscribers.append(subscriber)
            
            def notify(self, news):
                for subscriber in self.subscribers:
                    subscriber.update(news)

        class EmailSubscriber:
            def update(self, news):
                print(f"Email sent: {news}")

        class SMSSubscriber:
            def update(self, news):
                print(f"SMS sent: {news}")

        # Usage
        publisher = NewsPublisher()
        publisher.subscribe(EmailSubscriber())
        publisher.subscribe(SMSSubscriber())
        publisher.notify("Breaking news!")
      \end{lstlisting}

      which outputs 
      \begin{lstlisting}
        Email sent: Breaking news!
        SMS sent: Breaking news!
      \end{lstlisting}
    \end{example}

  \subsubsection{Command} 

    Motivation. 

    \begin{definition}[Command Pattern]
      In a \textbf{command pattern}, we encapsulate requests as objects, allowing parameterization and queuing.
    \end{definition}

    Results. 

    \begin{example}[Remote Control]
      \begin{lstlisting}
        class Light:
            def turn_on(self):
                print("Light is ON")
            
            def turn_off(self):
                print("Light is OFF")

        class TurnOnCommand:
            def __init__(self, light):
                self.light = light
            
            def execute(self):
                self.light.turn_on()

        class TurnOffCommand:
            def __init__(self, light):
                self.light = light
            
            def execute(self):
                self.light.turn_off()

        class RemoteControl:
            def __init__(self):
                self.command = None
            
            def set_command(self, command):
                self.command = command
            
            def press_button(self):
                self.command.execute()

        # Usage
        light = Light()
        remote = RemoteControl()

        remote.set_command(TurnOnCommand(light))
        remote.press_button()  # Light is ON

        remote.set_command(TurnOffCommand(light))
        remote.press_button()  # Light is OFF 
      \end{lstlisting}
    \end{example}

  \subsubsection{Template Method}

    Motivation. 

    \begin{definition}[Template Pattern]
      In a \textbf{template pattern}, we define the skeleton of an algorithm and let subclasses override specific steps. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Data Parsing]
      \begin{lstlisting}
        from abc import ABC, abstractmethod

        class DataParser(ABC):
            def parse(self):
                self.open_file()
                self.extract_data()
                self.parse_data()
                self.close_file()
            
            def open_file(self):
                print("Opening file...")
            
            @abstractmethod
            def extract_data(self):
                pass
            
            @abstractmethod
            def parse_data(self):
                pass
            
            def close_file(self):
                print("Closing file...")

        class CSVParser(DataParser):
            def extract_data(self):
                print("Extracting CSV data...")
            
            def parse_data(self):
                print("Parsing CSV format...")

        class JSONParser(DataParser):
            def extract_data(self):
                print("Extracting JSON data...")
            
            def parse_data(self):
                print("Parsing JSON format...")

        # Usage
        csv_parser = CSVParser()
        csv_parser.parse() 
      \end{lstlisting}
    \end{example}

  \subsubsection{Iterator}

    Motivation. 

    \begin{definition}[Iterator Pattern]
      In an \textbf{iterator pattern}, we provide a way to access elements sequentially without exposing underlying representations. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class BookCollection:
            def __init__(self):
                self.books = []
            
            def add_book(self, book):
                self.books.append(book)
            
            def __iter__(self):
                return BookIterator(self.books)

        class BookIterator:
            def __init__(self, books):
                self.books = books
                self.index = 0
            
            def __next__(self):
                if self.index < len(self.books):
                    book = self.books[self.index]
                    self.index += 1
                    return book
                raise StopIteration

        # Usage
        collection = BookCollection()
        collection.add_book("Python 101")
        collection.add_book("Design Patterns")
        collection.add_book("Clean Code")
        
        for book in collection:
            print(book) 
      \end{lstlisting}
    \end{example}

  \subsubsection{Chain of Responsibility}

    Motivation. 

    \begin{definition}[Chain of Responsibility]
      In a \textbf{chain of responsibility pattern}, we pass requests along a chain of handlers until one handles it. 
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class SupportHandler:
            def __init__(self):
                self.next_handler = None
            
            def set_next(self, handler):
                self.next_handler = handler
                return handler
            
            def handle(self, request):
                if self.next_handler:
                    return self.next_handler.handle(request)
                return None

        class Level1Support(SupportHandler):
            def handle(self, request):
                if request == "basic":
                    return "Level 1: Handling basic issue"
                return super().handle(request)

        class Level2Support(SupportHandler):
            def handle(self, request):
                if request == "intermediate":
                    return "Level 2: Handling intermediate issue"
                return super().handle(request)

        class Level3Support(SupportHandler):
            def handle(self, request):
                if request == "complex":
                    return "Level 3: Handling complex issue"
                return super().handle(request)

        # Usage
        l1 = Level1Support()
        l2 = Level2Support()
        l3 = Level3Support()

        l1.set_next(l2).set_next(l3)

        print(l1.handle("basic"))         # Level 1: Handling basic issue
        print(l1.handle("intermediate"))  # Level 2: Handling intermediate issue
        print(l1.handle("complex"))       # Level 3: Handling complex issue 
      \end{lstlisting}
    \end{example}

  \subsubsection{Interpreter}

    Motivation. 

    \begin{definition}[Interpreter Pattern]
      In an \textbf{interpreter pattern}, it defines a grammar and interprets sentences in that language. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class Context:
            def __init__(self):
                self.variables = {}
            
            def set_variable(self, name, value):
                self.variables[name] = value
            
            def get_variable(self, name):
                return self.variables.get(name, 0)

        class Expression:
            def interpret(self, context):
                pass

        class Number(Expression):
            def __init__(self, value):
                self.value = value
            
            def interpret(self, context):
                return self.value

        class Variable(Expression):
            def __init__(self, name):
                self.name = name
            
            def interpret(self, context):
                return context.get_variable(self.name)

        class Add(Expression):
            def __init__(self, left, right):
                self.left = left
                self.right = right
            
            def interpret(self, context):
                return self.left.interpret(context) + self.right.interpret(context)

        # Usage
        context = Context()
        context.set_variable("x", 10)
        context.set_variable("y", 5)

        # Expression: x + y + 3
        expression = Add(Add(Variable("x"), Variable("y")), Number(3))
        print(expression.interpret(context))  # 18 
      \end{lstlisting}
    \end{example}

  \subsubsection{Mediator}

    Motivation. 

    \begin{definition}[Mediator Pattern]
      In a \textbf{mediator pattern}, we define an object that coordinates communication between other objects. It is characterized by the following. 
      \begin{enumerate}
        \item 
      \end{enumerate}
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class ChatMediator:
            def __init__(self):
                self.users = []
            
            def add_user(self, user):
                self.users.append(user)
            
            def send_message(self, message, sender):
                for user in self.users:
                    if user != sender:
                        user.receive(message, sender)

        class User:
            def __init__(self, name, mediator):
                self.name = name
                self.mediator = mediator
                mediator.add_user(self)
            
            def send(self, message):
                print(f"{self.name} sends: {message}")
                self.mediator.send_message(message, self)
            
            def receive(self, message, sender):
                print(f"{self.name} receives from {sender.name}: {message}")

        # Usage
        mediator = ChatMediator()

        alice = User("Alice", mediator)
        bob = User("Bob", mediator)
        charlie = User("Charlie", mediator)

        alice.send("Hello everyone!")
        # Bob receives from Alice: Hello everyone!
        # Charlie receives from Alice: Hello everyone! 
      \end{lstlisting}
    \end{example}

  \subsubsection{Memento}

    Motivation. 

    \begin{definition}[Memento]
      In a \textbf{memento pattern}, it captures and restores an objects internal state without violating encapsulation. 
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class TextEditor:
            def __init__(self):
                self.content = ""
            
            def type(self, text):
                self.content += text
            
            def get_content(self):
                return self.content
            
            def save(self):
                return TextMemento(self.content)
            
            def restore(self, memento):
                self.content = memento.get_state()

        class TextMemento:
            def __init__(self, state):
                self._state = state
            
            def get_state(self):
                return self._state

        class History:
            def __init__(self):
                self.mementos = []
            
            def push(self, memento):
                self.mementos.append(memento)
            
            def pop(self):
                if self.mementos:
                    return self.mementos.pop()
                return None

        # Usage
        editor = TextEditor()
        history = History()

        editor.type("Hello ")
        history.push(editor.save())

        editor.type("World!")
        history.push(editor.save())

        editor.type(" How are you?")
        print(editor.get_content())  # Hello World! How are you?

        # Undo
        editor.restore(history.pop())
        print(editor.get_content())  # Hello World!

        # Undo again
        editor.restore(history.pop())
        print(editor.get_content())  # Hello 
      \end{lstlisting}
    \end{example}

  \subsubsection{Visitor}

    Motivation. 

    \begin{definition}[Visitor Pattern]
      In a \textbf{visitor pattern}, it separates algorithms from the objects they operate on. 
    \end{definition}

    Results. 

    \begin{example}[Case Study]
      \begin{lstlisting}
        class Element:
            def accept(self, visitor):
                pass

        class Book(Element):
            def __init__(self, title, price):
                self.title = title
                self.price = price
            
            def accept(self, visitor):
                visitor.visit_book(self)

        class Electronics(Element):
            def __init__(self, name, price):
                self.name = name
                self.price = price
            
            def accept(self, visitor):
                visitor.visit_electronics(self)

        class Visitor:
            def visit_book(self, book):
                pass
            
            def visit_electronics(self, electronics):
                pass

        class PriceCalculator(Visitor):
            def __init__(self):
                self.total = 0
            
            def visit_book(self, book):
                print(f"Book '{book.title}': ${book.price}")
                self.total += book.price
            
            def visit_electronics(self, electronics):
                print(f"Electronics '{electronics.name}': ${electronics.price}")
                self.total += electronics.price

        # Usage
        items = [
            Book("Design Patterns", 45),
            Electronics("Laptop", 1200),
            Book("Clean Code", 40)
        ]

        calculator = PriceCalculator()
        for item in items:
            item.accept(calculator)

        print(f"Total: ${calculator.total}") 
      \end{lstlisting}
    \end{example}

  \subsubsection{State} 

    Motivation. 
    
    \begin{definition}[State Pattern]
      In a \textbf{state pattern}, we can have an object change its behavior when its internal state changes. It is characterized by the following. 
      \begin{enumerate}
        \item It reduces the need for conditional statements depending on some attribute value.\footnote{Known as ``switch hell.''}  
        \item This is very similar to strategy, and sometimes interchangeable, depending on who you ask. 
      \end{enumerate}
    \end{definition}

    \begin{example}[Coin Machine]
      \begin{lstlisting}
        from abc import ABC, abstractmethod

        # State interface
        class State(ABC):
            @abstractmethod
            def insert_coin(self, machine):
                pass
            
            @abstractmethod
            def eject_coin(self, machine):
                pass
            
            @abstractmethod
            def dispense(self, machine):
                pass

        # Concrete States
        class NoCoinState(State):
            def insert_coin(self, machine):
                print("Coin inserted")
                machine.set_state(machine.has_coin_state)
            
            def eject_coin(self, machine):
                print("No coin to eject")
            
            def dispense(self, machine):
                print("Insert coin first")

        class HasCoinState(State):
            def insert_coin(self, machine):
                print("Coin already inserted")
            
            def eject_coin(self, machine):
                print("Coin ejected")
                machine.set_state(machine.no_coin_state)
            
            def dispense(self, machine):
                print("Dispensing item...")
                machine.set_state(machine.sold_state)

        class SoldState(State):
            def insert_coin(self, machine):
                print("Please wait, dispensing item")
            
            def eject_coin(self, machine):
                print("Cannot eject, already dispensing")
            
            def dispense(self, machine):
                print("Item dispensed!")
                machine.set_state(machine.no_coin_state)

        # Context
        class VendingMachine:
            def __init__(self):
                self.no_coin_state = NoCoinState()
                self.has_coin_state = HasCoinState()
                self.sold_state = SoldState()
                
                self.current_state = self.no_coin_state
            
            def set_state(self, state):
                self.current_state = state
            
            def insert_coin(self):
                self.current_state.insert_coin(self)
            
            def eject_coin(self):
                self.current_state.eject_coin(self)
            
            def dispense(self):
                self.current_state.dispense(self)

        # Usage
        machine = VendingMachine()

        machine.insert_coin()  # Coin inserted
        machine.dispense()     # Dispensing item...
        machine.dispense()     # Item dispensed!

        machine.dispense()     # Insert coin first
        machine.eject_coin()   # No coin to eject

        machine.insert_coin()  # Coin inserted
        machine.eject_coin()   # Coin ejected 
      \end{lstlisting}
    \end{example}

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Muchang Bahng | Duke Math</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/CSS/Pictures/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/CSS/Pictures/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/CSS/Pictures/favicon.ico">
  <link rel="stylesheet" href="/CSS/Header_Footer.css">
  <link rel="stylesheet" href="/CSS/html_notes.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    pre {
      background-color: rgb(213, 212, 212);
      overflow-x: visible
    }
  </style>
</head>



<body>
<div class="header">
  <div id="menu_button" onclick="myFunction(this)">
      <div id="bar1"></div>
      <div id="bar2"></div>
      <div id="bar3"></div>
  </div>
  <a id="HeaderName" href="/index.html" style="text-decoration: none;">Muchang Bahng</a>
</div>
  
  <div class="space" style="height:100px;"></div>
  <div class="information">
  
  <p class="title">Programming</p>
  <hr>
  
  <div class="toc">
    <div class="toctitle">Contents</div>
    <ol class="toclist">
      <li><a href="#Section1">Intermediate Topics</a></li>
      <li><a href="#Section2">Object Oriented Programming</a></li>
      <li><a href="#Section3">Regular Expressions</a></li>
    </ol>
  </div>

We assume that the reader is familiar with an introductory level of programming, such as the following. Things may slightly differ depending on which language the reader is working with. 
<ul>
  <li>Identifying basic types (Int, Float, String, Boolean) and data structures (List, Tuple, Set, Array, Dictionary)</li>
  <li>Working with variables, conditionals, for/while loops, and functions</li>
  <li>Knowing the basics of classes and objects, with methods and attributes. </li>
</ul>


<div class="title_and_hide">
<p id="Section1" class="section_title">Intermediate Topics</p>
<a id="show_hide_1" class="show_hide" onclick="show_hide_1()">[Hide]</a></div>
<hr>
<div id="section_content_1">

<div class="subsection_title">Pointers</div>


<div class="subsection_title">String Interpolation</div>


<div class="subsection_title">Local and Global Variables</div>


<div class="subsection_title">Anonymous Functions</div>


</div>

<div class="title_and_hide">
<p id="Section2" class="section_title">Object Oriented Programming</p>
<a id="show_hide_2" class="show_hide" onclick="show_hide_2()">[Hide]</a></div>
<hr>
<div id="section_content_2">

Recall that a class is basically a blueprint that is used to generate objects, also known as <i>class instantiation</i>. It contains <i>attributes</i> (variables of the object) and <i>methods</i> (functions of the object). Finally, the <i>constructor</i>, i.e. the <code>__init__()</code> method, is always called when an object is created. The constructor initializes (assign values) to the data members of the class when an object of this class is created. 

Finally, note the difference between the <i>object attributes/methods</i> and <i>class attributes/methods</i>. 
<ul>
  <li>The <code>self</code> keyword refers to the instantiated object itself, and so object attributes/methods, which are variables/functions associated with the <i>instantiated object</i>, will be called using the object name, in format <code>{object_name}.{attribute_method_name}</code>. </li>
  <li><i>Class attributes/methods</i> refers to the class itself, and so they will be called using the class name, in format <code>{class_name}.{attribute_method_name}</code>. They do not refer to an object, so we can call class attributes and methods without even instantiating any objects. </li>
</ul>

<pre>
class Person(): 

    is_mammal = True                                  #Class attribute

    def awk_silence():                                #Class method
        print("An awkward silence...")

    def __init__(self, first_name, last_name):        #Constructor function
        self.first_name = first_name                  #Initialize object attribute
        self.last_name = last_name                    #Initialize object attribute
        self.full_name = f"{first_name} {last_name}"  #Initialize object attribute

    def talk(self, dialogue):                         #Object method
        print(f"{self.first_name} says: {dialogue}")

charA = Person("Muchang", "Bahng")                    #Instantiate object charA of class Person
charB = Person("Sean", "Park")                        #Instantiate object charB of class Person

print(charA.full_name)                                #Print object attribute 'full_name' of charA
print(charB.full_name)                                #Print object attribute 'full_name' of charB

charA.talk("How's it going?")                         #Call object method 'talk' of charA
charB.talk("I'm depressed man...")                    #Call object method 'talk' of charB
Person.awk_silence()                                  #Call class method 'awk_silence'
charA.talk("I'm sorry to hear that. ")                #Call object method 'talk' of charA

print(Person.is_mammal)                               #Print class attribute 'is_mammal'
</pre>

There is an extreme variety of ways we can work with classes and objects. Any time we are working with a bunch of things of the same kind, we can use classes. Examples include 
<ol>
  <li>simulating particles bumping into each other within a box, with class <code>Particles</code> (with object attributes: <code>position</code>, <code>velocity</code>, <code>mass</code>, <code>radius</code> and class methods: <code>bump</code> and <code>reflect_wall</code>) and perhaps 100 objects representing 100 different particles. If the particles are all of the same type, we may set <code>mass</code> and <code>radius</code> as class attributes. </li>
  <li>an interactive game with 15 players. We can create a <code>Player</code> class with object attributes: <code>position</code>, <code>weight</code>, <code>height</code>, <code>shirt_color</code>, <code>pants_color</code>, <code>shoe_color</code>, class methods: <code>walk</code>, <code>run</code>, and object methods: <code>talk</code>. </li>
</ol>

<div class="subsection_title">Class Inheritance and Abstract Classes</div>

We can make subclasses (known as a <i>child class</i> or a <i>derived class</i>) from a <i>parent class</i>. All the attributes and methods of the parent class is shared within the child class, so we are able to call the parent attributes/methods without explicitly stating them in the child class body. One important thing to note: If the same method (e.g. <code>__init__</code>) is defined in both the parent and child class, then the method in the child class overrides that in the base class, completely replacing it. Generally, when overriding a base method, we want to extend the definition rather than simply replace it. 

<pre>
class Student(Person):                                  #Student is subclass of Person

    in_college = True

    def __init__(self, first_name, last_name, school, major, intelligence):    
      #Define constructor, which adds new attributes
        self.school = school                            #Additional object attributes of Student subclass
        self.major = major                              #Additional object attributes of Student subclass
        self.intelligence = intelligence                #Additional object attributes of Student subclass
      
      #Invoke the __init__ of the parent class 
        Person.__init__(self, first_name, last_name)    #Creates Person object, w/ parent attributes & methods

    def study(self):                                    #Object method of Student object                             
        print(f"{self.full_name} is studying {self.major} at {self.school}...")
        self.intelligence += 1
    
    def curfew():                                       #Class method of student object 
        print("Everyone returns to their dorms. ")
</pre>

We can see that a child object shares the attributes initialized from its parent class. 

<pre>
StudA = Student("Muchang", "Bahng", "Duke", "Math", 1)

print(StudA.first_name)     # Muchang
print(StudA.last_name)      # Bahng
print(StudA.full_name)      # Muchang Bahng
print(StudA.school)         # Duke
print(StudA.major)          # Math
print(StudA.intelligence)   # 1
</pre>

The parent class attributes and methods can be called using either the parent class or the child class. Remember, class attributes and methods do not even require any object to be instantiated. However, the child class attributes and methods cannot be called 
<pre>
#Calling parent class attribute
print(Person.is_mammal)   #True
print(Student.is_mammal)  #True

#Calling parent class method
Person.awk_silence()      # An awkward silence...
Student.awk_silence()     # An awkward silence...

#Calling child class attribute
print(Student.in_college) # True
print(Person.in_college)  # Error, type object 'Person' has no attribute 'in_college'

#Calling child class method 
Student.curfew()          #Everyone returns to their dorms. 
Person.curfew()           #Error, type object 'Person' has no attribute 'curfew'
</pre>

We can create a hierarchy of classes with inheritance, which leads us to the concept of <b>abstract classes</b>. Abstract classes are classes but they cannot be instantiated. Rather, we must create subclasses from them and should instantiate these ones. The purpose of abstract classes is to define how other classes should look like, i.e. what methods and properties they are expected to have. They attributes and methods defined (but not implemented) in an abstract class are called <b>abstract attributes</b> and <b>abstract methods</b>. Say that in a human role-playing game, we have the <code>Human</code> class (with relevant attributes and methods), with two subclasses <code>male</code> and <code>female</code> representing sex. We can interpret the <code>Human</code> class as an abstract class since every human is either a male or female, so to create a character must mean that we should instantiate from the <code>male</code> or <code>female</code> class. We can create an abstract class by inheriting from the <code>ABC</code> class which is part of the <code>abc</code> module. 

<pre>
from abc import ABC, abstractmethod 

class Human(ABC):               # Human is subclass of ABC --> it is an abstract class 
    def __init__(self, name):   # Constructor 
        self.name = name        # Abstract attribute
        self.level = 1          # Abstract attribute 

    
    @abstractmethod             # Decorator which indicates abstract method
    def walk(self):             # Abstract object method
        ... 

Player1 = Human("Muchang")      # Error
</pre>

We create the abstract class <code>Human</code> (by letting it be a subclass of ABC). We indicate that the method <code>walk</code> is an abstract method by using the <b>decorator</b> <code>@abstractmethod</code>, which means we expect this method to be implemented in every subclass of <code>Human</code>. Trying to create an object from <code>Human</code> directly results in a <code>TypeError</code>. 


<div class="subsection_title">Everything is an Object (Python Class Hierarchy)</div>
In object-oriented programming languages like Python, an <b>object</b> is an entity that contains data along with associated metadata and/or functionality. In Python, everything is an object, which means every (and yes, every) entity has some metadata (called attributes) and associated functionality (called methods). These attributes and methods are accessed via the dot syntax. 
Since Python is an object oriented programming language, everything is a class or objects of a class. We can interpret the types that we've learned in Python as classes themselves. 
<br><br>
In order to check the metadata and functionality of an object (i.e. what attributes and methods can I call on this object), then we can use the help keyword: 

<pre>
>>> x = 4
>>> help(x)
Help on int object:

class int(object)
 |  int([x]) -> integer
 |  int(x, base=10) -> integer
 |
 |  Convert a number or string to an integer, or return 0 if no arguments
 |  are given.  If x is a number, return x.__int__().  For floating point
 |  numbers, this truncates towards zero.
 |
 |  If x is not a number or if base is given, then x must be a string,
 |  bytes, or bytearray instance representing an integer literal in the
 |  given base.  The literal can be preceded by '+' or '-' and be surrounded
 |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |  Base 0 means to interpret the base from the string as an integer literal.
 |  >>> int('0b100', base=0)
 |  4
 |
 |  Built-in subclasses:
 |      bool
 |
 |  Methods defined here:
 |
 |  __abs__(self, /)
 |      abs(self)
 |
 |  __add__(self, value, /)
 |      Return self+value.
 |
 |  __and__(self, value, /)
 |      Return self&value.
 |
 |  __bool__(self, /)
 |      True if self else False
 |
 |  __ceil__(...)
 |      Ceiling of an Integral returns itself.
 |
 |  __divmod__(self, value, /)
 |      Return divmod(self, value).
 |
 |  __eq__(self, value, /)
 |      Return self==value.
 |
 |  __float__(self, /)
 |      float(self)
</pre>

Since we said that everything is an object, it is not too unreasonable to guess some sort of hierarchy of classes built into Python. This is indeed the case, and at the very top of the class hierarchy is the <code>object</code> class. It is meant to be an abstract class, so everything is an instantiation of a subclass of <code>object</code>. As of May 2022, the <code>object</code> class has about 150 subclasses, including <code>int</code>, <code>float</code>, etc.). 

We introduce further commands to navigate the hierarchy and structure of classes. 
<ul>
  <li>
    To find all subclasses of a class, use the <i>class</i> method (not object method) <code>__subclasses__()</code>. 
    <pre>
    >>> int.__subclasses__()
    [&lt;class 'bool'>, &lt;enum 'IntEnum'>, &lt;enum 'IntFlag'>, &lt;class 'sre_constants._NamedIntConstant'>, 
    &lt;class 'subprocess.Handle'>]
    </pre>
  </li>
  <li>
    To find the direct parent class(es) of a class, we use the class attribute <code>__bases__</code>
    <pre>
    class A(object):        #Create class 'A' (subclass of 'object class'
        pass 
    
    class B(object):        #Create class 'A' (subclass of 'object class'
        pass 
    
    class C(A, B):          #Create class 'A' (subclass of 'A', 'B') 
        pass 
    
    print(C.__bases__)      #(&ltclass '__main__.A'>, &ltclass '__main__.B'>)
    </pre>
  </li>
  <li>
    If you want all the ancestors (in order) rather than the immediate ones, use the <code>__mro__</code> class attribute. 
    <pre>
    >>> str.__mro__ 
    (&lt;class 'str'>, &lt;class 'object'>)
    </pre>
  </li>
  <li>
    To get the list of all the class attributes and class methods of a class, we can use the built-in function <code>dir(class_name)</code>. To get a list of all the object attributes and object methods of an object, we can also use the built-in function <code>dir(object_name)</code>. Using the <code>Person</code> and <code>Student</code> classes defined above, we show: 
    <pre>
    >>> x = Student("Muchang", "Bahng", "Duke", "Math", 1)
    >>> dir(x)
    ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
    '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
    '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', 
    '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 
    'awk_silence', 'curfew', 'first_name', 'full_name', 'in_college', 'intelligence', 
    'is_mammal', 'last_name', 'major', 'school', 'study', 'talk']
    </pre>
    Notice that all the functions in the double underscores were not explicitly constructed when we defined our <code>Person</code> and <code>Student</code> classes, but rather inherited from the <code>object</code> class. We can see below that the parent class of <code>Person</code> is <code>object</code>, which does indeed contain the identified attributes/methods. 
    <pre>
    print(Student.__base__)       # &lt;class '__main__.Person'>
    print(Person.__base__)        # &lt;class 'object'>
    print(dir(object))
    # ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
    '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', 
    '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
    '__sizeof__', '__str__', '__subclasshook__']
    </pre>
  </li>
</ul>

<div class="subsection_title">Built-In Functions/Operators and Dunder Methods</div>
We first should clarify the distinction between functions and expression operators in Python. In general, they are both a map (in the mathematical sense) and are just represented differently. 
<ul>
  <li>A function is a map that is of form <code>function(args)</code>. There are built-in functions (e.g. <code>len()</code> or <code>abs()</code>) or we can explicitly define them. Either way, letting $\texttt{CLS}$ be the set of all objects of class $\texttt{CLS}$, we can say that the functions above are (by default) maps with the following domain and codomains:  
  \begin{align*}
    \texttt{len()}: & \texttt{STR} \cup \texttt{LIST} \cup \ldots \cup \texttt{DICTIONARY} \longrightarrow \texttt{INT} \\
    \texttt{abs()}: & \texttt{INT} \cup \texttt{FLOAT} \longrightarrow \texttt{INT} \cup \texttt{FLOAT} 
  \end{align*}
  </li>
  <li>
    An operator is also considered a map, but the only difference is syntax. They are represented with <i>symbols</i>, such as <code>+</code> in <code>2 + 3</code>, <code>&lt;</code> in <code>1 &lt; 5</code>, and <code>[]</code> in <code>string.[i]</code>. Again, we can interpret them as mathematical maps with the following domain and codomains, where $\texttt{CLS}^2 = \texttt{CLS} \times \texttt{CLS}$: 
    \begin{align*} 
      \texttt{+} & : \texttt{INT}^2 \cup \texttt{STR}^2 \cup \texttt{LIST}^2 \longrightarrow \texttt{INT} \cup \texttt{STR} \cup \texttt{LIST} \\
      \texttt{&lt;} & : \texttt{INT}^2 \cup \texttt{FLOAT}^2 \longrightarrow \texttt{BOOL} \\
      \texttt{[]} & : ( \texttt{STR} \cup \texttt{LIST} ) \cup \texttt{INT} \longrightarrow \texttt{OBJECT} 
    \end{align*}
  </li>
</ul>
Another difference is that the set of all syntactic operators is fixed and new ones cannot be added by your Python code. You can't write your own code to define a new operator called <code>$</code> and then have <code>x $ y</code> work. On the other hand, you can define as many methods as you want. Fundamentally though, there really is no difference between functions and operators.
<br><br>
The Python interpreter has a number of built-in functions and operators that are always available (which can be easily googled). When we call these functions/operators, what really happens in the background is that they are just shortcuts that invokes a specific object method of whatever argument we are working with. Here are some examples: 
<ul>
  <li>
    The <code>abs</code> function accepts an integer, a float, or any argument with an <code>__abs__()</code> method. It invokes the <code>__abs__()</code> method of its object argument, which, by default for int and float, returns the absolute value of a number. 
    <pre>
    >>> x = 4 
    >>> y = -2.41
    >>> abs(x)
    4 
    >>> x.__abs__()
    4
    >>> abs(y)
    2.41
    >>> y.__abs__() 
    2.41
    </pre>
    Note that we can create a custom class with a custom <code>__abs__()</code> method. 
    <pre>
    class testClass(): 
    
        def __init__(self, arg1): 
            self.arg1 = arg1 
        
        def __abs__(self): 
            return f"Hello, I am {self.arg1}"
  
    x = testClass("Muchang")
    print(x.__abs__())              # Hello, I am Muchang
    print(abs(x))                   # Hello, I am Muchang
    </pre>
    As you can see, calling the <code>__abs__</code> method directly using the dot syntax and calling the <code>abs</code> function returns the same output. 
  </li>
  <li>
    The <code>len</code> function accepts a sequence (e.g. string, bytes, tuple, list, range), a collection (e.g. dictionary, set), or any argument with a <code>__len__()</code> method. It invokes, the <code>__len__()</code> method of its object argument, which, by default for the mentioned types, returns the length (the number of items) of an object. 
    <pre>
    >>> x = "Hello World"
    >>> y = [1, 3, 4, "hi", "hello"]
    >>> len(x)
    11
    >>> x.__len__()
    11
    >>> len(y)
    5
    >>> y.__len__()
    5
    </pre>
    Note that we can create a custom class with a custom <code>__len__()</code> method. 
    <pre>
    class testClass(): 
    
        def __init__(self, arg1): 
            self.arg1 = arg1 
        
        def __len__(self): 
            return 34

    x = testClass("Muchang")
    print(len(x))               # 34
    print(x.__len__())          # 34
    </pre>
    For some reason, it throws an error when <code>__len__()</code> returns a non-integer type, so we can't just copy and paste the previous example code (which is why we replaced the string with the integer <code>34</code>). However, the logic is the same. 
  </li>
  <li>
    The <code>+</code> operator can accept 2 integers, 2 strings, 2 lists, or any first argument with a <code>__add__(other)</code> method followed by an arbitrary second argument that is compatible with the definition of the method. It invokes, the <code>__add__(other)</code> method of its object argument. 
    <pre>
    >>> x = 2
    >>> y = 9
    >>> x + y         
    11 
    >>> x.__add__(y)  #Object method of 'x' with argument 'y'
    11 
    >> y + x 
    11 
    >> y.__add__(x)   #Object method of 'y' with argument 'x'
    11 
    </pre>
    Note that <code>x + y</code> calls <code>x.__add__(y)</code> and <code>y + x</code> calls <code>y.__add__(x)</code>. So, <code>x + y</code> is fundamentally different from <code>y + x</code> and equality is achieved due to commutativity of the <code>__add__()</code> operator. If we were to modify the <code>__add__()</code> method, then commutativity may not be achieved. 
  </li>
  <li>
    The indexing expression operator <code>[]</code> accepts some sequence (or any object having the <code>__getitem__(i)</code> method), and it calls the <code>__getitem__(i)</code>, where <code>i</code> is an integer. Let us implement this into the <code>Student</code> class. We will add an (object) attribute called <code>courses</code> which will be a list, and add the <code>__getitem__(i)</code> so that we can index the object directly. 
    <pre>
    class Student(Person): 

        in_college = True    

        def __init__(self, first_name, last_name, school, major, intelligence, courses):    
            self.school = school
            self.major = major 
            self.intelligence = intelligence
            self.courses = courses
            Person.__init__(self, first_name, last_name)

        def study(self):                         
            print(f"{self.full_name} is studying {self.major} at {self.school}...")
            self.intelligence += 1
        
        def curfew(): 
            print("Everyone returns to their dorms. ")

        def __getitem__(i): 
            return self.courses[i]

    x = Student("Muchang", "Bahng", "Duke", "Math", 1, ["Lin Alg", "Multi"])
    print(x.courses[1])     # Multi
    print(x[1])             # Multi 
    </pre>
    Normally, we can return the elements of the courses list by indexing from the attribute <code>x.courses</code>, which is a list. But if we want to index <i>directly</i> from the object itself, we must include the <code>__getitem__(i)</code> method. <code>x[1]</code> calls <code>x.__getitem__(1)</code>.  
  </li>
  <li>
    The operators <code>-, *, /, ==, &lt;, &gt;, &lt;=;, &gt;=</code> also call certain dunder methods
    <pre>
    >>> x - y     # Calls x.__sub__(y)
    8
    >>> x * y     # Calls x.__mul__(y)
    20
    >>> x / y     # Calls x.__truediv__(y)
    5.0
    >>> x == y    # Calls x.__eq__(y)
    False
    >>> x &lt;= y # Calls x.__lt__(y)
    False
    >>> x >= y    # Calls x.__gt__(y)
    True
    </pre>
  </li>
  <li>
    If we create a new class, instantiate an object, and try to print that object, it returns the class of that object followed by its <code>id</code>. 
    <pre>
      class testClass(): 
    
          def __init__(self, name): 
              self.name = name
  
      x = testClass("Muchang")
      print(x)                    # &lt;__main__.testClass object at 0x000001F1B2D84FD0>
    </pre> 
    <code>print</code> is also a function, and when we call <code>print(object)</code>, in the background it really calls the <code>__str__()</code> method in the object. Therefore, adding the <code>__str__()</code> method allows us to apply the <code>print</code> function. 
    <pre>
    class testClass(): 
  
        def __init__(self, name): 
            self.name = name
  
        def __str__(self): 
            return f"Name: {self.name}"
          

    x = testClass("Muchang")
    print(x)                    #Name: Muchang
    </pre>
    There is another very similar method called the <code>__repr__()</code> method that also converts to a string, but with some differences (irrelevant here). In JupyterNotebook or the command line, we don't have to call <code>print</code> in order to print. It does so automatically: 
    <pre>
    >>> x = 4 
    >>> x 
    4
    </pre>
    In this case, the <code>__repr__()</code> method is called when we just typed <code>x</code>, and without defining this method, the console would output the object id: 
    <pre>
    >>> class testClass():
    ...     def __init__(self, name):
    ...             self.name = name
    ...
    ...     def __str__(self):
    ...             return f"Name: {self.name}"
    ...
    >>> x = testClass("Muchang")
    >>> print(x)
    Name: Muchang
    >>>
    >>> x
    &lt;__main__.testClass object at 0x000001C874E6A140>
    </pre>
    To ensure that our class supports this, we should define <code>__repr__()</code>: 
    <pre>
    >>> class testClass():
    ...
    ...     def __init__(self, name):
    ...             self.name = name
    ... #
    ...     def __str__(self):
    ...             return f"Name: {self.name}"
    ... #
    ...     def __repr__(self):
    ...             return f"Name: {self.name}"
    ... 
    >>> x = testClass("Muchang")
    >>> print(x)
    Name: Muchang
    >>> x
    Name: Muchang
    </pre>
  </li>
  <li>
    The operators <code>+=, -=, *=, /=</code> also calls dunder methods. 
    <pre>
    >>> x = 4 
    >>> y = 2 
    >>> x += y      # x.__iadd__(y)
    >>> x -= y      # x.__isub__(y)
    >>> x *= y      # x.__imul__(y)
    >>> x /= y      # x.__itruediv__(y)
    </pre>
  </li>
</ul>
The examples above show how we are able to build custom classes and customize existing classes. However, it is not recommended to change any of the built-in functions and its associated methods. 
<br><br>
Now we can introduce <b>dunder/magic methods</b>, which are methods having two prefix and suffix underscores in the method name. The "dunder" is shorthand for "double underscore." These methods are used for operator overloading, which means to give a certain method an extended meaning beyond their predefined operational meaning. For example, the <code>__add__()</code> operator is used to add two integers as well as join two strings and merge two lists. This is because the <code>__add__()</code> operator is overloaded by the <code>int</code>, <code>str</code>, and <code>list</code> classes. 
<pre>
>>> int1 = 2
>>> int2 = 5
>>> str1 = "Hello "
>>> str2 = "World"
>>> list1 = [1, 2, 3]
>>> list2 = [4, 5, 6]
>>> int1.__add__(int2)
7
>>> str1.__add__(str2)
'Hello World'
>>> list1.__add__(list2)
[1, 2, 3, 4, 5, 6]
</pre>
There are many other overloaded operators, the most common being the <code>__init__()</code> method which is called whenever an object is instantiated. All of the operators mentioned above are also overloaded, since they are implemented in multiple classes. 

</div>

<div class="title_and_hide">
<p id="Section3" class="section_title">Regular Expressions</p>
<a id="show_hide_3" class="show_hide" onclick="show_hide_3()">[Hide]</a></div>
<hr>
<div id="section_content_3">

</div>

<div class="title_and_hide">
<p id="Section4" class="section_title">Requests & APIs</p>
<a id="show_hide_4" class="show_hide" onclick="show_hide_4()">[Hide]</a></div>
<hr>
<div id="section_content_4">

</div>

<div class="title_and_hide">
<p id="Section5" class="section_title">Webscraping with BeautifulSoup4</p>
<a id="show_hide_5" class="show_hide" onclick="show_hide_5()">[Hide]</a></div>
<hr>
<div id="section_content_5">
  
</div>

<div class="title_and_hide">
<p id="Section6" class="section_title">Scrapy</p>
<a id="show_hide_6" class="show_hide" onclick="show_hide_6()">[Hide]</a></div>
<hr>
<div id="section_content_6">
  
</div>

<div class="title_and_hide">
<p id="Section7" class="section_title">Swift</p>
<a id="show_hide_7" class="show_hide" onclick="show_hide_7()">[Hide]</a></div>
<hr>
<div id="section_content_7">
  
</div>

<script src="/JS/html_notes.js"></script>
</body>
</html>
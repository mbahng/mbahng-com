<!DOCTYPE html>
<html lang="en">
<head>
  <title>Muchang Bahng | Duke Math</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/CSS/Pictures/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/CSS/Pictures/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/CSS/Pictures/favicon.ico">
  <link rel="stylesheet" href="/CSS/Header_Footer.css">
  <link rel="stylesheet" href="/CSS/html_notes.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
</head>


<body>
<div class="header">
  <div id="menu_button" onclick="myFunction(this)">
      <div id="bar1"></div>
      <div id="bar2"></div>
      <div id="bar3"></div>
  </div>
  <a id="HeaderName" href="/index.html" style="text-decoration: none;">Muchang Bahng</a>
</div>
  
  <div class="space" style="height:100px;"></div>
  <div class="information">
  
  <p class="title">Programming</p>
  <hr>
  
  <div class="toc">
    <div class="toctitle">Contents</div>
    <ol class="toclist">
      <li><a href="#Section1">Intermediate Topics</a></li>
      <li><a href="#Section2">Object Oriented Programming</a></li>
      <li><a href="#Section3">Regular Expressions</a></li>
    </ol>
  </div>

We assume that the reader is familiar with an introductory level of programming, such as the following. Things may slightly differ depending on which language the reader is working with. 
<ul>
  <li>Identifying basic types (Int, Float, String, Boolean) and data structures (List, Tuple, Set, Array, Dictionary)</li>
  <li>Working with variables, conditionals, for/while loops, and functions</li>
  <li>Knowing the basics of classes and objects, with methods and attributes. </li>
</ul>


<div class="title_and_hide">
<p id="Section1" class="section_title">Intermediate Topics</p>
<a id="show_hide_1" class="show_hide" onclick="show_hide_1()">[Hide]</a></div>
<hr>
<div id="section_content_1">

<div class="subsection_title">Pointers</div>


<div class="subsection_title">String Interpolation</div>


<div class="subsection_title">Local and Global Variables</div>


<div class="subsection_title">Anonymous Functions</div>


</div>

<div class="title_and_hide">
<p id="Section2" class="section_title">Object Oriented Programming</p>
<a id="show_hide_2" class="show_hide" onclick="show_hide_2()">[Hide]</a></div>
<hr>
<div id="section_content_2">

Recall that a class is basically a blueprint that is used to generate objects, also known as <i>class instantiation</i>. It contains <i>attributes</i> (variables of the object) and <i>methods</i> (functions of the object). Finally, the <i>constructor</i>, i.e. the <code>__init__()</code> method, is always called when an object is created. The constructor initializes (assign values) to the data members of the class when an object of this class is created. 

Finally, note the difference between the <i>object attributes/methods</i> and <i>class attributes/methods</i>. 
<ul>
  <li>The <code>self</code> keyword refers to the instantiated object itself, and so object attributes/methods, which are variables/functions associated with the <i>instantiated object</i>, will be called using the object name, in format <code>{object_name}.{attribute_method_name}</code>. </li>
  <li><i>Class attributes/methods</i> refers to the class itself, and so they will be called using the class name, in format <code>{class_name}.{attribute_method_name}</code>. They do not refer to an object, so we can call class attributes and methods without even instantiating any objects. </li>
</ul>

<pre>
class Person(): 

    is_mammal = True                                  #Class attribute

    def awk_silence():                                #Class method
        print("An awkward silence...")

    def __init__(self, first_name, last_name):        #Constructor function
        self.first_name = first_name                  #Initialize object attribute
        self.last_name = last_name                    #Initialize object attribute
        self.full_name = f"{first_name} {last_name}"  #Initialize object attribute

    def talk(self, dialogue):                         #Object method
        print(f"{self.first_name} says: {dialogue}")

charA = Person("Muchang", "Bahng")                    #Instantiate object charA of class Person
charB = Person("Sean", "Park")                        #Instantiate object charB of class Person

print(charA.full_name)                                #Print object attribute 'full_name' of charA
print(charB.full_name)                                #Print object attribute 'full_name' of charB

charA.talk("How's it going?")                         #Call object method 'talk' of charA
charB.talk("I'm depressed man...")                    #Call object method 'talk' of charB
Person.awk_silence()                                  #Call class method 'awk_silence'
charA.talk("I'm sorry to hear that. ")                #Call object method 'talk' of charA

print(Person.is_mammal)                               #Print class attribute 'is_mammal'
</pre>

There is an extreme variety of ways we can work with classes and objects. Any time we are working with a bunch of things of the same kind, we can use classes. Examples include 
<ol>
  <li>simulating particles bumping into each other within a box, with class <code>Particles</code> (with object attributes: <code>position</code>, <code>velocity</code>, <code>mass</code>, <code>radius</code> and class methods: <code>bump</code> and <code>reflect_wall</code>) and perhaps 100 objects representing 100 different particles. If the particles are all of the same type, we may set <code>mass</code> and <code>radius</code> as class attributes. </li>
  <li>an interactive game with 15 players. We can create a <code>Player</code> class with object attributes: <code>position</code>, <code>weight</code>, <code>height</code>, <code>shirt_color</code>, <code>pants_color</code>, <code>shoe_color</code>, class methods: <code>walk</code>, <code>run</code>, and object methods: <code>talk</code>. </li>
</ol>

<div class="subsection_title">Class Inheritance and Abstract Classes</div>

We can make subclasses (known as a <i>child class</i> or a <i>derived class</i>) from a <i>parent class</i>. All the attributes and methods of the parent class is shared within the child class, so we are able to call the parent attributes/methods without explicitly stating them in the child class body. One important thing to note: If the same method (e.g. <code>__init__</code>) is defined in both the parent and child class, then the method in the child class overrides that in the base class, completely replacing it. Generally, when overriding a base method, we want to extend the definition rather than simply replace it. 

<pre>
class Student(Person):                                  #Student is subclass of Person

    in_college = True

    def __init__(self, first_name, last_name, school, major, intelligence):    
      #Define constructor, which adds new attributes
        self.school = school                            #Additional object attributes of Student subclass
        self.major = major                              #Additional object attributes of Student subclass
        self.intelligence = intelligence                #Additional object attributes of Student subclass
      
      #Invoke the __init__ of the parent class 
        Person.__init__(self, first_name, last_name)    #Creates Person object, w/ parent attributes & methods

    def study(self):                                    #Object method of Student object                             
        print(f"{self.full_name} is studying {self.major} at {self.school}...")
        self.intelligence += 1
    
    def curfew():                                       #Class method of student object 
        print("Everyone returns to their dorms. ")
</pre>

We can see that a child object shares the attributes initialized from its parent class. 

<pre>
StudA = Student("Muchang", "Bahng", "Duke", "Math", 1)

print(StudA.first_name)     # Muchang
print(StudA.last_name)      # Bahng
print(StudA.full_name)      # Muchang Bahng
print(StudA.school)         # Duke
print(StudA.major)          # Math
print(StudA.intelligence)   # 1
</pre>

The parent class attributes and methods can be called using either the parent class or the child class. Remember, class attributes and methods do not even require any object to be instantiated. However, the child class attributes and methods cannot be called 
<pre>
#Calling parent class attribute
print(Person.is_mammal)   #True
print(Student.is_mammal)  #True

#Calling parent class method
Person.awk_silence()      # An awkward silence...
Student.awk_silence()     # An awkward silence...

#Calling child class attribute
print(Student.in_college) # True
print(Person.in_college)  # Error, type object 'Person' has no attribute 'in_college'

#Calling child class method 
Student.curfew()          #Everyone returns to their dorms. 
Person.curfew()           #Error, type object 'Person' has no attribute 'curfew'
</pre>

We can create a hierarchy of classes with inheritance, which leads us to the concept of <b>abstract classes</b>. Abstract classes are classes but they cannot be instantiated. Rather, we must create subclasses from them and should instantiate these ones. The purpose of abstract classes is to define how other classes should look like, i.e. what methods and properties they are expected to have. They attributes and methods defined (but not implemented) in an abstract class are called <b>abstract attributes</b> and <b>abstract methods</b>. Say that in a human role-playing game, we have the <code>Human</code> class (with relevant attributes and methods), with two subclasses <code>male</code> and <code>female</code> representing sex. We can interpret the <code>Human</code> class as an abstract class since every human is either a male or female, so to create a character must mean that we should instantiate from the <code>male</code> or <code>female</code> class. We can create an abstract class by inheriting from the <code>ABC</code> class which is part of the <code>abc</code> module. 

<pre>
from abc import ABC, abstractmethod 

class Human(ABC):               # Human is subclass of ABC --> it is an abstract class 
    def __init__(self, name):   # Constructor 
        self.name = name        # Abstract attribute
        self.level = 1          # Abstract attribute 

    
    @abstractmethod             # Decorator which indicates abstract method
    def walk(self):             # Abstract object method
        ... 

Player1 = Human("Muchang")      # Error
</pre>

We create the abstract class <code>Human</code> (by letting it be a subclass of ABC). We indicate that the method <code>walk</code> is an abstract method by using the <b>decorator</b> <code>@abstractmethod</code>, which means we expect this method to be implemented in every subclass of <code>Human</code>. Trying to create an object from <code>Human</code> directly results in a <code>TypeError</code>. 


<div class="subsection_title">Everything is an Object (Python Class Hierarchy)</div>
In object-oriented programming languages like Python, an <b>object</b> is an entity that contains data along with associated metadata and/or functionality. In Python, everything is an object, which means every (and yes, every) entity has some metadata (called attributes) and associated functionality (called methods). These attributes and methods are accessed via the dot syntax. 
Since Python is an object oriented programming language, everything is a class or objects of a class. We can interpret the types that we've learned in Python as classes themselves. 
<br><br>
In order to check the metadata and functionality of an object (i.e. what attributes and methods can I call on this object), then we can use the help keyword: 

<pre>
>>> x = 4
>>> help(x)
Help on int object:

class int(object)
 |  int([x]) -> integer
 |  int(x, base=10) -> integer
 |
 |  Convert a number or string to an integer, or return 0 if no arguments
 |  are given.  If x is a number, return x.__int__().  For floating point
 |  numbers, this truncates towards zero.
 |
 |  If x is not a number or if base is given, then x must be a string,
 |  bytes, or bytearray instance representing an integer literal in the
 |  given base.  The literal can be preceded by '+' or '-' and be surrounded
 |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |  Base 0 means to interpret the base from the string as an integer literal.
 |  >>> int('0b100', base=0)
 |  4
 |
 |  Built-in subclasses:
 |      bool
 |
 |  Methods defined here:
 |
 |  __abs__(self, /)
 |      abs(self)
 |
 |  __add__(self, value, /)
 |      Return self+value.
 |
 |  __and__(self, value, /)
 |      Return self&value.
 |
 |  __bool__(self, /)
 |      True if self else False
 |
 |  __ceil__(...)
 |      Ceiling of an Integral returns itself.
 |
 |  __divmod__(self, value, /)
 |      Return divmod(self, value).
 |
 |  __eq__(self, value, /)
 |      Return self==value.
 |
 |  __float__(self, /)
 |      float(self)
</pre>

Since we said that everything is an object, it is not too unreasonable to guess some sort of hierarchy of classes built into Python. This is indeed the case, and at the very top of the class hierarchy is the <code>object</code> class. It is meant to be an abstract class, so everything is an instantiation of a subclass of <code>object</code>. As of May 2022, the <code>object</code> class has about 150 subclasses, including <code>int</code>, <code>float</code>, etc.). 

We introduce further commands to navigate the hierarchy and structure of classes. 
<ul>
  <li>
    To find all subclasses of a class, use the <i>class</i> method (not object method) <code>__subclasses__()</code>. 
    <pre>
    >>> int.__subclasses__()
    [&lt;class 'bool'>, &lt;enum 'IntEnum'>, &lt;enum 'IntFlag'>, &lt;class 'sre_constants._NamedIntConstant'>, 
    &lt;class 'subprocess.Handle'>]
    </pre>
  </li>
  <li>
    To find the direct parent class(es) of a class, we use the class attribute <code>__bases__</code>
    <pre>
    class A(object):        #Create class 'A' (subclass of 'object class'
        pass 
    
    class B(object):        #Create class 'A' (subclass of 'object class'
        pass 
    
    class C(A, B):          #Create class 'A' (subclass of 'A', 'B') 
        pass 
    
    print(C.__bases__)      #(&ltclass '__main__.A'>, &ltclass '__main__.B'>)
    </pre>
  </li>
  <li>
    If you want all the ancestors (in order) rather than the immediate ones, use the <code>__mro__</code> class attribute. 
    <pre>
    >>> str.__mro__ 
    (&lt;class 'str'>, &lt;class 'object'>)
    </pre>
  </li>
  <li>
    To get the list of all the class attributes and class methods of a class, we can use the built-in function <code>dir(class_name)</code>. To get a list of all the object attributes and object methods of an object, we can also use the built-in function <code>dir(object_name)</code>. Using the <code>Person</code> and <code>Student</code> classes defined above, we show: 
    <pre>
    >>> x = Student("Muchang", "Bahng", "Duke", "Math", 1)
    >>> dir(x)
    ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
    '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
    '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', 
    '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 
    'awk_silence', 'curfew', 'first_name', 'full_name', 'in_college', 'intelligence', 
    'is_mammal', 'last_name', 'major', 'school', 'study', 'talk']
    </pre>
    Notice that all the functions in the double underscores were not explicitly constructed when we defined our <code>Person</code> and <code>Student</code> classes, but rather inherited from the <code>object</code> class. We can see below that the parent class of <code>Person</code> is <code>object</code>, which does indeed contain the identified attributes/methods. 
    <pre>
    print(Student.__base__)       # &lt;class '__main__.Person'>
    print(Person.__base__)        # &lt;class 'object'>
    print(dir(object))
    # ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
    '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', 
    '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
    '__sizeof__', '__str__', '__subclasshook__']
    </pre>
  </li>
</ul>

<div class="subsection_title">Built-In Functions</div>
The Python interpreter has a number of built-in functions and types built into it that are always available. All of them can be easily googled. Note that given a built-in function with an object input <code>function(Obj)</code>, this function is really just a shortcut that implements a specific object method of <code>Obj</code>. Here are some examples: 
<ul>
  <li>
    The <code>abs</code> function accepts an integer, a float, or any argument with an <code>__abs__()</code> method. It invokes the <code>__abs__()</code> method of its object argument, which, by default for int and float, returns the absolute value of a number. 
    <pre>
    >>> x = 4 
    >>> y = -2.41
    >>> abs(x)
    4 
    >>> x.__abs__()
    4
    >>> abs(y)
    2.41
    >>> y.__abs__() 
    2.41
    </pre>
    Note that we can create a custom class with a custom <code>__abs__()</code> method. 
    <pre>
    class testClass(): 
    
        def __init__(self, arg1): 
            self.arg1 = arg1 
        
        def __abs__(self): 
            return f"Hello, I am {self.arg1}"
  
    x = testClass("Muchang")
    print(x.__abs__())              # Hello, I am Muchang
    print(abs(x))                   # Hello, I am Muchang
    </pre>
    As you can see, calling the <code>__abs__</code> method directly using the dot syntax and calling the <code>abs</code> function returns the same output. 
  </li>
  <li>
    The <code>len</code> function accepts a sequence (e.g. string, bytes, tuple, list, range), a collection (e.g. dictionary, set), or any argument with a <code>__len__()</code> method. It invokes, the <code>__len__()</code> method of its object argument, which, by default for the mentioned types, returns the length (the number of items) of an object. 
    <pre>
    >>> x = "Hello World"
    >>> y = [1, 3, 4, "hi", "hello"]
    >>> len(x)
    11
    >>> x.__len__()
    11
    >>> len(y)
    5
    >>> y.__len__()
    5
    </pre>
    Note that we can create a custom class with a custom <code>__len__()</code> method. 
    <pre>
    class testClass(): 
    
        def __init__(self, arg1): 
            self.arg1 = arg1 
        
        def __len__(self): 
            return 34

    x = testClass("Muchang")
    print(len(x))               # 34
    print(x.__len__())          # 34
    </pre>
    For some reason, it throws an error when <code>__len__()</code> returns a non-integer type, so we can't just copy and paste the previous example code (which is why we replaced the string with the integer <code>34</code>). However, the logic is the same. 
  </li>
</ul>
The examples above show how we are able built custom classes and customize existing classes. However, it is not recommended to change any of the built-in functions and its associated methods. 


<div class="subsection_title">Dunder/Magic Methods</div>

</div>

<div class="title_and_hide">
<p id="Section3" class="section_title">Regular Expressions</p>
<a id="show_hide_3" class="show_hide" onclick="show_hide_3()">[Hide]</a></div>
<hr>
<div id="section_content_3">

</div>

<div class="title_and_hide">
<p id="Section4" class="section_title">Requests & APIs</p>
<a id="show_hide_4" class="show_hide" onclick="show_hide_4()">[Hide]</a></div>
<hr>
<div id="section_content_4">

</div>

<div class="title_and_hide">
<p id="Section5" class="section_title">Webscraping with BeautifulSoup4</p>
<a id="show_hide_5" class="show_hide" onclick="show_hide_5()">[Hide]</a></div>
<hr>
<div id="section_content_5">
  
</div>

<div class="title_and_hide">
<p id="Section6" class="section_title">Scrapy</p>
<a id="show_hide_6" class="show_hide" onclick="show_hide_6()">[Hide]</a></div>
<hr>
<div id="section_content_6">
  
</div>

<div class="title_and_hide">
<p id="Section7" class="section_title">Swift</p>
<a id="show_hide_7" class="show_hide" onclick="show_hide_7()">[Hide]</a></div>
<hr>
<div id="section_content_7">
  
</div>

<script src="/JS/html_notes.js"></script>
</body>
</html>
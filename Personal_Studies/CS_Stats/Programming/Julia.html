<!DOCTYPE html>
<html lang="en">
<head>
  <title>Muchang Bahng | Duke Math</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/CSS/Pictures/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/CSS/Pictures/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/CSS/Pictures/favicon.ico">
  <link rel="stylesheet" href="/CSS/Header_Footer.css">
  <link rel="stylesheet" href="/CSS/html_notes.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    pre {
      background-color: rgb(213, 212, 212);
      overflow-x: visible
    }
  </style>
</head>

<body>
<div class="header">
  <div id="menu_button" onclick="myFunction(this)">
      <div id="bar1"></div>
      <div id="bar2"></div>
      <div id="bar3"></div>
  </div>
  <a id="HeaderName" href="/index.html" style="text-decoration: none;">Muchang Bahng</a>
</div>
  
  <div class="space" style="height:100px;"></div>
  <div class="information">
  
  <p class="title">Julia</p>
  <hr>
  
  <div class="toc">
    <div class="toctitle">Contents</div>
    <ol class="toclist">
      <li><a href="#Section1">Virtual Envs & FileSystem</a></li>
      <li><a href="#Section2">Basics</a></li>
      <li><a href="#Section3">Data Structures</a></li>
      <li><a href="#Section4">Functions</a></li>
      <li><a href="#Section5">Structs & Types</a></li>
      <li><a href="#Section6">Modules</a></li>
    </ol>
  </div>

We assume that the reader is familiar with an introductory level of programming, such as the following. Things may slightly differ depending on which language the reader is working with. 
<ul>
  <li>Identifying basic types (Int, Float, String, Boolean) and data structures (List, Tuple, Set, Array, Dictionary)</li>
  <li>Working with variables, conditionals, for/while loops, and functions</li>
  <li>Knowing the basics of classes and objects, with methods and attributes. </li>
</ul>

<div class="title_and_hide">
<p id="Section1" class="section_title">Julia: Virtual Environment Management</p>
<a id="show_hide_1" class="show_hide" onclick="show_hide_1()">[Hide]</a></div>
<hr>
<div id="section_content_1">

<div class="subsection_title">Different Modes in Julia REPL</div>
<div>
We go into the command line/terminal and type julia (or click on the execuatble) to activate the Julia command-line REPL (read-eval-print loop). There are 3 modes in this REPL that we are concerned with (out of 5): 
<ul>
  <li>
    The <b>Julian mode</b> is the default prompt, where we can enter Julia expressions. Each line starts with <code>julia></code>. 
    <pre>
    julia> println("Hello World") 
    Hello World
    </pre>
  </li>
  <li>
    By typing <code>?</code>, we go into <b>Help mode</b>. Julia will attempt to print help or documentation for anything entered in help mode. Each line starts with <code>help?></code>, and we can escape by pressing <code>BACKSPACE</code>. 
    <pre>
    julia> ? # upon typing ?, the prompt changes (in place) to: help?>

    help?> string
    search: string String Cstring Cwstring RevString randstring bytestring SubString

    string(xs...)

    Create a string from any values using the print function.
    </pre>
  </li>
  <li>
    By pressing <code>]</code>, we enter into Pkg (Package manager) mode, which accepts specialized commands for loading and updating packages. Each line starts with <code>pkg></code>, and we can escape by pressing <code>BACKSPACE</code>. We can see which environment you are currently in by looking at the prompt.
    <pre>
    (@v1.7) pkg>      # In default environment
    (@ACE_Env) pkg>   # In ACE_Env environment 
    </pre>
  </li>
</ul>
</div>

<div class="subsection_title">Package Mode Commands</div>
<div>
 Some commands: 
<ul>
  <li><b>Listing Environments</b>: Environments are by default stored in <code>.julia/environments</code> directory, which may contain a directory called, say <code>env1</code>. Every environment directory will contain a <code>Project.toml</code> and <code>Manifest.toml</code> file, which stores metadata on your project. The <code>Project.toml</code> files defines which packages are needed for the project and should not be manually edited. The environment name is the directory name. Unfortunately, these environment directories can be located elsewhere, so locating all of them is difficult. As for the ones in the <code>.julia/environments</code> directory, we can just write 
  <pre>
  pkg> activate @
  </pre>
  and press <code>tab</code>, which will list all available directories in <code>.julia/environments</code>. 
  </li>
  <li>
    <b>Activating Environments</b>: We type activate followed by the environment name. If we wish to activate the default environment, then we just type: 
    <pre>
    (BayesianMLIP) pkg> activate
    Activating project at `C:\Users\bahng\.julia\environments\v1.7`
    </pre>
    In general, if we wish to activate an environment, called say <code>MyEnv</code>, we must navigate into the directory containing <code>MyEnv</code>, enter into the Julia REPL from there, and then call 
    <pre>
    (@v1.7) pkg> activate MyEnv
    Activating project at `C:\Users\bahng\OneDrive\Documents\GitHub\MyEnv`
    </pre>
    If our environment happens to be in the <code>.jula\environments</code> directory, then we do not have to navigate into there and can just call it using the <code>@</code> symbol: 
    <pre>
    (@v1.7) pkg> activate @ACE_Env
    Activating project at `C:\Users\bahng\.julia\environments\ACE_Env`
    </pre>
    If no such environment exists, then Julia makes a new project in the current directory (or in <code>.julia\environments</code>): 
    <pre>
    (@v1.7) pkg> activate newEnv
    Activating new project at `C:\Users\bahng\newEnv`

    (@newEnv) pkg> activate @newEnv2
    Activating new project at `C:\Users\bahng\.julia\environments\newEnv`
    </pre>
  </li>
  <li>
    <b>Listing Packages</b>: Once you are in your desired environment, to list all packages, use the <code>status</code> keyword, which will look at the <code>Project.toml</code> file for the relevant information. It also displays the location of the environment directory. 
    <pre>
    (@v1.7) pkg> status
    Status `C:\Users\bahng\.julia\environments\v1.7\Project.toml`
    [336ed68f] CSV v0.10.4
    [49dc2e85] Calculus v0.5.1
    [a93c6f00] DataFrames v1.3.3
    [31c24e10] Distributions v0.25.55
    [7073ff75] IJulia v1.23.3
    [5ab0869b] KernelDensity v0.6.3
    [91a5bcdd] Plots v1.27.5
    [37e2e46d] LinearAlgebra
    </pre>
  </li>
  <li>
    <b>Adding/Deleting/Updating Packages</b>: We use the <code>add</code>, <code>rm</code>, and <code>update</code> keywords. 
    <pre>
    (@v1.7) pkg> add Example      #add package Example
    (@v1.7) pkg> rm Example       #remove package Example
    (@v1.7) pkg> update Example   #update package Example
    </pre>
    To update all packages, use <code>update</code> without arguments. We have only talked about <b>registered packages</b>. To add <b>unregistered packages</b>, specify a URL: 
    <pre>
    (@v1.7) pkg> add https://github.com/JuliaLang/Example.jl
    </pre>
  </li>
</ul>
</div>

<div class="subsection_title">Modules: Import, Using, and Export</div>
<div>
A module in Julia are delimited inside the <code>module ... end</code>, containing <b>names</b> which refer to functions, types, global variables, and constants. The information is based off of the Modules sections in the Julia documentation. Let us have a module called <code>NiceStuff</code> with the following information: 
<pre>
module NiceStuff

export nice, DOG

struct Dog end      # singleton type, not exported

const DOG = Dog()   # named instance, exported

nice(x) = "nice $x" # function, exported

end
</pre>
<ul>
  <li><code>Import NiceStuff</code> loads the module <code>NiceStuff</code>. Names from the module can be accessed with <code>NiceStuff.name</code> syntax, and in this case, <code>NiceStuff.Dog</code>, <code>NiceStuff.DOG</code>, and <code>NiceStuff.nice</code> can be used. </li>
  <li><code>Using NiceStuff</code> loads the module and makes the exported names available for direct use. In this case, after we have written <code>Using NiceStuff</code>, we can write <code>nice</code> and <code>DOG</code> without the module name, but we can still refer to the struct as <code>NiceStuff.Dog</code>. </li> 
  <li><code>Export</code>: Name that are exported are available for direct use when calling the <code>Using NiceStuff</code>. That is, the only use for the <code>export</code> keyword is if we are going to write <code>using NiceStuff</code> later. </li>
</ul>
We can also import specific functions of a module using a colon. For example, 
<pre>
using NiceStuff: nice, DOG 
</pre>
</div>

</div>

<div class="title_and_hide">
<p id="Section2" class="section_title">Julia Coding</p>
<a id="show_hide_2" class="show_hide" onclick="show_hide_2()">[Hide]</a></div>
<hr>
<div id="section_content_2">

<div class="subsection_title">Structs</div>
The most commonly used kind of type is <code>struct</code>, specified as a name and a set of fields. We can think of this as analogous to a class in Python, with attributes. 
<pre>
struct Point 
    x
    y
end
</pre>
Fields may have type restrictions and a struct can also declare an abstract super type via the <code>&lt;:</code> syntax: 
<pre>
struct Point &lt;: AbstractPoint      # A subtype of type AbstractPoint
    x::Integer                        # Field must be of type Integer
    y::Float64                        # Field must be of type Float64
end
</pre>
Structs are immutable by default, so an instance of one of these types cannot be modified after constructiof. For mutable structs we can use the <code>mutable struct</code> keyword. 

<div class="subsection_title">Types</div>
<div>
We describe some commands to navigate the type hierarchy of of Julia. We can think of it as analogous to the class hierarchy in Python. To determine all supertypes (parent types), use the <code>supertype()</code> function. 
<pre>
julia> supertype(Number)
Any
</pre>
To determine the direct children, use the <code>subtypes()</code> function. 
<pre>
julia> subtypes(Number)
2-element Vector{Any}:
 Complex
 Real
</pre>
We describe the hierarchy: 
<ol>
  <li>At the top of the hierarchy is the <code>Any</code> type. Every object is an instance of <code>Any</code>. As of May 2022, it has 531 subtypes. </li> 
  <li>The <code>Number</code> type is an abstract type. Let us examine its hierarchy: 
  <pre>
  julia> subtypes(Number)
  2-element Vector{Any}:
    Complex
    Real
  julia> subtypes(Real)
  4-element Vector{Any}:
    AbstractFloat
    AbstractIrrational
    Integer
    Rational
  subtypes(AbstractFloat)
  4-element Vector{Any}:
    BigFloat
    Float16
    Float32
    Float64
  </pre>
  and so on. A nice visual. 
  <img src="/CSS/Pictures/Julia-number-type-hierarchy.svg.png" width="90%"> 
</li>
  <li>At the bottom of the hierarchy is the abstract "bottom" type, which is written as <code>Union{}</code>. No object is an instance of <code>Union{}</code>, and all types are supertypes of <code>Union{}</code>. </li>
</ol>

Abstract types are declared using the <code>abstract type</code> keyword, with the general syntax being: 
<pre>
abstract type «name» end
abstract type «name» &lt;: «supertype» end
</pre>
This introduces a new abstract type whose name is given by <code>«name»</code>. This name can be optionally followed by <code>&lt;:</code> and an already existing type, indicating that the newly declared abstract type is a subtype of this parent type. The <code>&lt;:</code> operator generally means "is a subtype of." 
<br><br>
A <b>primitive type</b> is a type whose data consists only of a series of bits, and for now we can interpret them as just "simple" types. A <b>composite type</b> are referred to as structs or objects, introduced with the <code>struct</code> keyword. An instance of composite types can be created by applying the type object like a function to values for its fields, which will create an object of that type. 
<pre>
julia> struct Foo
           bar
           baz::Int
           qux::Float64
       end

julia> fooObj = Foo("Hello World", 23, 1.5)
Foo("Hello World", 23, 1.5)

julia> typeof(fooObj)
Foo
</pre>
The field names of the type can be found using the <code>fieldnames</code> function (similar to class method), and we can access the field values using dot syntax (similar to object attributes). 
<pre>
julia> fieldnames(Foo)
(:bar, :baz, :qux)

julia> fieldnames(typeof(fooObj))   # Fieldnames of an object
(:bar, :baz, :qux)

julia> fooObj.bar
"Hello World"

julia> fooObj.baz
23

julia> fooObj.qux
1.5
</pre>

We can also declare <b>type unions</b>, which can be thought of as unions of types. They are special abstract types which includes as objects all instances of any of its argument types, constructed using the <code>Union</code> keyword. 
<pre>
julia> IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64
</pre>
A useful case is <code>Union{T, Nothing}</code>, where <code>T</code> can be of any type and <code>Nothing</code> is the singleton type whose only instance is the object <code>nothing</code>. 
<br><br>
A <b>parametric type</b> is a type with parameters introduced immediately after the type name, surrounded by curly braces. For example, 
<pre>
julia> struct Point{T}
           x::T
           y::T
       end
</pre>
defines a new parametric type, <code>Point{T}</code>, holding two "coordinates" <code>x</code>, <code>y</code> of type <code>T</code>. The point here is that <code>T</code> can be any type at all, and so <code>Point{T}</code> really describes objects that are two-tuples of the same type. <code>Point{T}</code> declares an unlimited number of types: <code>Point{Float64}</code>, <code>Point{AbstractString}</code>, <code>Point{Int64}</code>, all subtypes of the <code>Point</code> type (which is also a valid type object). 
<br><br>
The <code>where</code> keyword creates a type that is an iterated union of other types, over all values of some variable. For example, <code>Vector{T} where T&lt;:Real</code> includes all <code>Vector</code>s where the element type is some kind of Real number. 
<pre>
Vector{T} where T             # short for `where T&lt;:Any`
Vector{T} where T>:Int        # Variables can have lower bounds
Vector{T} where Int&lt;:T&lt;:Real
</pre>
</div>


<div class="subsection_title">Methods</div>


</div>
<script src="/JS/html_notes.js"></script>
</body>
</html>
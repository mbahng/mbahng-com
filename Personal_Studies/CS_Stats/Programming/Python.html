<!DOCTYPE html>
<html lang="en">
<head>
  <title>Muchang Bahng | Duke Math</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/CSS/Pictures/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/CSS/Pictures/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/CSS/Pictures/favicon.ico">
  <link rel="stylesheet" href="/CSS/Header_Footer.css">
  <link rel="stylesheet" href="/CSS/html_notes.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    pre {
      background-color: rgb(213, 212, 212);
      overflow-x: visible
    }
  </style>
</head>

<body>
<div class="header">
  <div id="menu_button" onclick="myFunction(this)">
      <div id="bar1"></div>
      <div id="bar2"></div>
      <div id="bar3"></div>
  </div>
  <a id="HeaderName" href="/index.html" style="text-decoration: none;">Muchang Bahng</a>
</div>
  
  <div class="space" style="height:100px;"></div>
  <div class="information">
  
  <p class="title">Python3</p>
  <hr>
  
  <div class="toc">
    <div class="toctitle">Contents</div>
    <ol class="toclist">
      <li><a href="#Section1">Virtual Envs & FileSystem</a></li>
      <li><a href="#Section2">Basic Topics</a></li>
      <li><a href="#Section3">Intermediate Topics</a></li>
      <li><a href="#Section4">Object Oriented Programming</a></li>
      <li><a href="#Section5">DateTime Package</a></li>
      <li><a href="#Section6">Numpy Package</a></li>
      <li><a href="#Section7">Pandas Package</a></li>
    </ol>
  </div>


<div class="title_and_hide">
<p id="Section1" class="section_title">Virtual Environments & FileSystem</p>
<a id="show_hide_1" class="show_hide" onclick="show_hide_1()">[Hide]</a></div>
<hr>
<div id="section_content_1">
Remember that an environment really contains three things: 
<ul>
  <li>A <code>Lib\site-packages</code> directory that contains all the packages needed for the project. 
    <ul>
      <li>A <b>module</b> is a bunch of code in a file with the extension <code>.py</code>, in which there may be functions, classes, or variables defined. </li>
      <li>A <b>package</b> is a directory of a collection of modules (i.e. the folder that contains all modules). </li>
      <li>A <b>library</b> is an umbrella term referring to a reusable chunk of code, containing a collection of related modules and packages. It is sometimes used interchangeable with packages. </li>
    </ul>
  </li>
  <li>A scripts directory that contains various executables that will run your scripts with the help of packages imported. 
  <ul>
    <li>python.exe</li>
    <li>activate.bat</li>
    <li>pip.exe</li>
    <li>wheel.exe</li>
  </ul> </li>
  <li>Whatever scripts you have written as a part of your program.</li>
</ul>
Note that the scripts you have written as a part of your program is <i>not</i> within the virtual environment folder; it only contains the executable scripts and packages. Usually, the scripts would be contained one step above in the file tree of the virtual environment all within a bigger project folder. 
<br><br>
We must also distinguish two types of environments. 
<ul>
  <li>A <b>base environment</b>, which handles Python scripts on your entire system. The path for this environment is similar for most systems, but mine is <code>C:\Users\bahng\AppData\Local\Programs\Python\Python39</code>. 
  Note that the Python directory contains the scripts, while the Python39 directory is technically known as the environment. </li>
  <li>Multiple <b>virtual environments</b>, which are isolated environments designed for specific projects. The key benefit of virtual environments is that they isolate each of your projects from any other installation of Python on your computer, allowing multiple versions of Python to coexist without stepping on each other. However, they can be decenetralized, making it hard to manage and requiring activation/deactivation in a terminal-basis. Some of my own virtual environments are listed in different directories, but <code>venv</code> folder has the path: <code>C:\Users\bahng\PycharmProjects\HW_Problem_Generator\venv</code>. </li>
</ul>
Thankfully, there are multiple package managers that allows us to organize our environments. In addition to the information below, this <a href="https://www.section.io/engineering-education/introduction-to-virtual-environments-and-dependency-managers/" target="BLANK">link</a> is also a great tutorial. It is conventional to use venv somewhere in the environment name, and it is easily available in ignore files like .gitignore. 
<br><br>
Some common virtual environment management programs. 
<ul>
  <li><b>Venv</b> is the default virtual environment module for Python 3 and one of the easiest modules for creating virtual environments. It comes pre-installed in Python3 or newer. 
    <table>
      <tr>
        <th>Windows CMD</th> 
        <th>MacOS Terminal</th>
        <th>Task</th> 
      </tr>
      <tr>
        <td>python -m venv &lt;path_to_venv_directory/NAME&gt;</td>
        <td></td>
        <td>Creates a new virtual environment directory named NAME in current directory by default or in path_to_venv_directory specified. </td>
      </tr>
      <tr>
        <td>activate.bat</td>
        <td></td>
        <td>Activates the virtual environment. Remember to be in the scripts directory in order to run the executable. </td>
      </tr>
      <tr>
        <td>deactivate.bat</td>
        <td></td>
        <td>Deactivates the virtual environment. Remember to be in the scripts directory in order to run the executable. </td>
      </tr>
    </table>
    Note that one you have activated the virtual environment, the environment name should pop up in parantheses in your shell as such. 
    <pre class="terminal">
C:\User\bahng>python -m venv testvenv
C:\User\bahng>cd testvenv\Scripts
C:\Users\bahng\testvenv\Scripts>activate.bat
(venv) C:\Users\bahng\venv\Scripts> _
    </pre>
    Remember that virtual environments are just directories that contain a library of site-packages and a collection of executables. They can be installed anywhere on your computer, even in directories that have nothing to do with Python scripts. </li>
    <li><b>Virtualenv</b> is a third-party dependency manager used for creating and managing Python projects, but used mainly for Python 2 so we will not elaborate here. Note that virtual environments do not come as a native feature for Python 2. </li>
    <li><b>Conda</b> is another package manager that specializes in data science. You can download it by installing Anaconda or Miniconda (a mini-version of Anaconda that contains only Conda and its dependencies). Again, for ease of use, make sure you add conda to the PATH variable. Note that when you install conda, a directory called anaconda3 is made which contains a <i>new</i> base environment and additional virtual environment directories. Listing all the environments I have returns
<pre class="terminal">
C:\Users\bahng>conda env list
# conda environments:
#
base                     C:\Users\bahng\anaconda3
testenv               *  C:\Users\bahng\anaconda3\envs\testenv
</pre>
      The asterick just means that I am currently in (i.e. have activated) the testenv environment. 
      </p>
      <table>
        <tr>
          <th>Windows CMD</th> 
          <th>MacOS Terminal</th>
          <th>Task</th> 
        </tr>
        <tr>
          <td colspan=2>conda info</td>
          <td>Outputs information on conda</td>
        </tr>
        <tr>
          <td colspan=2>conda -V</td>
          <td>Outputs version of conda</td>
        </tr>
        <tr>
          <td colspan=2>conda update conda</td>
          <td>Updates conda</td>
        </tr>
        <tr>
          <td colspan=2>conda install (update) PACKAGE</td>
          <td>Install (update) PACKAGE with conda</td>
        </tr>
        <tr>
          <td colspan=2>conda create --name NAME</td>
          <td>Create a virtual environment called NAME. Note that regardless of which directory you are in, conda will create all virtual environments in anaconda3\envs. </td>
        </tr>
        <tr>
          <td colspan=2>conda activate (deactivate) ENV</td>
          <td>Activate (deactivate) the environment named ENV</td>
        </tr>
        <tr>
          <td colspan=2>conda env list</td>
          <td>Get a list of all conda environments, active environment shown with asterick. </td>
        </tr>
        <tr>
          <td colspan=2>conda create --clone ENV --name ENV2</td>
          <td>Clones an environment</td>
        </tr>
        <tr>
          <td colspan=2>conda list</td>
          <td>List all packages & versions installed in active environment</td>
        </tr>
        <tr>
          <td colspan=2>conda env remove --name ENV</td>
          <td>Delete an environment and everyhing in it</td>
        </tr>
        <tr>
          <td colspan=2>conda install --name ENV2 PKG</td>
          <td>Install new package PKG in a different environment ENV2</td>
        </tr>
        <tr>
          <td colspan=2>conda remove --name ENV PKG1 PKG2</td>
          <td>Remove one or more packages from environment ENV</td>
        </tr>
      </table>
      A conda <a href="https://docs.conda.io/projects/conda/en/4.6.0/_downloads/52a95608c49671267e40c689e0bc00ca/conda-cheatsheet.pdf" target=BLANK>cheatsheet</a>. </li>
  <li><b>Pip</b> is a package manager used to install, uninstall, and organize different Python packages on your computer. First  
    <table>
      <tr>
        <th>Windows CMD</th> 
        <th>MacOS Terminal</th>
        <th>Task</th> 
      </tr>
      <tr>
        <td>pip install (uninstall) PKG</td>
        <td></td>
        <td>Install (uninstall) a package directly from PyPI into the current active environment using pip. However, this may not install all the dependencies of the package, so the command below is recommended. </td>
      </tr>
      <tr>
        <td>python -m pip install (uninstall) PKG</td>
        <td></td>
        <td>Installs a package and all of its dependencies. The uninstall command does not uninstall the dependencies however. </td>
      </tr>
      <tr>
        <td>python -m pip install PKG --upgrade</td>
        <td></td>
        <td>Upgrades package to its latest version</td>
      </tr>
      <tr>
        <td>python -m pip install --upgrade pip</td>
        <td></td>
        <td>Update pip to its latest version </td>
      </tr>
      <tr>
        <td>python -m pip list</td>
        <td></td>
        <td>List all packages & versions installed in active environment</td>
      </tr>
      <tr>
        <td>pip show PKG</td>
        <td></td>
        <td>Shows information about package PKG</td>
      </tr>
      <tr>
        <td>python -m pip search PKG</td>
        <td></td>
        <td>Searches for the PKG package. </td>
      </tr>
      <tr>
        <td>pip --help</td>
        <td></td>
        <td>Returns the full list of pip options. </td>
      </tr>
    </table></li>
</ul>

A final reminder that each instance of python, pip, and all the other packages installed is only updated <i>within its environment</i>! Updating, pip (for instance) in the base environment will not update pip in any one of the virtual environments. 
</div>

<div class="title_and_hide">
<p id="Section2" class="section_title">Basic Topics</p>
<a id="show_hide_2" class="show_hide" onclick="show_hide_2()">[Hide]</a></div>
<hr>
<div id="section_content_2">

<div class="subsection_title">String Interpolation</div>
There are three main ways to do string interpolation, listed from the best method to the worst method. 
<ul>
  <li>F-strings. 
    <pre>
      you = "Muchang" 
      me = "Brian"
      print(f"Hello {you}, I am {me}.")
    </pre>
  </li>
  <li>Using <code>str.format()</code>
    <pre>
      you = "Muchang"
      me = "Brian" 
      print("Hello {}, I am {}.".format(you, me))
    </pre>
  </li>
  <li>
    Using <code>%</code>, but this is not recommended due to decreased readability. 
    <pre>
      you = "Muchang" 
      me = "Brian" 
      print("Hello %s, I am %s."%(you, me))
    </pre>
  </li>
</ul>


<div class="subsection_title">Data Structures: Lists, Tuples, Sets, Dictionaries</div>
We list some basic data structures. 
<ol>
  <li>
    <b>Lists</b> are dynamic-sized arrays. Should be quite familiar with them. 
    <pre>
      >>> x = [1, 2.3, "Hello"]   # x = list([1, 2.3, "Hello"])
      >>> x[1]
      2.3
      >>> x[0]
      1
      >>> x[2]
      'Hello'
    </pre>
  </li>
  <li>
    <b>Tuples</b> is similar to a list in terms of indexing, nested objects, and repetition, but a tuple is immutable. 
    <pre>
      >>> tup = (1, 2.3, "Hello")     # tup = tuple((1, 2.3, "Hello"))
      >>> tup[1]
      2.3
      >>> tup[1] = 3.4
      Traceback (most recent call last):
        File "&lt;stdin>", line 1, in &lt;module>
      TypeError: 'tuple' object does not support item assignment
    </pre>
  </li>
  <li>
    A <b>set</b> is an unordered (not able to be indexed) collection data type that is iterable, mutable, and has no duplicate elements. This represents the mathematical notation of a set. 
    <pre>
      >>> set = {1, 2, 3}
    </pre>
  </li>
  <li>
    A <b>dictionary</b> is an ordered (since Python3.7) collection of data values, used to staore data values in key-value pairs. 
    <pre>
      >>> dict = {1:"Hello", "World": 2}
      >>> dict[1]
      'Hello'
      >>> dict["World"]
      2
    </pre>
  </li>
</ol>

<div class="subsection_title">Functions: Regular & Anonymous Functions</div>

<div class="subsection_title">Classes & Objects</div>

<div class="subsection_title">Scope: Local and Global Variables</div>


</div>

<div class="title_and_hide">
<p id="Section3" class="section_title">Intermediate Topics</p>
<a id="show_hide_3" class="show_hide" onclick="show_hide_3()">[Hide]</a></div>
<hr>
<div id="section_content_3">

<div class="subsection_title">References</div>

<div class="subsection_title">Regular Expressions</div>

<div class="subsection_title">API Calls: Requests, Asyncio</div>

</div>

<div class="title_and_hide">
<p id="Section4" class="section_title">Object Oriented Programming</p>
<a id="show_hide_4" class="show_hide" onclick="show_hide_4()">[Hide]</a></div>
<hr>
<div id="section_content_4">

Recall that a class is basically a blueprint that is used to generate objects, also known as <i>class instantiation</i>. It contains <i>attributes</i> (variables of the object) and <i>methods</i> (functions of the object). Finally, the <i>constructor</i>, i.e. the <code>__init__()</code> method, is always called when an object is created. The constructor initializes (assign values) to the data members of the class when an object of this class is created. 

Finally, note the difference between the <i>object attributes/methods</i> and <i>class attributes/methods</i>. 
<ul>
  <li>The <code>self</code> keyword refers to the instantiated object itself, and so object attributes/methods, which are variables/functions associated with the <i>instantiated object</i>, will be called using the object name, in format <code>{object_name}.{attribute_method_name}</code>. </li>
  <li><i>Class attributes/methods</i> refers to the class itself, and so they will be called using the class name, in format <code>{class_name}.{attribute_method_name}</code>. They do not refer to an object, so we can call class attributes and methods without even instantiating any objects. </li>
</ul>

<pre>
class Person(): 

    is_mammal = True                                  #Class attribute

    def awk_silence():                                #Class method
        print("An awkward silence...")

    def __init__(self, first_name, last_name):        #Constructor function
        self.first_name = first_name                  #Initialize object attribute
        self.last_name = last_name                    #Initialize object attribute
        self.full_name = f"{first_name} {last_name}"  #Initialize object attribute

    def talk(self, dialogue):                         #Object method
        print(f"{self.first_name} says: {dialogue}")

charA = Person("Muchang", "Bahng")                    #Instantiate object charA of class Person
charB = Person("Sean", "Park")                        #Instantiate object charB of class Person

print(charA.full_name)                                #Print object attribute 'full_name' of charA
print(charB.full_name)                                #Print object attribute 'full_name' of charB

charA.talk("How's it going?")                         #Call object method 'talk' of charA
charB.talk("I'm depressed man...")                    #Call object method 'talk' of charB
Person.awk_silence()                                  #Call class method 'awk_silence'
charA.talk("I'm sorry to hear that. ")                #Call object method 'talk' of charA

print(Person.is_mammal)                               #Print class attribute 'is_mammal'
</pre>

There is an extreme variety of ways we can work with classes and objects. Any time we are working with a bunch of things of the same kind, we can use classes. Examples include 
<ol>
  <li>simulating particles bumping into each other within a box, with class <code>Particles</code> (with object attributes: <code>position</code>, <code>velocity</code>, <code>mass</code>, <code>radius</code> and class methods: <code>bump</code> and <code>reflect_wall</code>) and perhaps 100 objects representing 100 different particles. If the particles are all of the same type, we may set <code>mass</code> and <code>radius</code> as class attributes. </li>
  <li>an interactive game with 15 players. We can create a <code>Player</code> class with object attributes: <code>position</code>, <code>weight</code>, <code>height</code>, <code>shirt_color</code>, <code>pants_color</code>, <code>shoe_color</code>, class methods: <code>walk</code>, <code>run</code>, and object methods: <code>talk</code>. </li>
</ol>

<div class="subsection_title">Class Inheritance and Abstract Classes</div>

We can make subclasses (known as a <i>child class</i> or a <i>derived class</i>) from a <i>parent class</i>. All the attributes and methods of the parent class is shared within the child class, so we are able to call the parent attributes/methods without explicitly stating them in the child class body. One important thing to note: If the same method (e.g. <code>__init__</code>) is defined in both the parent and child class, then the method in the child class overrides that in the base class, completely replacing it. Generally, when overriding a base method, we want to extend the definition rather than simply replace it. 

<pre>
class Student(Person):                                  #Student is subclass of Person

    in_college = True

    def __init__(self, first_name, last_name, school, major, intelligence):    
      #Define constructor, which adds new attributes
        self.school = school                            #Additional object attributes of Student subclass
        self.major = major                              #Additional object attributes of Student subclass
        self.intelligence = intelligence                #Additional object attributes of Student subclass
      
      #Invoke the __init__ of the parent class 
        Person.__init__(self, first_name, last_name)    #Creates Person object, w/ parent attributes & methods

    def study(self):                                    #Object method of Student object                             
        print(f"{self.full_name} is studying {self.major} at {self.school}...")
        self.intelligence += 1
    
    def curfew():                                       #Class method of student object 
        print("Everyone returns to their dorms. ")
</pre>

We can see that a child object shares the attributes initialized from its parent class. 

<pre>
StudA = Student("Muchang", "Bahng", "Duke", "Math", 1)

print(StudA.first_name)     # Muchang
print(StudA.last_name)      # Bahng
print(StudA.full_name)      # Muchang Bahng
print(StudA.school)         # Duke
print(StudA.major)          # Math
print(StudA.intelligence)   # 1
</pre>

The parent class attributes and methods can be called using either the parent class or the child class. Remember, class attributes and methods do not even require any object to be instantiated. However, the child class attributes and methods cannot be called 
<pre>
#Calling parent class attribute
print(Person.is_mammal)   #True
print(Student.is_mammal)  #True

#Calling parent class method
Person.awk_silence()      # An awkward silence...
Student.awk_silence()     # An awkward silence...

#Calling child class attribute
print(Student.in_college) # True
print(Person.in_college)  # Error, type object 'Person' has no attribute 'in_college'

#Calling child class method 
Student.curfew()          #Everyone returns to their dorms. 
Person.curfew()           #Error, type object 'Person' has no attribute 'curfew'
</pre>

We can create a hierarchy of classes with inheritance, which leads us to the concept of <b>abstract classes</b>. Abstract classes are classes but they cannot be instantiated. Rather, we must create subclasses from them and should instantiate these ones. The purpose of abstract classes is to define how other classes should look like, i.e. what methods and properties they are expected to have. They attributes and methods defined (but not implemented) in an abstract class are called <b>abstract attributes</b> and <b>abstract methods</b>. Say that in a human role-playing game, we have the <code>Human</code> class (with relevant attributes and methods), with two subclasses <code>male</code> and <code>female</code> representing sex. We can interpret the <code>Human</code> class as an abstract class since every human is either a male or female, so to create a character must mean that we should instantiate from the <code>male</code> or <code>female</code> class. We can create an abstract class by inheriting from the <code>ABC</code> class which is part of the <code>abc</code> module. 

<pre>
from abc import ABC, abstractmethod 

class Human(ABC):               # Human is subclass of ABC --> it is an abstract class 
    def __init__(self, name):   # Constructor 
        self.name = name        # Abstract attribute
        self.level = 1          # Abstract attribute 

    
    @abstractmethod             # Decorator which indicates abstract method
    def walk(self):             # Abstract object method
        ... 

Player1 = Human("Muchang")      # Error
</pre>

We create the abstract class <code>Human</code> (by letting it be a subclass of ABC). We indicate that the method <code>walk</code> is an abstract method by using the <b>decorator</b> <code>@abstractmethod</code>, which means we expect this method to be implemented in every subclass of <code>Human</code>. Trying to create an object from <code>Human</code> directly results in a <code>TypeError</code>. 


<div class="subsection_title">Everything is an Object (Python Class Hierarchy)</div>
In object-oriented programming languages like Python, an <b>object</b> is an entity that contains data along with associated metadata and/or functionality. In Python, everything is an object, which means every (and yes, every) entity has some metadata (called attributes) and associated functionality (called methods). These attributes and methods are accessed via the dot syntax. 
Since Python is an object oriented programming language, everything is a class or objects of a class. We can interpret the types that we've learned in Python as classes themselves. 
<br><br>
In order to check the metadata and functionality of an object (i.e. what attributes and methods can I call on this object), then we can use the help keyword: 

<pre>
>>> x = 4
>>> help(x)
Help on int object:

class int(object)
 |  int([x]) -> integer
 |  int(x, base=10) -> integer
 |
 |  Convert a number or string to an integer, or return 0 if no arguments
 |  are given.  If x is a number, return x.__int__().  For floating point
 |  numbers, this truncates towards zero.
 |
 |  If x is not a number or if base is given, then x must be a string,
 |  bytes, or bytearray instance representing an integer literal in the
 |  given base.  The literal can be preceded by '+' or '-' and be surrounded
 |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |  Base 0 means to interpret the base from the string as an integer literal.
 |  >>> int('0b100', base=0)
 |  4
 |
 |  Built-in subclasses:
 |      bool
 |
 |  Methods defined here:
 |
 |  __abs__(self, /)
 |      abs(self)
 |
 |  __add__(self, value, /)
 |      Return self+value.
 |
 |  __and__(self, value, /)
 |      Return self&value.
 |
 |  __bool__(self, /)
 |      True if self else False
 |
 |  __ceil__(...)
 |      Ceiling of an Integral returns itself.
 |
 |  __divmod__(self, value, /)
 |      Return divmod(self, value).
 |
 |  __eq__(self, value, /)
 |      Return self==value.
 |
 |  __float__(self, /)
 |      float(self)
</pre>

Since we said that everything is an object, it is not too unreasonable to guess some sort of hierarchy of classes built into Python. This is indeed the case, and at the very top of the class hierarchy is the <code>object</code> class. It is meant to be an abstract class, so everything is an instantiation of a subclass of <code>object</code>. As of May 2022, the <code>object</code> class has about 150 subclasses, including <code>int</code>, <code>float</code>, etc.). 

We introduce further commands to navigate the hierarchy and structure of classes. 
<ul>
  <li>
    To find all subclasses of a class, use the <i>class</i> method (not object method) <code>__subclasses__()</code>. 
    <pre>
    >>> int.__subclasses__()
    [&lt;class 'bool'>, &lt;enum 'IntEnum'>, &lt;enum 'IntFlag'>, &lt;class 'sre_constants._NamedIntConstant'>, 
    &lt;class 'subprocess.Handle'>]
    </pre>
  </li>
  <li>
    To find the direct parent class(es) of a class, we use the class attribute <code>__bases__</code>
    <pre>
    class A(object):        #Create class 'A' (subclass of 'object class'
        pass 
    
    class B(object):        #Create class 'A' (subclass of 'object class'
        pass 
    
    class C(A, B):          #Create class 'A' (subclass of 'A', 'B') 
        pass 
    
    print(C.__bases__)      #(&ltclass '__main__.A'>, &ltclass '__main__.B'>)
    </pre>
  </li>
  <li>
    If you want all the ancestors (in order) rather than the immediate ones, use the <code>__mro__</code> class attribute. 
    <pre>
    >>> str.__mro__ 
    (&lt;class 'str'>, &lt;class 'object'>)
    </pre>
  </li>
  <li>
    To get the list of all the class attributes and class methods of a class, we can use the built-in function <code>dir(class_name)</code>. To get a list of all the object attributes and object methods of an object, we can also use the built-in function <code>dir(object_name)</code>. Using the <code>Person</code> and <code>Student</code> classes defined above, we show: 
    <pre>
    >>> x = Student("Muchang", "Bahng", "Duke", "Math", 1)
    >>> dir(x)
    ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
    '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
    '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', 
    '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 
    'awk_silence', 'curfew', 'first_name', 'full_name', 'in_college', 'intelligence', 
    'is_mammal', 'last_name', 'major', 'school', 'study', 'talk']
    </pre>
    Notice that all the functions in the double underscores were not explicitly constructed when we defined our <code>Person</code> and <code>Student</code> classes, but rather inherited from the <code>object</code> class. We can see below that the parent class of <code>Person</code> is <code>object</code>, which does indeed contain the identified attributes/methods. 
    <pre>
    print(Student.__base__)       # &lt;class '__main__.Person'>
    print(Person.__base__)        # &lt;class 'object'>
    print(dir(object))
    # ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
    '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', 
    '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
    '__sizeof__', '__str__', '__subclasshook__']
    </pre>
  </li>
</ul>

<div class="subsection_title">Built-In Functions/Operators and Dunder Methods</div>
We first should clarify the distinction between functions and expression operators in Python. In general, they are both a map (in the mathematical sense) and are just represented differently. 
<ul>
  <li>A function is a map that is of form <code>function(args)</code>. There are built-in functions (e.g. <code>len()</code> or <code>abs()</code>) or we can explicitly define them. Either way, letting $\texttt{CLS}$ be the set of all objects of class $\texttt{CLS}$, we can say that the functions above are (by default) maps with the following domain and codomains:  
  \begin{align*}
    \texttt{len()}: & \texttt{STR} \cup \texttt{LIST} \cup \ldots \cup \texttt{DICTIONARY} \longrightarrow \texttt{INT} \\
    \texttt{abs()}: & \texttt{INT} \cup \texttt{FLOAT} \longrightarrow \texttt{INT} \cup \texttt{FLOAT} 
  \end{align*}
  </li>
  <li>
    An operator is also considered a map, but the only difference is syntax. They are represented with <i>symbols</i>, such as <code>+</code> in <code>2 + 3</code>, <code>&lt;</code> in <code>1 &lt; 5</code>, and <code>[]</code> in <code>string.[i]</code>. Again, we can interpret them as mathematical maps with the following domain and codomains, where $\texttt{CLS}^2 = \texttt{CLS} \times \texttt{CLS}$: 
    \begin{align*} 
      \texttt{+} & : \texttt{INT}^2 \cup \texttt{STR}^2 \cup \texttt{LIST}^2 \longrightarrow \texttt{INT} \cup \texttt{STR} \cup \texttt{LIST} \\
      \texttt{&lt;} & : \texttt{INT}^2 \cup \texttt{FLOAT}^2 \longrightarrow \texttt{BOOL} \\
      \texttt{[]} & : ( \texttt{STR} \cup \texttt{LIST} ) \cup \texttt{INT} \longrightarrow \texttt{OBJECT} 
    \end{align*}
  </li>
</ul>
Another difference is that the set of all syntactic operators is fixed and new ones cannot be added by your Python code. You can't write your own code to define a new operator called <code>$</code> and then have <code>x $ y</code> work. On the other hand, you can define as many methods as you want. Fundamentally though, there really is no difference between functions and operators.
<br><br>
The Python interpreter has a number of built-in functions and operators that are always available (which can be easily googled). When we call these functions/operators, what really happens in the background is that they are just shortcuts that invokes a specific object method of whatever argument we are working with. Here are some examples: 
<ul>
  <li>
    The <code>abs</code> function accepts an integer, a float, or any argument with an <code>__abs__()</code> method. It invokes the <code>__abs__()</code> method of its object argument, which, by default for int and float, returns the absolute value of a number. 
    <pre>
    >>> x = 4 
    >>> y = -2.41
    >>> abs(x)
    4 
    >>> x.__abs__()
    4
    >>> abs(y)
    2.41
    >>> y.__abs__() 
    2.41
    </pre>
    Note that we can create a custom class with a custom <code>__abs__()</code> method. 
    <pre>
    class testClass(): 
    
        def __init__(self, arg1): 
            self.arg1 = arg1 
        
        def __abs__(self): 
            return f"Hello, I am {self.arg1}"
  
    x = testClass("Muchang")
    print(x.__abs__())              # Hello, I am Muchang
    print(abs(x))                   # Hello, I am Muchang
    </pre>
    As you can see, calling the <code>__abs__</code> method directly using the dot syntax and calling the <code>abs</code> function returns the same output. 
  </li>
  <li>
    The <code>len</code> function accepts a sequence (e.g. string, bytes, tuple, list, range), a collection (e.g. dictionary, set), or any argument with a <code>__len__()</code> method. It invokes, the <code>__len__()</code> method of its object argument, which, by default for the mentioned types, returns the length (the number of items) of an object. 
    <pre>
    >>> x = "Hello World"
    >>> y = [1, 3, 4, "hi", "hello"]
    >>> len(x)
    11
    >>> x.__len__()
    11
    >>> len(y)
    5
    >>> y.__len__()
    5
    </pre>
    Note that we can create a custom class with a custom <code>__len__()</code> method. 
    <pre>
    class testClass(): 
    
        def __init__(self, arg1): 
            self.arg1 = arg1 
        
        def __len__(self): 
            return 34

    x = testClass("Muchang")
    print(len(x))               # 34
    print(x.__len__())          # 34
    </pre>
    For some reason, it throws an error when <code>__len__()</code> returns a non-integer type, so we can't just copy and paste the previous example code (which is why we replaced the string with the integer <code>34</code>). However, the logic is the same. 
  </li>
  <li>
    The <code>+</code> operator can accept 2 integers, 2 strings, 2 lists, or any first argument with a <code>__add__(other)</code> method followed by an arbitrary second argument that is compatible with the definition of the method. It invokes, the <code>__add__(other)</code> method of its object argument. 
    <pre>
    >>> x = 2
    >>> y = 9
    >>> x + y         
    11 
    >>> x.__add__(y)  #Object method of 'x' with argument 'y'
    11 
    >> y + x 
    11 
    >> y.__add__(x)   #Object method of 'y' with argument 'x'
    11 
    </pre>
    Note that <code>x + y</code> calls <code>x.__add__(y)</code> and <code>y + x</code> calls <code>y.__add__(x)</code>. So, <code>x + y</code> is fundamentally different from <code>y + x</code> and equality is achieved due to commutativity of the <code>__add__()</code> operator. If we were to modify the <code>__add__()</code> method, then commutativity may not be achieved. 
  </li>
  <li>
    The indexing expression operator <code>[]</code> accepts some sequence (or any object having the <code>__getitem__(i)</code> method), and it calls the <code>__getitem__(i)</code>, where <code>i</code> is an integer. Let us implement this into the <code>Student</code> class. We will add an (object) attribute called <code>courses</code> which will be a list, and add the <code>__getitem__(i)</code> so that we can index the object directly. 
    <pre>
    class Student(Person): 

        in_college = True    

        def __init__(self, first_name, last_name, school, major, intelligence, courses):    
            self.school = school
            self.major = major 
            self.intelligence = intelligence
            self.courses = courses
            Person.__init__(self, first_name, last_name)

        def study(self):                         
            print(f"{self.full_name} is studying {self.major} at {self.school}...")
            self.intelligence += 1
        
        def curfew(): 
            print("Everyone returns to their dorms. ")

        def __getitem__(i): 
            return self.courses[i]

    x = Student("Muchang", "Bahng", "Duke", "Math", 1, ["Lin Alg", "Multi"])
    print(x.courses[1])     # Multi
    print(x[1])             # Multi 
    </pre>
    Normally, we can return the elements of the courses list by indexing from the attribute <code>x.courses</code>, which is a list. But if we want to index <i>directly</i> from the object itself, we must include the <code>__getitem__(i)</code> method. <code>x[1]</code> calls <code>x.__getitem__(1)</code>.  
  </li>
  <li>
    The operators <code>-, *, /, ==, &lt;, &gt;, &lt;=;, &gt;=</code> also call certain dunder methods
    <pre>
    >>> x - y     # Calls x.__sub__(y)
    8
    >>> x * y     # Calls x.__mul__(y)
    20
    >>> x / y     # Calls x.__truediv__(y)
    5.0
    >>> x == y    # Calls x.__eq__(y)
    False
    >>> x &lt;= y # Calls x.__lt__(y)
    False
    >>> x >= y    # Calls x.__gt__(y)
    True
    </pre>
  </li>
  <li>
    If we create a new class, instantiate an object, and try to print that object, it returns the class of that object followed by its <code>id</code>. 
    <pre>
      class testClass(): 
    
          def __init__(self, name): 
              self.name = name
  
      x = testClass("Muchang")
      print(x)                    # &lt;__main__.testClass object at 0x000001F1B2D84FD0>
    </pre> 
    <code>print</code> is also a function, and when we call <code>print(object)</code>, in the background it really calls the <code>__str__()</code> method in the object. Therefore, adding the <code>__str__()</code> method allows us to apply the <code>print</code> function. 
    <pre>
    class testClass(): 
  
        def __init__(self, name): 
            self.name = name
  
        def __str__(self): 
            return f"Name: {self.name}"
          

    x = testClass("Muchang")
    print(x)                    #Name: Muchang
    </pre>
    There is another very similar method called the <code>__repr__()</code> method that also converts to a string, but with some differences (irrelevant here). In JupyterNotebook or the command line, we don't have to call <code>print</code> in order to print. It does so automatically: 
    <pre>
    >>> x = 4 
    >>> x 
    4
    </pre>
    In this case, the <code>__repr__()</code> method is called when we just typed <code>x</code>, and without defining this method, the console would output the object id: 
    <pre>
    >>> class testClass():
    ...     def __init__(self, name):
    ...             self.name = name
    ...
    ...     def __str__(self):
    ...             return f"Name: {self.name}"
    ...
    >>> x = testClass("Muchang")
    >>> print(x)
    Name: Muchang
    >>>
    >>> x
    &lt;__main__.testClass object at 0x000001C874E6A140>
    </pre>
    To ensure that our class supports this, we should define <code>__repr__()</code>: 
    <pre>
    >>> class testClass():
    ...
    ...     def __init__(self, name):
    ...             self.name = name
    ... #
    ...     def __str__(self):
    ...             return f"Name: {self.name}"
    ... #
    ...     def __repr__(self):
    ...             return f"Name: {self.name}"
    ... 
    >>> x = testClass("Muchang")
    >>> print(x)
    Name: Muchang
    >>> x
    Name: Muchang
    </pre>
  </li>
  <li>
    The operators <code>+=, -=, *=, /=</code> also calls dunder methods. 
    <pre>
    >>> x = 4 
    >>> y = 2 
    >>> x += y      # x.__iadd__(y)
    >>> x -= y      # x.__isub__(y)
    >>> x *= y      # x.__imul__(y)
    >>> x /= y      # x.__itruediv__(y)
    </pre>
  </li>
</ul>
The examples above show how we are able to build custom classes and customize existing classes. However, it is not recommended to change any of the built-in functions and its associated methods. 
<br><br>
Now we can introduce <b>dunder/magic methods</b>, which are methods having two prefix and suffix underscores in the method name. The "dunder" is shorthand for "double underscore." These methods are used for operator overloading, which means to give a certain method an extended meaning beyond their predefined operational meaning. For example, the <code>__add__()</code> operator is used to add two integers as well as join two strings and merge two lists. This is because the <code>__add__()</code> operator is overloaded by the <code>int</code>, <code>str</code>, and <code>list</code> classes. 
<pre>
>>> int1 = 2
>>> int2 = 5
>>> str1 = "Hello "
>>> str2 = "World"
>>> list1 = [1, 2, 3]
>>> list2 = [4, 5, 6]
>>> int1.__add__(int2)
7
>>> str1.__add__(str2)
'Hello World'
>>> list1.__add__(list2)
[1, 2, 3, 4, 5, 6]
</pre>
There are many other overloaded operators, the most common being the <code>__init__()</code> method which is called whenever an object is instantiated. All of the operators mentioned above are also overloaded, since they are implemented in multiple classes. 

<div class="subsection_title">Iterators and Generators</div>


</div>

<div class="title_and_hide">
<p id="Section7" class="section_title">DateTime Package</p>
<a id="show_hide_7" class="show_hide" onclick="show_hide_7()">[Hide]</a></div>
<hr>
<div id="section_content_7">
Once we install and import the <code>datetime</code> package, we can see that every <code>datetime</code> object has 7 components: <b>year, month, day, hour, minute, second, microsecond</b>. 
<ul>
  <li><code>dt.datetime.now()</code> returns the current datetime. </li>
</ul>
<pre class="terminal">
>>> import datetime as dt
>>> x = dt.datetime.now()
>>> x
datetime.datetime(2021, 11, 29, 23, 9, 41, 334025)
>>> print(x)
2021-11-29 23:09:41.334025
>>> type(x)
&lt;class 'datetime.datetime'>
</pre>
To create datetime objects, we use <code>dt.datetime(year, month, day)</code>. This can take in additional arguments for time (hour, minute, second, microsecond with default being <code>0</code>). 
<pre class="terminal">
>>> x = dt.datetime(2021, 11, 29)
>>> print(x)
2021-11-29 00:00:00
>>> y = dt.datetime(2021, 11, 29, 23, 16, 43, 23454)
>>> print(y)
2021-11-29 23:16:43.023454
</pre>
Given that we have a datetime, such as <code>y</code>, we can do multiple things: 
<ul>
  <li><code>y.weekday()</code> outputs a number representing the weekday (0: Mon, 1: Tues, 2: Wed, 3: Thurs, 4: Fri, 5: Sat, 6 Sun)</li>
  <li><code>y.date()</code> outputs only the date</li>
  <li><code>y.time()</code> outputs only the time</li>
</ul>
<pre class="terminal">
>>> y.weekday()
0
>>> print(y.date())
2021-11-29
>>> print(y.time())
23:16:43.023454
</pre>
Furthermore, we can use <code>dt.timedelta</code> to add or subtract a certain time from a <code>datetime</code> object. 
<ul>
  <li><code>dt.timedelta()</code> creates a <code>timedelta</code> object that we can add to a <code>datetime</code> object. </li>
  <li>Subtracting a <code>datetime</code> object from another <code>datetime</code> object returns a <code>timedelta</code> object. </li>
</ul>
<pre class="terminal">
>>> tday = dt.date.today()
>>> tdelta = dt.timedelta(days=7)
>>> print(tday)
2021-11-29
>>> nxtwk = tday + tdelta
>>> print(nxtwk)
2021-12-06
>>> print(nxtwk - tday)
7 days, 0:00:00
</pre>

<div class="subsection_title">Displaying DateTimes to Strings</div>
Given any <code>datetime</code> object <code>x</code>, <code>x.strftime(format)</code> converts it to a string. 
<pre class="terminal">
>>> y = dt.datetime(2021, 11, 29, 23, 16, 43, 23454)
>>> print(y.strftime("%B"))
November
>>> print(y.strftime("%Y-%m-%d"))
2021-11-29
>>> print(y.strftime("%B %d, %Y on a %A at %I:%M%p"))
November 29, 2021 on a Monday at 11:16PM
</pre>
The full list of legal format codes is listed: 
<table>
  <tr>
    <th>Directive</th>
    <th>Description</th>
    <th>Example</th>
  </tr>
  <tr>
    <td>%a, %A, %w</td>
    <td>Weekday short version, long version, as a number (0~6)</td>
    <td>Wed, Wednesday, 3</td>
  </tr>
  <tr>
    <td>%d</td>
    <td>Day of month 01-31</td>
    <td>31</td>
  </tr>
  <tr>
    <td>%b, %B, %m</td>
    <td>Month name short version, long version, as a number 01-12</td>
    <td>Dec, December, 12</td>
  </tr>
  <tr>
    <td>%y, %Y</td>
    <td>Year short version, full version</td>
    <td>18, 2018</td>
  </tr>
  <tr>
    <td>%H, %I, %p, %M</td>
    <td>Hour 00-23, Hour 00-12, AM/PM</td>
    <td>17, 05, PM</td>
  </tr>
  <tr>
    <td>%M, %S, %f</td>
    <td>Minute 00-59, Second 00-59, Microsecond 000000-999999</td>
    <td>41, 08, 548513</td>
  </tr>
  <tr>
    <td>%j, %U, %W</td>
    <td>Day number of year 001-366, Week number of year (Sunday as first day) 00-53, (Monday as first day) 00-53. </td>
    <td>365, 52, 52</td>
  </tr>
</table>

<div class="subsection_title">DateTimes with Time Zones</div>
The datetime objects that are not aware of time zones are called <b>naive datetimes</b>. On the other hand, <b>aware datetimes</b> do account for time zones. The <code>pytz</code> package is used when working with time zones. The list of all timezones can be found with the command <code>pytz.all_timezones</code>, but some important ones are: 
<ul>
  <li><code>pytz.timezone('Asia/Shanghai')</code></li>
  <li><code>pytz.timezone('US/Eastern')</code></li>
  <li><code>pytz.timezone('US/Pacific')</code></li>
  <li><code>pytz.timezone('US/Central')</code></li>
  <li><code>pytz.timezone('UTC')</code></li>
  <li><code>pytz.timezone('Asia/Seoul')</code></li>
  <li><code>pytz.timezone('Asia/Tokyo')</code></li>
</ul>
<pre class="terminal">
>>> x = dt.datetime(2021, 11, 29, tzinfo=pytz.timezone('US/Eastern'))
>>> x
datetime.datetime(2021, 11, 29, 0, 0, tzinfo=&lt;DstTzInfo 'US/Eastern' LMT-1 day, 19:04:00 STD>)
>>> print(x)
2021-11-29 00:00:00-04:56
</pre>
</div>

<div class="title_and_hide">
<p id="Section8" class="section_title">Numpy Package</p>
<a id="show_hide_8" class="show_hide" onclick="show_hide_8()">[Hide]</a></div>
<hr>
<div id="section_content_8">
<code>numpy</code> and <code>pandas</code> are two packages used to analyze large datasets. We briefly go over some of them in this chapter. We assume that these packages are installed in the relevant venv (click <a href="/Personal_Studies/CS_Stats/Virtual_Envs_Packages.html#Section3" target="_blank">here</a> for more info on virtual environments). A quick comparison of numpy vs pandas. 

<table style="width:90%; margin: 10px auto; ">
  <tr>
      <th style="width: 50%;">Pandas</th>
      <th style="width: 50%;">Numpy</th>
  </tr>
  <tr>
      <td>Preferred when working with <b>Tabular data</b>. </td>
      <td>Preferred when working with <b>Numerical data</b>. </td>
  </tr>
  <tr>
      <td>The powerful tools of pandas are <b>Dataframes</b> and <b>Series</b>. </td>
      <td>The powerful tool of numpy is <b>Arrays</b>. </td>
  </tr>
  <tr>
      <td>Pandas consume <b>more memory</b>. </td>
      <td>Numpy is more <b>memory efficient</b>. </td>
  </tr>
  <tr>
      <td>Pandas has better performance when number of rows is <b>500k or more</b>. </td>
      <td>Numpy has better performance when number of rows is <b>50k</b> or less. </td>
  </tr>
  <tr>
      <td>Indexing of pandas series is <b>very slow</b> compared to numpy arrays. </td>
      <td>Indexing of numpy Arrays is <b>very fast</b>. </td>
  </tr>
  <tr>
      <td>Pandas offers 2D table object called <b>DataFrame</b>. </td>
      <td>Numpy is capable of providing <b>multi-dimensional arrays</b>. </td>
  </tr>
</table>

Furthermore, there are several important differences between numpy arrays and standard Python sequences. 
<ul>
  <li>Numpy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Canging the size of an <code>ndarray</code> will create a new array and delete the original. </li>
  <li>The elements in a Numpy array are all required to be of the same data type, and thus will be the same size in memory. </li>
  <li>Numpy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using python's built-in sequences. </li>
</ul>
The points about sequence size and speed are particularly important with scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. If the data are stored in two Python lists, <code>a</code> and <code>b</code>, we could iterate over each element: 
<pre class="terminal">
c = []
for i in range(len(a)):
    c.append(a[i] * b[i])
</pre>
This produces the correct answer, but if <code>a</code> and <code>b</code> each contain millions of numbers, we will pay the price for the inefficienies of looping in Python. We could accomplish the same task much more quickly in C by writing: 
<pre class="terminal">
for (i = 0; i < rows; i++): {
  c[i] = a[i] * b[i];
}
</pre>
This saves all the overhead involved in interpreting the Python code and manipulating Python objects, but at the expense of the benefits gained from coding in Python. Furtherore, the coding work required increases with the dimensionality of our data. In the case of a 2-D array, the C code expands to 
<pre class="terminal">
for (i = 0; i < rows; i++): {
  for (j = 0; j < columns; j++): {
    c[i][j] = a[i][j] * b[i][j]; 
  }
}
</pre>
Numpy gives the best of both worlds: operations speedily executed by pre-compiled C code but with the code simplicity of something based on Python. This is known as <b>vectorization</b>, meaning the absence of any explicit looping, indexing, etc. in the code (or more accurately, the looping, etc. are taking place "behind the scenes" in optimized pre-compiled C code). 


<div class="subsection_title">Numpy Array Attributes</div>
A numpy <b>array</b>, also called an <code>ndarray</code>, is a multidimentional container of items of the same type and size. It is constructed using <code>array</code> and has the following attributes: 
<ul>
  <li><code>ndarray.ndim</code> outputs the dimension of the array</li>
  <li><code>ndarray.shape</code> returns the tuple describing the shape</li>
  <li><code>ndarray.size</code> returns the total number of elements in the array</li>
  <li><code>ndarray.dtype</code> describes the type of the elements in the array</li>
  <li><code>ndarray.itemsize</code> returns the amount of memory each element takes up, in Bytes</li>
</ul>
<pre class="terminal">
>>> x = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])
>>> x
array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14]])
>>> type(x)
&lt;class 'numpy.ndarray'>
>>> x.ndim
2
>>> x.shape
(3, 5)
>>> x.size
15
>>> x.dtype
dtype('int32')
>>> x.itemsize 
4
</pre>
Numpy also supports arrays of complex numbers. 
<pre class="terminal">
>>> np.array([[1+5j, 2+3j], [-8j, 4]], dtype=complex)
array([[ 1.+5.j,  2.+3.j],
      [-0.-8.j,  4.+0.j]])
</pre>
Furthermore, a 3-D array is shown as a stack of 2-D arrays. 
<pre class="terminal">
>>> np.arange(60).reshape(3, 4, 5)
array([[[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19]],

        [[20, 21, 22, 23, 24],
        [25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34],
        [35, 36, 37, 38, 39]],

        [[40, 41, 42, 43, 44],
        [45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54],
        [55, 56, 57, 58, 59]]])
</pre>

<div class="subsection_title">Numpy Array Creation</div>
Numpy arrays can be created with the following: 
<ul>
  <li><code>np.array</code> creates the array from an iterated list</li>
  <li><code>np.arange</code> creates a 1-D array with elements indexed from 0</li>
  <li><code>ndarray.reshape</code> reshapes the array to a specified shape</li>
  <li><code>np.zeros</code> creates an array of 0s</li>
  <li><code>np.ones</code> creates an array of 1s</li>
  <li><code>np.empty</code> creates an array of uninitialized values</li>
  <li><code>np.full</code> creates an array filled with one specified value</li>
</ul>
<pre class="terminal">
>>> np.array([[2, 3, 5], [-1, 8, 9]])
array([[ 2,  3,  5],
        [-1,  8,  9]])
>>> np.arange(8)
array([0, 1, 2, 3, 4, 5, 6, 7])
>>> np.arange(8).reshape(2, 4)
array([[0, 1, 2, 3],
        [4, 5, 6, 7]])
>>> np.zeros((2, 3), dtype=np.int64)
array([[0, 0, 0],
        [0, 0, 0]], dtype=int64)
>>> np.ones(4)
array([1., 1., 1., 1.])
>>> np.empty((2, 3, 2))
array([[[4.45057637e-308, 1.78021527e-306],
        [8.45549797e-307, 1.37962049e-306],
        [1.11260619e-306, 1.78010255e-306]],

       [[9.79054228e-307, 4.45057637e-308],
        [8.45596650e-307, 9.34602321e-307],
        [4.94065646e-322, 1.24610927e-306]]])
>>> np.full((2, 3), 10, dtype=np.int32)
array([[10, 10, 10],
        [10, 10, 10]])
</pre>
Furthermore, the <code>np.arange</code> function can be used to make arrays containing general arithmetic sequences, and if the number of elements is known (but not the step size), we can use <code>np.linspace</code>
<pre class="terminal">
>>> from numpy import pi
>>> np.arange(10, 30, 5)
array([10, 15, 20, 25])
>>> np.arange(0, 2, 0.3)
array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
>>> np.linspace(0, 2, 9)
array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])
>>> np.linspace(0, 2 * pi, 10)
array([0.        , 0.6981317 , 1.3962634 , 2.0943951 , 2.7925268 ,
       3.4906585 , 4.1887902 , 4.88692191, 5.58505361, 6.28318531])
</pre>
To get an array of random numbers, we use the following functions 
<ul>
  <li><code>np.random.rand(d1, d2, ...)</code> returns an array with elements picked randomly from a uniform distribution over $[0, 1)$, with the shape as its parameter. </li>
  <li><code>np.random.randint (low, high, shape)</code> returns an array of <code>shape</code> with elements as integers chosen randomly between <code>low</code> and <code>high</code>. </li>
</ul>
<pre class="terminal">
>>> np.random.rand()
0.9137870621759168
>>> np.random.rand(3, 2)
array([[0.40222644, 0.63487523],
        [0.03923849, 0.17318991],
        [0.25070361, 0.42871893]])
>>> np.random.randint(3, 10, (3, 3))
array([[3, 7, 3],
       [5, 3, 8],
       [6, 3, 8]])
</pre>

Finally, the null value is created with <code>np.nan</code>, which outputs <code>NaN</code>. This can be thought of as an undefined or missing value. 
<pre class="terminal">
>>> np.nan
nan
</pre>

<div class="subsection_title">Numpy Array Indexing, Slicing & Stacking</div>
Indexing and slicing arrays can be done as follows. 
<ul>
  <li>Indexing a 2-dimensional <code>ndarray</code> is like indexing the elements of a matrix: row first, then column (according to the shape)</li>
  <li>Since the 2-D array is like an iterated list, the first index iterates over the rows, and the second index iterates over the elements in each row. </li>
  <li><b>Slicing</b> an array can produce views, or cross-sections, of the array, and one can change elements of the array by setting it equal to a new number. </li>
</ul>
<pre class="terminal">
>>> x = np.arange(12).reshape(3, 4)
>>> x
array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x[2,3]
11
>>> x[0]
array([0, 1, 2, 3])
>>> x[:, 0]
array([0, 4, 8])
>>> x[-1]
array([ 8,  9, 10, 11])
</pre>
Arrays can be stacked and split along different axes. 
<ul>
  <li><code>np.vstack((a, b))</code> stacks array <code>b</code> below <code>a</code> vertically. </li>
  <li><code>np.hstack((a, b))</code> stacks array <code>b</code> to the right of <code>a</code> horizontally. </li>
  <li><code>hsplit</code> splits an array along its horizontal axis, either by specifying the number of equally shaped arrays to return or by specifying the columns after which the division should occur. </li>
  <li><code>vsplit</code> does exactly the same, except along its vertical axis. </li>
</ul>
<pre class="terminal">
>>> x = np.arange(4).reshape(2, 2)
>>> y =np.arange(5, 9).reshape(2, 2)
>>> x
array([[0, 1],
        [2, 3]])
>>> y
array([[5, 6],
        [7, 8]])
>>> np.vstack((x, y))
array([[0, 1],
        [2, 3],
        [5, 6],
        [7, 8]])
>>> np.hstack((x, y))
array([[0, 1, 5, 6],
        [2, 3, 7, 8]])
>>> z = np.arange(20).reshape(2, 10)
>>> z
array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]])
>>> np.hsplit(z, 5)
[array([[ 0,  1],
       [10, 11]]), array([[ 2,  3],
       [12, 13]]), array([[ 4,  5],
       [14, 15]]), array([[ 6,  7],
       [16, 17]]), array([[ 8,  9],
       [18, 19]])]
>>> np.hsplit(z, (3, 4))
[array([[ 0,  1,  2],
       [10, 11, 12]]), array([[ 3],
       [13]]), array([[ 4,  5,  6,  7,  8,  9],
       [14, 15, 16, 17, 18, 19]])]
       >>> w = np.arange(12).reshape(6, 2)
>>> np.vsplit(w, 6)
[array([[0, 1]]), array([[2, 3]]), array([[4, 5]]), array([[6, 7]]), array([[8, 9]]), array([[10, 11]])]
>>> np.vsplit(w, (3, 4))
[array([[0, 1],
       [2, 3],
       [4, 5]]), array([[6, 7]]), array([[ 8,  9],
       [10, 11]])]
</pre>


<div class="subsection_title">Numpy Array Copying</div>
There are three cases: 
<ul>
  <li>No copy is made, since simple assignments of data make no copies of objects or their data. In this case, <code>a</code> and <code>b</code> point to the same object. 
  <pre class="terminal">
>>> a = np.arange(15).reshape(3, 5)
>>> b = a
>>> id(a)
1539741920304
>>> id(b)
1539741920304
  </pre>
  </li>
  <li><b>View or shallow copies</b> represent the case when different array objects share the same data. The <code>view</code> method creates a new array object that looks at the same data (as shown in <code>base</code>). Note that changing the shape of a view copy does not affect the data nor the original copy, but changing the value of an element in a view copy does affect the base data and therefore affects the original copy. 
  <pre class="terminal">
>>> c = a.view()
>>> a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> c
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> id(a)
1539741920304
>>> id(c)
1539741920208
>>> c.base
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
>>> a.base
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
>>> c = c.reshape((5, 3))
>>> c
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
>>> a.shape
(3, 5)
>>> c[0, 2] = 1234
>>> c
array([[   0,    1, 1234],
       [   3,    4,    5],
       [   6,    7,    8],
       [   9,   10,   11],
       [  12,   13,   14]])
>>> a
array([[   0,    1, 1234,    3,    4],
       [   5,    6,    7,    8,    9],
       [  10,   11,   12,   13,   14]])
  </pre>
</li>
  <li><b>Deep copies</b> makes a complete copy of the array and its data, which becomes a completely different entity than the original copy. Whatever happens to one doesn't affect the other.
  <pre class="terminal">
>>> d = a.copy()
>>> d 
array([[   0,    1, 1234,    3,    4],
       [   5,    6,    7,    8,    9],
       [  10,   11,   12,   13,   14]])
>>> d is a
False
>>> d.base is a
False
>>> d[0, 0] = 99
>>> d
array([[  99,    1, 1234,    3,    4],
       [   5,    6,    7,    8,    9],
       [  10,   11,   12,   13,   14]])
>>> a
array([[   0,    1, 1234,    3,    4],
       [   5,    6,    7,    8,    9],
       [  10,   11,   12,   13,   14]])
  </pre>
  </li>
</ul>

<div class="subsection_title">Numpy Statistics</div>
Assuming that there are no <code>NaN</code> values in a given 1-D Numpy array <code>a</code>, we list some common statistics functions. Let <code>b</code> be another 1-D array with same shape as <code>a</code>. The functions in parentheses is the analog of the original functions for when there are <code>NaN</code> (null) values in <code>a</code> or <code>b</code>. 
<ul>
  <li><code>np.sum(a)</code> (<code>np.nansum(a)</code>) computes the sum of all elements in the array. </li>
  <li><code>np.ptp(a)</code> returns the range of the data in the array. </li>
  <li><code>np.min(a)</code> or <code>np.amin(a)</code> (<code>np.nanmin(a)</code>) returns the minimum of an array. </li>
  <li><code>np.max(a)</code> or <code>np.amax(a)</code> (<code>np.nanmax(a)</code>) returns the maximum of an array. </li>
  <li><code>np.percentile(a, q)</code> (<code>np.nanpercentile(a)</code>) returns the <code>q</code>th percentile of the array. </li>
  <li><code>np.quantile(a, q)</code> (<code>np.nanquantile(a)</code>) returns the <code>q</code>th quantile of the array. </li>
  <li><code>np.sort(a)</code> returns a sorted version of the data in the array. </li>
  <li><code>np.median(a)</code> (<code>np.nanmedian(a)</code>) computes the median of the array.</li>
  <li><code>np.mean(a)</code> (<code>np.nanmean(a)</code>) or <code>np.average(a)</code> computes the mean of the array. </li>
  <li><code>np.std(a)</code> (<code>np.nanstd(a)</code>) computes the standard deviation of the array. </li>
  <li><code>np.var(a)</code> (<code>np.nanvar(a)</code>) computes the variance of the array. </li>
  <li><code>np.corrcoef(a, b)</code> computes the Pearson product-moment correlation coefficient of the two arrays. </li>
  <li><code>np.correlate(a, b)</code> computes the cross-correlation of two 1-D arrays. </li>
  <li><code>np.cov(a, b)</code> computes the covariance matrix. </li>
  <li><code>np.histogram(a, bins=int, range=(float, float))</code> outputs a two-tuple of two arrays, with the first array being the amount of numbers in each bin, and the second tuple representing the size of each bin. This function will not work if there are <code>NaN</code> values in <code>a</code>. </li>
</ul>
<pre class="terminal">
>>> data = np.random.rand(1000)
>>> np.histogram(data, bins=50, range=(0, 2))
(array([34, 47, 35, 33, 39, 58, 40, 34, 39, 39, 45, 37, 38, 44, 47, 36, 28,
       39, 48, 43, 39, 36, 34, 44, 44,  0,  0,  0,  0,  0,  0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
      dtype=int64), array([0.  , 0.04, 0.08, 0.12, 0.16, 0.2 , 0.24, 0.28, 0.32, 0.36, 0.4 ,
       0.44, 0.48, 0.52, 0.56, 0.6 , 0.64, 0.68, 0.72, 0.76, 0.8 , 0.84,
       0.88, 0.92, 0.96, 1.  , 1.04, 1.08, 1.12, 1.16, 1.2 , 1.24, 1.28,
       1.32, 1.36, 1.4 , 1.44, 1.48, 1.52, 1.56, 1.6 , 1.64, 1.68, 1.72,
       1.76, 1.8 , 1.84, 1.88, 1.92, 1.96, 2.  ]))
</pre>

<div class="subsection_title">Numpy Linear Algebra</div>
The numpy linear algebra functions rely on low level implementations on standard linear algebra algorithms for efficiency. The <code>scipy</code> library also contains a <code>linalg</code> submodule with overlap in functionality, but the <code>scipy</code> module is much broader. Note that using the <code>numpy.matrix</code> object is <i>not</i> recommended, and that we should rather use a <code>numpy.array</code> object. Some common functions are listed: 
<ul>
  <li><code>np.eye(N)</code> returns the $N$-dimensional identity matrix. </li>
  <li><code>x.transpose()</code> returns the transpose of 2-D array <code>x</code>. </li>
  <li><code>np.dot(a, b)</code> computes the dot product of two 1-dimensional arrays.</li>
  <li><code>np.outer(a, b)</code> computes the outer product of two 1-dimensional arrays. </li>
  <li><code>np.matmul(x1, x2)</code> computes the matrix product of the two 2-dimensional arrays. </li>
  <li><code>np.linalg.matrix_power(a, n)</code> computes the square matrix <code>a</code> raised to the (integer) power <code>n</code>. </li>
  <li><code>np.linalg.inv(a)</code> computes the multiplicative inverse of a matrix. </li>
  <li><code>np.linalg.pinv(a)</code> computes the pseudo-inverse of a matrix. </li>
  <li><code>np.linalg.det(a)</code> computes the determinant of an array. </li>
  <li><code>np.linalg.matrix_rank(a)</code> computes the matrix rank of an array. </li>
  <li><code>np.trace(a)</code> computes the trace of matrix <code>a</code>. </li>
  <li><code>np.linalg.eig(a)</code> computes the eigenvalues and (right) eigenvectors of a square array.</li>
  <li><code>np.linalg.eigvals(a)</code> computes the eigenvalues of a general matrix. </li>
  <li><code>np.linalg.norm(x)</code> computes the matrix or vector norm. </li>
  <li><code>np.linalg.qr(a)</code> computes the QR factorization of a matrix. </li>
  <li><code>np.linalg.svd(a)</code> computes the singular value decomposition of a matrix. </li>
  <li><code>np.linalg.solve(a, b)</code> computes the solution <p class="math_mode">x</p> to the matrix linear equation <code>a</code><p class="math_mode">x =</p><code>b</code>. </li>
  <li><code>np.linalg.lstsq(a, b)</code> computes the least-squares solution to the matrix linear equation <code>a</code><p class="math_mode">x =</p><code>b</code>. </li>
</ul>

<div class="subsection_title">Saving and Loading Numpy Objects</div>
It is easy to save numpy a single <code>ndarray</code> object into a <code>.npy</code> file with <code>np.save(filename, array)</code> and to load them using <code>np.load(filename)</code>. 
<pre class="terminal">
>>> a = np.array([1, 2, 3, 4, 5, 6])
>>> np.save('filename', a)
>>> b = np.load('filename.npy')
>>> print(b)
[1 2 3 4 5 6]
</pre>
To save multiple numpy arrays, we store them into a <code>.npz</code> file with <code>np.savez(filename, array1, array2, ...)</code> and load them using <code> np.load(filename)</code>. 
<pre class="terminal">
>>> a = np.arange(6)
>>> b = np.arange(12).reshape(3, 4)
>>> c = np.arange(1000).reshape(10, 10, 10)
>>> np.savez("filename.npz", list1 = a, list2 = b, list3 = c)
>>> npzfile = np.load("filename.npz")
>>> npzfile.files
['list1', 'list2', 'list3']
>>> npzfile['list1']
array([0, 1, 2, 3, 4, 5])
>>> npzfile['list2']
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</pre>

</div>

<div class="title_and_hide">
<p id="Section9" class="section_title">Pandas Package</p>
<a id="show_hide_9" class="show_hide" onclick="show_hide_9()">[Hide]</a></div>
<hr>
<div id="section_content_9">
<div class="subsection_title">Pandas Series</div>
We can create a pandas <b>Series</b> by passing a list of values, letting pandas create a default integer index. We import numpy to define the null value. 
<pre class="terminal">
>>> import pandas as pd
>>> import numpy as np
>>> s = pd.Series([1, 3, 5, np.nan, 6, 8])
>>> s
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
>>> type(s)
&lt;class 'pandas.core.series.Series'&gt;
</pre>

<div class="subsection_title">Pandas DataFrame Creation & Indexing</div>
A pandas <b>DataFrame</b> is a 2-D labeled data structure with columns of potentially different types (in contrast to a 2-D ndarray, which must have <i>all</i> elements of all columns of the same type). There are multiple ways to create a pandas <b>DataFrame</b>, but they are all called through the command <code>pd.DataFrame(data, ...)</code>. 
<ul>
  <li>We can pass a 2-D Numpy array, with the index and columns labeled. 
<pre class="terminal">
>>> pd.DataFrame(np.random.randn(6, 4), index=[1, 2, 3, 4, 5, 6], columns=['A', 'B', 'C', 'D'])
          A         B         C         D
1 -0.716135  1.223677  0.055879 -0.203054
2 -0.606139  0.362999  0.073280  1.507172
3 -0.333047  0.143730  2.064551  0.722014
4 -1.284994  0.127667  0.074262 -1.003211
5 -0.401853  1.686010 -0.287202  0.663701
6 -1.123393  0.375613  1.478878  0.586513
</pre>
  </li>
  <li>We can create one using a list of lists. 
<pre class="terminal">
>>> data = [['tom', 10], ['nick', 15], ['juli', 14]]
>>> pd.DataFrame(data, columns = ['Name', 'Age'])
   Name  Age
0   tom   10
1  nick   15
2  juli   14
</pre>
  </li>
  <li>Finally, we can create one using a dictionary. 
<pre class="terminal">
>>> data = {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
>>> pd.DataFrame(data, index = ['Day 1', 'Day 2', 'Day 3', 'Day 4'])
</pre>
  </li>
</ul>
There are some useful functions when it comes to indexing. 
<ul>
  <li>We can treat the dictionary like an iterated list when indexing, with the first index refrencing the column and the second referencing the element in the column. 
<pre class="terminal">
>>> df
        AAA  BBB  CCC
Day 1    4   10  100
Day 2    5   20   50
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
>>> df['AAA']
Day 1    4
Day 2    5
Day 3    6
Day 4    7
Day 5    8 
Day 6    1 
Name: AAA, dtype: int64
>>> df['AAA']['Day 3']
6
</pre>
  </li>
  <li><code>df.head()</code> and <code>df.tail()</code> returns the top and bottom rows (by default, 5) of the dataframe <code>df</code>. 
  <pre class="terminal">
>>> df.head()
       AAA  BBB  CCC
Day 1    4   10  100
Day 2    5   20   50
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
>>> df.tail(3)
       AAA  BBB  CCC
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
  </pre>
  </li>
  <li><code>df.index</code> and <code>df.columns</code> returns the index and columns of the dataframe <code>df</code>. 
  <pre class="terminal">
>>> df.index
Index(['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6'], dtype='object')
>>> df.columns
Index(['AAA', 'BBB', 'CCC'], dtype='object')
  </pre>
  </li>
  <li><code>df.loc[row_labels, column_labels]</code> allows us to select (potentially multiple) rows, columns, and sub-DataFrames by label. 
<pre class="terminal">
>>> df
       AAA  BBB  CCC
Day 1    4   10  100
Day 2    5   20   50
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
>>> df.loc['Day 1', : ]
AAA      4
BBB     10
CCC    100
Name: Day 1, dtype: int64
>>> df.loc[ : , 'AAA']
Day 1    4
Day 2    5
Day 3    6
Day 4    7
Day 5    8
Day 6    1
Name: AAA, dtype: int64
>>> df.loc[: , ['AAA', 'BBB']]
       AAA  BBB
Day 1    4   10
Day 2    5   20
Day 3    6   30
Day 4    7   40
Day 5    8   50
Day 6    1   60
>>> df.loc[ ['Day 1', 'Day 2', 'Day 6'], ['AAA', 'BBB']]
       AAA  BBB
Day 1    4   10
Day 2    5   20
Day 6    1   60
</pre>
  </li>
  <li><code>df.iloc[row_positions, column_positions]</code> allows us to select (potentially multiple) rows, columns, and sub-DataFrames by position. 
  <pre class="terminal">
>>> df
       AAA  BBB  CCC
Day 1    4   10  100
Day 2    5   20   50
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
>>> df.iloc[3]
AAA     7
BBB    40
CCC   -50
Name: Day 4, dtype: int64
>>> df.iloc[3:5, 0:2]
       AAA  BBB
Day 4    7   40
Day 5    8   50
>>> df.iloc[2: , : ]
       AAA  BBB  CCC
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
>>> df.iloc[[1, 2, 4], [0, 2]]
       AAA  CCC
Day 2    5   50
Day 3    6  -30
Day 5    8  -80
>>> df.iloc[1, 1]
20
</pre>
  </li>
</ul>

<div class="subsection_title">Adding, Deleting, Changing Elements in DataFrames</div>
In a DataFrame, we can change a single element, a row, or a column using either labels or by position by setting whatever element, row, or column equal to a new value. We show an example using labels but the process for position is identical using <code>iloc</code>. 
<pre class="terminal">
>>> df
       AAA   BBB   CCC
Day 1  3.0   3.0   3.0
Day 2  5.0  20.0  50.0
Day 3  NaN  30.0 -30.0
Day 4  7.0  40.0 -50.0
Day 5  8.0  50.0 -80.0
Day 6  1.0  60.0 -90.0
>>> df = pd.DataFrame(data, index=index)
>>> df
       AAA  BBB  CCC
Day 1    4   10  100
Day 2    5   20   50
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
>>> df["BBB"]["Day 1"] = 999
>>> df
       AAA  BBB  CCC
Day 1    4  999  100
Day 2    5   20   50
Day 3    6   30  -30
Day 4    7   40  -50
Day 5    8   50  -80
Day 6    1   60  -90
>>> df.loc["Day 2", :] = [np.nan, np.nan, np.nan]
>>> df
       AAA    BBB    CCC
Day 1  4.0  999.0  100.0
Day 2  NaN    NaN    NaN
Day 3  6.0   30.0  -30.0
Day 4  7.0   40.0  -50.0
Day 5  8.0   50.0  -80.0
Day 6  1.0   60.0  -90.0
>>> df.loc[ : , "CCC"] = [0, 0, 0, 0, 0, 0]
>>> df
       AAA    BBB  CCC
Day 1  4.0  999.0    0
Day 2  NaN    NaN    0
Day 3  6.0   30.0    0
Day 4  7.0   40.0    0
Day 5  8.0   50.0    0
Day 6  1.0   60.0    0
>>> df.loc[['Day 1', 'Day 3', 'Day 5'], ['AAA', 'CCC']] = np.ones((3, 2))
>>> df
       AAA    BBB  CCC
Day 1  1.0  999.0  1.0
Day 2  NaN    NaN  0.0
Day 3  1.0   30.0  1.0
Day 4  7.0   40.0  0.0
Day 5  1.0   50.0  1.0
Day 6  1.0   60.0  0.0
</pre>
To delete rows and columns (for elements, we can just set them to <code>NaN</code>), we use the <code>drop</code> function. Note that the drop function removes columns and rows based on labels rather than positioning. 
<ul>
  <li>To delete a column, we input in a list of the column labels and set parameter <code>axis=1</code>. </li>
  <li>To delete a row, we input in a list of the row labels and set parameter <code>axis=0</code>. </li>
</ul>
<pre class="terminal">
>>> df2, df3 = df.copy(), df.copy()
>>> df2.drop(['AAA', 'CCC'], axis=1)
         BBB
Day 1  999.0
Day 2    NaN
Day 3   30.0
Day 4   40.0
Day 5   50.0
Day 6   60.0
>>> df3.drop(['Day 2', 'Day 5'], axis=0)
       AAA    BBB  CCC
Day 1  1.0  999.0  1.0
Day 3  1.0   30.0  1.0
Day 4  7.0   40.0  0.0
Day 6  1.0   60.0  0.0
</pre>
To add two dataframes together with the same column but with additional indices (rows), we use the <code>concat()</code> function. 
<pre class="terminal">
>>> df1 = pd.DataFrame(
  {
      "A": ["A0", "A1", "A2", "A3"],
      "B": ["B0", "B1", "B2", "B3"],
      "C": ["C0", "C1", "C2", "C3"],
      "D": ["D0", "D1", "D2", "D3"],
  },
  index=[0, 1, 2, 3],
)
>>> df2 = pd.DataFrame(
  {
      "A": ["A4", "A5", "A6", "A7"],
      "B": ["B4", "B5", "B6", "B7"],
      "C": ["C4", "C5", "C6", "C7"],
      "D": ["D4", "D5", "D6", "D7"],
  },
  index=[4, 5, 6, 7],
)
>>>
>>>
>>> df3 = pd.DataFrame(
  {
      "A": ["A8", "A9", "A10", "A11"],
      "B": ["B8", "B9", "B10", "B11"],
      "C": ["C8", "C9", "C10", "C11"],
      "D": ["D8", "D9", "D10", "D11"],
  },
  index=[8, 9, 10, 11],
)
>>> pd.concat([df1, df2, df3])
      A    B    C    D
0    A0   B0   C0   D0
1    A1   B1   C1   D1
2    A2   B2   C2   D2
3    A3   B3   C3   D3
4    A4   B4   C4   D4
5    A5   B5   C5   D5
6    A6   B6   C6   D6
7    A7   B7   C7   D7
8    A8   B8   C8   D8
9    A9   B9   C9   D9
10  A10  B10  C10  D10
11  A11  B11  C11  D11
</pre>


<div class="subsection_title">Copying, Saving, Loading Pandas DataFrames</div>
Copying a DataFrame is very simple using the <code>df.copy()</code>. By default, the only parameter <code>deep</code> is set to <code>True</code>, allowing us to create a deep copy of <code>pd</code>, and setting <code>deep=False</code> makes a shallow copy. 
<pre class="terminal">
>>> df
       AAA    BBB  CCC
Day 1  1.0  999.0  1.0
Day 2  NaN    NaN  0.0
Day 3  1.0   30.0  1.0
>>> df2 = df.copy()
>>> df2
       AAA    BBB  CCC
Day 1  1.0  999.0  1.0
Day 2  NaN    NaN  0.0
Day 3  1.0   30.0  1.0
</pre>

To save a pandas dataframe to a file, we use the the following. Assume that <code>df</code> is a dataframe and <code>encoding='utf8'</code> should be set to avoid any character issues. 
<ul>
  <li><code>df.to_csv("filename.csv", index, encoding='utf8')</code> saves the data to a <code>csv</code> saves the file to <code>filename.csv</code> (path can also be specified here). Setting <code>index=False</code> does not save the row numbers in the output file, and setting <code>index=True</code> does. </li>
  <li><code>df.to_excel("filename.csv", index, encoding='utf8')</code> also saves the data to a <code>.xlsx</code> file, with the same parameters. </li>
</ul>
<pre class="terminal">
>>> df
       AAA    BBB  CCC
Day 1  1.0  999.0  1.0
Day 2  NaN    NaN  0.0
Day 3  1.0   30.0  1.0
>>> df.to_csv("output_filename.csv", index=False, encoding='utf8')
</pre>
To load the data in a certain file, we simply use the <code>read_csv</code> command. 
<pre class="terminal">
>>> data = pd.read_csv("path_to_filename.csv")
</pre>
</div>

<script src="/JS/html_notes.js"></script>
</body>
</html>
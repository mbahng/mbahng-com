Now that we have learned the theory behind computer science, we will begin to start building a computer from scratch, and the hardware (and low level software) design of the computer is within the realm of \textit{computer architecture}. Starting from the lowest levels allow you to both understand completely the abstractions and appreciate what they do for you. 

We should start with transistors, which allows you to then physically implement basic logic gates. This then gives us a sequence of bits to work with, and to create meaningful representations, we define \textit{encoding schemes} on them. Then, these can then be used to do Boolean arithmetic and logical operations (e.g. conditionals), which unlocks our first component of the CPU: the ALU. We must still figure out how to simulate volatile and non-volatile storage, which allows us to define registers and memory. Finally, we wish to define a very tiny language of instructions---called the \textit{instruction set architecture}---that the CPU can understand. This allows the MMU to also interact with the memory. 

\begin{definition}[Instruction Set Architecture]
  The \textbf{instruction set architecture (ISA)} of a CPU is a description of what it can do. Its scope covers the following. 
  \begin{enumerate} 
    \item What instructions it can execute, such as bit-length, decoding, and number of operations. 
    \item The performance vs power efficiency. 
  \end{enumerate}
\end{definition}

\begin{example}[]
  ISAs can be classified into two types. 
  \begin{enumerate} 
    \item The \textbf{complex instruction set computer} (CISC) is characterized by a large set of complex instructions, which can execute a variety of low-level operations. This approach aims to reduce the number of instructions per program, attempting to achieve higher efficiency by performing more operations with fewer instructions. An example is x86, which is the most common architecture for personal computers.  
    \item The \textbf{reduced instruction set computer} (RISC) emphasizes simplicity and efficiency with a smaller number of instructions that are generally simpler and more uniform in size and format. This approach facilitates faster instruction execution and easier pipelining, with the philosophy that simpler instructions can provide greater performance when optimized. Some examples are the ARM and RISC-V architectures. 
  \end{enumerate}
\end{example}

The actual method in which a given ISA is implemented in a processor is called the \textit{microarchitecture}. 

\begin{definition}[Microarchitecture]
  The \textbf{microarchitecture}. 
\end{definition}


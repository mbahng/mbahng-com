\section{Primitives}  

  \subsection{String Manipulation} 

    \begin{definition}[Checking Alphanumeric]
      \begin{table}[H]
        \centering
        \begin{tabular}{|c|p{8cm}|}
          \hline
          \textbf{Method} & \textbf{} \\
          \hline
          \texttt{str.isalnum()} & Return \texttt{True} is all chars in are alphanumeric and there is at least 1 char.\\ 
          \texttt{str.isalpha()} & Return \texttt{True} if all characters in string are alphanumeric and there is at least 1 char. \\ 
          \hline 
        \end{tabular}
        \caption{}
      \end{table}
    \end{definition}

    You probably used the \texttt{str.strip()} method. However, you can have more control over this. 

    \begin{definition}[Strip, Prefix, and Suffix] 
      \begin{table}[H]
        \centering
        \begin{tabular}{|c|p{10cm}|}
          \hline
          \textbf{Method} & \textbf{} \\
          \hline
          \texttt{str.lstrip(chars=None)} & Returns copy of string with leading characters (default ascii space) removed. \\
          \texttt{str.rstrip(chars=None)} & Returns copy of string with trailing characters (default ascii space) removed. \\
          \texttt{str.strip(chars=None)} & Returns copy of string with both leading and trailing characters removed. \\
          \texttt{str.removeprefix(prefix)} & Returns a string with the prefix removed (if it exists). \\
          \texttt{str.removesuffix(suffix)} & Returns a string with the suffix removed (if it exists). \\ 
          \texttt{str.startswith(prefix)} & Return \texttt{True} if starts with \texttt{prefix}, else \texttt{False} \\ 
          \texttt{str.endswith(prefix)} & Return \texttt{True} if ends with \texttt{prefix}, else \texttt{False} \\  
          \hline
        \end{tabular}
        \caption{Note that stripping, which targets all combinations defined in \texttt{chars}, is more aggressive than removing prefix. }
      \end{table}
    \end{definition} 

    \begin{definition}[Justify and Filling]
      \begin{table}[H]
        \centering
        \begin{tabular}{|c|p{8cm}|}
          \hline
          \textbf{Method} & \textbf{} \\
          \hline
          \texttt{str.ljust(width, fillchar=' ')} & Returns the string left justified in a string of length width with padding \texttt{fillchar}. \\ 
          \texttt{str.rjust(width, fillchar=' ')} & Returns the string right justified in a string of length width with padding \texttt{fillchar}. \\  
          \texttt{str.zfill(width)} & Returns copy of string left-filled with \texttt{"0"} digits to make a string of length \texttt{width}. Accounts for negative numbers. \\ 
          \hline
        \end{tabular}
        \caption{Note that stripping, which targets all combinations defined in \texttt{chars}, is more aggressive than removing prefix. }
      \end{table}
      \begin{lstlisting} 
        >>> "hello world".ljust(20)
        'hello world         '
        >>> "hello world".rjust(20)
        '         hello world'
        >>> "42".zfill(5)
        '00042'
        >>> "-42".zfill(5)
        '-0042'
      \end{lstlisting}
    \end{definition} 

    \begin{definition}[Find, Index, and Replace]
      \begin{table}[H]
        \centering
        \begin{tabular}{|c|p{8cm}|}
          \hline
          \textbf{Method} & \textbf{} \\
          \hline
          \texttt{str.find(sub)} & Return the lowest index in string where substring \texttt{sub} is found. Returns -1 if not found. \\  
          \texttt{str.index(sub)} & Like \texttt{str.find(sub)}, but raises \texttt{ValueError} when substring is not found. \\ 
          \texttt{str.replace(old, new)} & Return a copy of string with all occurrences of substring \texttt{old} replaced by \texttt{new}. \\ 
          \texttt{str.translate()} & Replace all occurrences of characters in string with a translation table. \\ 
          \hline
        \end{tabular}
      \end{table}
    \end{definition}

    \begin{definition}[Split and Partition]
      \begin{table}[H]
        \centering
        \begin{tabular}{|c|p{8cm}|}
          \hline
          \textbf{Method} & \textbf{} \\
          \hline
          \texttt{str.split(sep=None)} & Return a list of words in the string, using \texttt{sep} as delimiter string. \\ 
          \texttt{str.splitlines(sep=None)} & Like \texttt{str.split()} but we account for all newline characters (not only just \texttt{\textbackslash n}). \\ 
          \texttt{str.partition(sep)} & Split the string at the first occurrence of \texttt{sep}, and return a 3-tuple. \\ 
          \texttt{str.rpartition(sep)} & Split the string at last occurrence of \texttt{sep}, return a 3-tuple. \\  
          \hline
        \end{tabular}
      \end{table}
    \end{definition} 

\subsection{Typecasting}

  Let's talk about typecasting between these primitives. Note that converting strings to ints is pretty ambiguous. 

  \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
      \hline
      \textbf{Function} & \textbf{Input} & \textbf{Output} & \textbf{Notes} \\
      \hline
      \texttt{int.to\_bytes()} & \texttt{int} & \texttt{bytes} & Specify the \texttt{length} arg to prevent overflow. \\ 
      \textit{classmethod} \texttt{int.from\_bytes()} & \texttt{bytes} & \texttt{int} & \\
      \texttt{str.encode()} & \texttt{str} & \texttt{bytes} & Usually we use \texttt{encoding='utf-8'}. \\  
      \texttt{byte.decode()} & \texttt{bytes} & \texttt{str} & Usually we use \texttt{'utf-8'}. \\  
      \texttt{str()} & \texttt{int} & \texttt{str} & \\ 
      \hline
    \end{tabular} 
  \end{table}

  Now if you want to convert this to a fixed length, then you can simply use the built-in \texttt{hash()} function. Ints, strings, and bytes are all immutable and thus hashable. 


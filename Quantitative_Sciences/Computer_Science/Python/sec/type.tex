\section{Classes} 

  The development of the Python type hierarchy is a bit involved and requires you to know both implementation details and history. During the early days of Python 2, the language had both \textit{types} and \textit{classes}. Types were built-in objects implemented in C, and classes were what you built when using a \texttt{class} statement. These two were named differently because you couldn't mix these; classes could not extend types. However, this difference was artificial and ultimately a limitation in the language implementation. Starting with Python 2.2, the developers of Python have slowly moved towards unifying the two concepts, which the difference completely done in Python 3. Built-in types are now labeled classes, and you can extend them at will. Since we are working in Python 3, they are interchangeable.  

  \begin{theorem}[Types and Classes]
    In Python 3, types and classes mean the same thing. 
  \end{theorem} 

  Let's do a bit of review on classes. 

  \begin{definition}[Class] 
    A \textbf{class} is a template for creating objects, which support \textit{attributes} to store some state and \textit{methods} that may or may not modify the state. The object that is created from a class is called a \textbf{class instance}. 

    \begin{lstlisting}
      class ClassName: 
        ...  
    \end{lstlisting}
  \end{definition} 

  It is important to have good tools to analyze the class itself and the instance. These are mainly stored in \textit{dunder (double underscore)} methods, also called \textit{magic methods}. 

  \begin{definition}[Class and Type Information]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Functions} & \textbf{Description} \\
        \hline 
        \texttt{hasattr(obj, "attr\_name")} & checks if an object has a specific attribute \\
        \hline
        \texttt{isinstance(obj, ClassA)} & checks if an object is an instance of a class \\
        \hline
        \texttt{issubclass(ClassA, ClassB)} & checks if one class is a subclass of another \\
        \hline
        \texttt{type(obj)} & returns the type/class of an object \\
        \hline
        \texttt{dir(obj)} & lists all attributes and methods of an object \\
        \hline
        \texttt{vars(obj)} & returns the \_\_dict\_\_ of an object \\
        \hline
        \texttt{obj.\_\_dict\_\_} & dictionary containing the object's attributes \\
        \hline
        \texttt{obj.\_\_class\_\_} & reference to the object's class \\
        \hline
        \texttt{ClassA.\_\_name\_\_} & name of the class \\
        \hline
        \texttt{ClassA.\_\_module\_\_} & module where the class was defined \\
        \hline
        \texttt{ClassA.\_\_bases\_\_} & tuple of base classes \\
        \hline
        \texttt{ClassA.\_\_mro\_\_} & method resolution order tuple \\
        \hline
        \texttt{\_\_getattr\_\_(self, name)} & called when attribute doesn't exist \\
        \hline
        \texttt{\_\_setattr\_\_(self, name, value)} & called when setting attributes \\
        \hline
        \texttt{\_\_delattr\_\_(self, name)} & called when deleting attributes \\
        \hline
        \texttt{\_\_getattribute\_\_(self, name)} & called for all attribute access \\
        \hline
      \end{tabular}
      \caption{Class instances (objects) are marked with \texttt{obj} and Class definitions with \texttt{ClassA}.}
      \label{tab:functions_for_classes}
    \end{table}
  \end{definition}

  A class can be instantiated with the following. 

  \begin{example}[Animal Class Definition]
    \begin{figure}[H]
      \centering 
      \begin{lstlisting}
        class Animal: 
            def __init__(self, name):
                self.name = name
            
            def speak(self):
                return f"{self.name} makes a sound"
      \end{lstlisting} 
      \caption{} 
      \label{fig:animal_class}
    \end{figure}
  \end{example} 

  \begin{definition}[Documentation and Metadata]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Attributes} & \textbf{Description} \\
        \hline 
        \texttt{obj.\_\_doc\_\_} & docstring of the class or method \\
        \hline
        \texttt{obj.\_\_annotations\_\_} & type annotations dictionary \\
        \hline
      \end{tabular}
      \caption{Documentation and metadata attributes for classes and objects.}
      \label{tab:documentation_metadata}
    \end{table}
  \end{definition}

  \begin{definition}[Object Lifecycle]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_init\_\_(self, ...)} & constructor method \\
        \hline
        \texttt{\_\_new\_\_(cls, ...)} & object creation method (called before \_\_init\_\_) \\
        \hline
        \texttt{\_\_del\_\_(self)} & destructor method \\
        \hline
      \end{tabular}
      \caption{Methods that control object creation and destruction.}
      \label{tab:object_lifecycle}
    \end{table}
  \end{definition}

  \begin{definition}[String Representation]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_str\_\_(self)} & informal string representation (used by str()) \\
        \hline
        \texttt{\_\_repr\_\_(self)} & official string representation (used by repr()) \\
        \hline
      \end{tabular}
      \caption{Methods for string representation of objects.}
      \label{tab:string_representation}
    \end{table}
  \end{definition}

  \begin{definition}[Comparison and Hashing]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_eq\_\_(self, other)} & equality comparison (==) \\
        \hline
        \texttt{\_\_lt\_\_(self, other)} & less than comparison (<) \\
        \hline
        \texttt{\_\_gt\_\_(self, other)} & greater than comparison (>) \\
        \hline
        \texttt{\_\_le\_\_(self, other)} & less than or equal (<=) \\
        \hline
        \texttt{\_\_ge\_\_(self, other)} & greater than or equal (>=) \\
        \hline
        \texttt{\_\_ne\_\_(self, other)} & not equal (!=) \\
        \hline
        \texttt{\_\_hash\_\_(self)} & hash value for the object \\
        \hline
      \end{tabular}
      \caption{Methods for object comparison and hashing.}
      \label{tab:comparison_hashing}
    \end{table}
  \end{definition}

  \begin{definition}[Container-like Behavior]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_len\_\_(self)} & length of the object \\
        \hline
        \texttt{\_\_getitem\_\_(self, key)} & get item by index/key (obj[key]) \\
        \hline
        \texttt{\_\_setitem\_\_(self, key, value)} & set item by index/key (obj[key] = value) \\
        \hline
        \texttt{\_\_delitem\_\_(self, key)} & delete item by index/key (del obj[key]) \\
        \hline
        \texttt{\_\_iter\_\_(self)} & makes object iterable \\
        \hline
        \texttt{\_\_contains\_\_(self, item)} & supports 'in' operator \\
        \hline
      \end{tabular}
      \caption{Methods that make objects behave like containers.}
      \label{tab:container_behavior}
    \end{table}
  \end{definition}

  \begin{definition}[Mathematical Operations] 
    Most of the math operators in Python (\texttt{+}, \texttt{-}, ...) actually call some dunder method. We can define these dunder methods in order to use mathematical operations on class objects, e.g. \texttt{a + b}. 

    \begin{table}[H]
      \centering
      \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Methods} & \textbf{Description} \\
        \hline 
        \texttt{\_\_add\_\_(self, other)} & called when we evaluate \texttt{self + other} \\
        \hline
        \texttt{\_\_sub\_\_(self, other)} & called when we evaluate \texttt{self - other} \\
        \hline
        \texttt{\_\_mul\_\_(self, other)} & called when we evaluate \texttt{self * other} \\
        \hline
        \texttt{\_\_truediv\_\_(self, other)} & called when we evaluate \texttt{self / other} \\
        \hline
        \texttt{\_\_floordiv\_\_(self, other)} & called when we evaluate \texttt{self // other} \\
        \hline
        \texttt{\_\_mod\_\_(self, other)} & called when we evaluate \texttt{self \% other} \\
        \hline
        \texttt{\_\_pow\_\_(self, other)} & called when we evaluate \texttt{self ** other} \\
        \hline
        \texttt{\_\_and\_\_(self, other)} & called when we evaluate \texttt{self \& other} \\
        \hline
        \texttt{\_\_or\_\_(self, other)} & called when we evaluate \texttt{self | other} \\
        \hline
        \texttt{\_\_xor\_\_(self, other)} & called when we evaluate \texttt{self \^{} other} \\
        \hline
        \texttt{\_\_lshift\_\_(self, other)} & called when we evaluate \texttt{self << other} \\
        \hline
        \texttt{\_\_rshift\_\_(self, other)} & called when we evaluate \texttt{self >> other} \\
        \hline
        \texttt{\_\_neg\_\_(self)} & called when we evaluate \texttt{-self} \\
        \hline
        \texttt{\_\_pos\_\_(self)} & called when we evaluate \texttt{+self} \\
        \hline
        \texttt{\_\_abs\_\_(self)} & called when we evaluate \texttt{abs(self)} \\
        \hline
        \texttt{\_\_invert\_\_(self)} & called when we evaluate \texttt{\~{}self} \\
        \hline
        \texttt{\_\_round\_\_(self, ndigits)} & called when we evaluate \texttt{round(self)} \\
        \hline
        \texttt{\_\_floor\_\_(self)} & called when we evaluate \texttt{math.floor(self)} \\
        \hline
        \texttt{\_\_ceil\_\_(self)} & called when we evaluate \texttt{math.ceil(self)} \\
        \hline
        \texttt{\_\_trunc\_\_(self)} & called when we evaluate \texttt{math.trunc(self)} \\
        \hline
      \end{tabular}
      \caption{Methods for mathematical operations on objects.}
      \label{tab:mathematical_operations}
    \end{table}

    Note that in the abstract algebraic sense, \texttt{a + b} is really just a binary operation and may not be commutative. There are also \textit{reverse versions} of the binary operations, e.g. \texttt{\_\_radd\_\_}, that are called when the left operand doesn't support the operation. There are also \textit{in-place versions} like \texttt{\_\_iadd\_\_()} for operations like \texttt{+=}.  
  \end{definition}

\subsection{Inheritance, Polymorphism, and Encapsulation} 

  Conceptually, we might think of certain types a subset of another type. Therefore, it makes sense to design some \textit{hierarchy} of these types where children can extend the functionality of their parents. This is the conceptual idea of inheritance, which is a convenient way of designing code. In fact, if we had infinite coding power where we don't care about maintainability or the DRY (don't repeat yourself) principle, then you wouldn't need inheritance. 

  \begin{definition}[Class Inheritance]
    A \textbf{child class} can inherit the attributes and methods of the parent class, and in general should \textit{extend} the functionality of the base class. Here is the minimal example. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P: 
            ... 
          class B(A): 
            ...
        \end{lstlisting}
        \caption{Inheritance with 1 parent class and 1 child class.}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class P1: ... 
          class P2: ...
          class P3: ... 
          class C(P1, P2, P3): ...
        \end{lstlisting}
        \caption{Multiple inheritance with 3 parent and 1 child class.}
      \end{subfigure}
      \caption{}
    \end{figure}
  \end{definition}

  A more directly practical advantage of coding is that we can take advantage of the \textit{method resolution order (MRO)}. Let's introduce what this is slowly with a sequence of examples. 

  \begin{example}[Methods of Parent are Accessible from Child]
    Consider the two classes. 
    \begin{lstlisting}
      class Animal: 
        def __init__(self, name): 
          self.name = name 

        def speak(self): 
          print("Rah") # generic animal sound

      class Dog(Animal): 
        ...
    \end{lstlisting} 
    The only way \texttt{Dog} is connected to \texttt{Animal} is that it is declared as a subclass of \texttt{Animal}. It may not look like \texttt{Dog} even has a constructor method, but in fact we can access both the \texttt{\_\_init\_\_} and \texttt{speak} methods! 
    \begin{lstlisting} 
      >>> x = Dog("wolfy") 
      >>> x.speak() 
      "Rah"
    \end{lstlisting}
  \end{example} 

  So we have found out that subclasses can access parent class methods by default. But what if we have \textit{multiple} parent classes?  

  \begin{example}[Method Resolution with Multiple Parent Classes]
    Say that we have the same \texttt{Animal} class as defined above, but with the following hierarchy. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Animal: 
            def __init__(self, name):
              print("Animal constructor called.")
              self.name = name
            
            def speak(self):
              return f"{self.name} makes a sound"  

          class Flyer(Animal):  
            def __init__(self, name): 
              print("Flyer constructor called") 

          class Swimmer(Animal): 
            def __init__(self, name): 
              print("Swimmer constructor called") 
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Duck1(Flyer, Swimmer): 
            ... 

          class Duck2(Swimmer, Flyer): 
            ...

          class Duck3(Flyer, Swimmer): 
            def __init__(self, name): 
              print("Duck constructor called")
        \end{lstlisting}
        \caption{}
      \end{subfigure}
      \caption{}
    \end{figure}

    Interesting, so it seems like if the child class supports its own constructor, then it will call its own constructor, and if not, then it will look at the constructors of the parent classes, \textit{in the order in which they were specified} when defining the child class. 
      
    \begin{lstlisting}
      >>> Duck1("duck1")
      Flyer constructor called
      >>> Duck2("duck2")
      Swimmer constructor called
      >>> Duck3("duck3")
      Duck constructor called
    \end{lstlisting} 
  \end{example} 

  So when a subclass is instantiated, the child class somehow knows where to look first for an implementation of a method to call, then next, then next, etc. This ordering is extremely useful, though can be a double-edged sword.   

  \begin{definition}[Method Resolution Order]
    The \textbf{method resolution order (MRO)} of a given class \texttt{C} is a sequence of classes that Python looks through to find an implementation of any method. 
    \begin{enumerate}
      \item It is a tuple that can be retrieved with \texttt{C.\_\_mro\_\_} (this is a class method). 
      \item The actual way that the MRO is computed is with the \href{https://docs.python.org/3/howto/mro.html}{C3 Algorithm}, starting from Python 2.3.
    \end{enumerate}
  \end{definition}

  \begin{example}[MROs of Ducks]
    The MROs of the Duck classes confirms our suspicion. Generally, we go from the most specific class to the broadest class, which is always \texttt{object} in Python. 

    \begin{lstlisting}
      >>> print(Duck1.__mro__)
      (<class '__main__.Duck1'>, <class '__main__.Flyer'>, <class '__main__.Swimmer'>, <class '__main__.Animal'>, <class 'object'>)

      >>> print(Duck2.__mro__)
      (<class '__main__.Duck2'>, <class '__main__.Swimmer'>, <class '__main__.Flyer'>, <class '__main__.Animal'>, <class 'object'>)

      >>> print(Duck3.__mro__)
      (<class '__main__.Duck3'>, <class '__main__.Flyer'>, <class '__main__.Swimmer'>, <class '__main__.Animal'>, <class 'object'>)
    \end{lstlisting}
  \end{example} 

  \begin{definition}[Commands for Child-Parent Class Relation]
    \begin{table}[H]
      \centering
      \begin{tabular}{|c|c|}
        \hline
        \textbf{Method} & \textbf{Description} \\
        \hline
        \texttt{super()} & \texttt{Accesses parent class?} \\
        \hline
      \end{tabular}
      \caption{}
      \label{tab:}
    \end{table}
  \end{definition}


  \begin{enumerate}
    \item The constructor of the child class should call the constructor of the parent class in order to set up the attributes.\footnote{This is not strictly necessary, and we don't necessarily need to do this if we will completely override the parent's attributes. But then why would you use inheritance in the first place?} 

    \item You can add and override both attributes and methods by simply defining them after parent class constructor.   
    \item You can delete an attribute from the child class with the \texttt{delattr(ChildClass, "attribute")}, though this probably means you shouldn't be using inheritance at all. 
    \item You cannot delete a method that exists in the parent class from the child class. The best you can do is override it to throw an exception. 
  \end{enumerate}


  \begin{example}[Modifying Attributes in Child Class]
    We begin with an \texttt{Animal} class.

    \begin{figure}[H]
      \centering 
      \begin{lstlisting}
        class Animal: 
            def __init__(self, name):
                self.name = name
            
            def speak(self):
                return f"Rahhh" # generic animal sound
      \end{lstlisting} 
      \caption{} 
    \end{figure}

    There is a \texttt{Dog} class that we would like to inherit from \texttt{Animal}. Let's go through a few ways we can design the attributes of the child class. 

    \begin{figure}[H]
      \centering
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, name): 
              super().__init__(name) 
          .
        \end{lstlisting}
        \caption{Nothing is added. Since called the parent constructor, we still have access to the \texttt{name} attribute and \texttt{speak} method. }
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, name, breed): 
              super().__init__(name)
              self.breed = breed
        \end{lstlisting}
        \caption{We just want to add a new attribute called \texttt{breed}. Since called the parent constructor, we still have access to the \texttt{name} attribute and \texttt{speak} method. }
      \end{subfigure}

      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, id): 
              self.id = id
        \end{lstlisting}
        \caption{You don't even call the parent constructor, so you lose access to \texttt{name}. However, you still have access to the \texttt{speak()} method. This is not recommended.}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \begin{lstlisting}
          class Dog(Animal): 
            def __init__(self, name, breed): 
              super().__init__(name)  
              print(self.name)
              self.name = f"{name}_{breed}"
        \end{lstlisting}
        \caption{Say you want to override the name so that the breed is also included in it.}
      \end{subfigure}
      \caption{}
    \end{figure}
  \end{example}

  \begin{definition}[Multiple Inheritance]
    
  \end{definition}

\subsection{Metaclasses}

  Metaclasses 
    - Apparently need to know for PEP 3119

\subsection{Interfaces and Abstract Base Classes} 

  But classes are limited? So we want to use interfaces (duck typing).  

    % - Implemented as ABCs in python. https://peps.python.org/pep-3119/ 
    % - A new module abc which serves as an “ABC support framework”. It defines a metaclass for use with ABCs and a decorator that can be used to define abstract methods. 
    % - PEP 3141 gives a hierarchy of the numbers.  
    % - ABCs have two points, one obtained by subclassing ("invasive"), one by registering (non-invasive). (https://stackoverflow.com/questions/3392352/python-abcs-registering-vs-subclassing) 
    %

\subsection{Type Hints}
  Type Hints - PEP 484 (3.5) 

\subsection{Protocols}

  Protocols - PEP 544 (3.7) 

\subsection{Type Checking}

  \begin{question}[To Do]
    Move some of these to general language notes. 
  \end{question}

  \begin{definition}[Type Checking]
    \textbf{Type checking} is the process of verifying that the types of values in a program are used consistently and correctly according to the language's type system rules. These include: 
    \begin{enumerate}
      \item Operations are valid for their operand types 
      \item Function/method calls match their signatures 
      \item Assignments are type-compatible (though this isn't necessary in Python) 
    \end{enumerate}
  \end{definition}

  The implementation of type checking differs for every language, and they generally fall into 3 different philosophies. 

  \begin{definition}[Nominal Typing]
    \textbf{Nominal typing} is a static typing system that determines that two types are equal/compatible if their fully qualified class names (FQCN) are equal. 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=C++]{Code}
          struct Cat {
              std::string name;
              int age;
          };

          void printCat(const Cat& c) {
              std::cout << "Cat: " << c.name << ", age " << c.age << "\n";
          }        
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[language=C++]{Output}
          struct Dog {
              std::string name;
              int age;
          };

          void printDog(const Dog& d) {
              std::cout << "Dog: " << d.name << ", age " << d.age << "\n";
          }
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}[language=C++]
        int main() {
            Cat kitty{"Whiskers", 3};
            Dog pup{"Buddy", 5};

            printCat(kitty); // works
            printDog(pup);   // works

            // printCat(pup); // error: cannot convert Dog to Cat (nominal typing)

            return 0;
        } 
      \end{lstlisting}
      \caption{C++ uses aspects of nominal typing.} 
      \label{fig:cpp_nominal}
    \end{figure}
  \end{definition}

  \begin{definition}[Structural Typing]
    \textbf{Structural typing} is a static typing system that determines that two types are equal/compatible if their structures (e.g. the attributes and methods it supports) are equal. The class name is immaterial. 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=php]{Code}
          type Cat = {
            name: string;
            age: number;
          };

          function printCat(c: Cat) {
            console.log(`Cat: ${c.name}, age ${c.age}`);
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          type Dog = {
            name: string;
            age: number;
          };

          function printDog(d: Dog) {
            console.log(`Dog: ${d.name}, age ${d.age}`);
          }
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}
        const kitty: Cat = { name: "Whiskers", age: 3 };
        const pup: Dog = { name: "Buddy", age: 5 };

        printCat(kitty); // works
        printDog(pup);   // works
        printCat(pup);   // also works (structural typing!)
      \end{lstlisting}
      \caption{Typescript uses aspects of structural typing.} 
      \label{fig:typescript_structural}
    \end{figure}
  \end{definition}

  \begin{definition}[Duck Typing]
    \textbf{Duck typing} is a dynamic typing system that determines that two types are equal/compatible is the \textit{accessed} structure (e.g. used attributes or called methods) are equal. The class name and the unused properties are immaterial.\footnote{If it walks like a duck and quacks like a duck, then it must be a duck.} 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=python]{Code}
          class Cat:
              def __init__(self, name, age):
                  self.name = name
                  self.age = age 

              def meow(self): 
                  print("meow")

          def print_cat(c):
              print(f"Cat: {c.name}, age {c.age}")
        \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          class Dog:
              def __init__(self, name, age):
                  self.name = name
                  self.age = age

              def bark(self): 
                  print("woof")

          def print_dog(d):
              print(f"Dog: {d.name}, age {d.age}")
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}
        kitty = Cat("Whiskers", 3)
        pup   = Dog("Buddy", 5)

        print_cat(kitty) # works
        print_dog(pup)   # works
        print_cat(pup)   # also works though structures are different
        pup.bark(), kitty.meow()       # works  
        pup.meow() # Error: 'Dog' object has no attribute 'meow'
      \end{lstlisting}
      \caption{Python uses duck typing: any object with the right attributes can be passed.} 
      \label{fig:python_duck}
    \end{figure}
  \end{definition} 

  Duck typing and structural typing are similar (and often confused) but distinct, and the preference for one over the other is controversial. The big difference is that duck typing is ``looser'' in that type checking happens at \textit{runtime}, whether an object has the required methods/properties when they are actually used. 

  We will start by going through all the types in Python. 


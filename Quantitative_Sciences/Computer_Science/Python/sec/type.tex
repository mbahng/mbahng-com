\section{Types} 

  \begin{question}[To Do]
    Move some of these to general language notes. 
  \end{question}

  To avoid confusion, let's delve into a bit of history. During the early days of Python 2, the language had both \textit{types} and \textit{classes}. Types were built-in objects implemented in C, and classes were what you built when using a \texttt{class} statement. These two were named differently because you couldn't mix these; classes could not extend types. However, this difference was artificial and ultimately a limitation in the language implementation. Starting with Python 2.2, the developers of Python have slowly moved towards unifying the two concepts, which the difference completely done in Python 3. Built-in types are now labeled classes, and you can extend them at will. Since we are working in Python 3, they are interchangeable.  

  \begin{theorem}[Types and Classes]
    In Python 3, types and classes mean the same thing. 
  \end{theorem} 

  \begin{definition}[Type Checking]
    \textbf{Type checking} is the process of verifying that the types of values in a program are used consistently and correctly according to the language's type system rules. These include: 
    \begin{enumerate}
      \item Operations are valid for their operand types 
      \item Function/method calls match their signatures 
      \item Assignments are type-compatible (though this isn't necessary in Python) 
    \end{enumerate}
  \end{definition}

  The implementation of type checking differs for every language, and they generally fall into 3 different philosophies. 

  \begin{definition}[Nominal Typing]
    \textbf{Nominal typing} is a static typing system that determines that two types are equal/compatible if their fully qualified class names (FQCN) are equal. 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=C++]{Code}
          struct Cat {
              std::string name;
              int age;
          };

          void printCat(const Cat& c) {
              std::cout << "Cat: " << c.name << ", age " << c.age << "\n";
          }        
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[language=C++]{Output}
          struct Dog {
              std::string name;
              int age;
          };

          void printDog(const Dog& d) {
              std::cout << "Dog: " << d.name << ", age " << d.age << "\n";
          }
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}[language=C++]
        int main() {
            Cat kitty{"Whiskers", 3};
            Dog pup{"Buddy", 5};

            printCat(kitty); // works
            printDog(pup);   // works

            // printCat(pup); // error: cannot convert Dog to Cat (nominal typing)

            return 0;
        } 
      \end{lstlisting}
      \caption{C++ uses aspects of nominal typing.} 
      \label{fig:cpp_nominal}
    \end{figure}
  \end{definition}

  \begin{definition}[Structural Typing]
    \textbf{Structural typing} is a static typing system that determines that two types are equal/compatible if their structures (e.g. the attributes and methods it supports) are equal. The class name is immaterial. 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=php]{Code}
          type Cat = {
            name: string;
            age: number;
          };

          function printCat(c: Cat) {
            console.log(`Cat: ${c.name}, age ${c.age}`);
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          type Dog = {
            name: string;
            age: number;
          };

          function printDog(d: Dog) {
            console.log(`Dog: ${d.name}, age ${d.age}`);
          }
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}
        const kitty: Cat = { name: "Whiskers", age: 3 };
        const pup: Dog = { name: "Buddy", age: 5 };

        printCat(kitty); // works
        printDog(pup);   // works
        printCat(pup);   // also works (structural typing!)
      \end{lstlisting}
      \caption{Typescript uses aspects of structural typing.} 
      \label{fig:typescript_structural}
    \end{figure}
  \end{definition}

  \begin{definition}[Duck Typing]
    \textbf{Duck typing} is a dynamic typing system that determines that two types are equal/compatible is the \textit{accessed} structure (e.g. used attributes or called methods) are equal. The class name and the unused properties are immaterial.\footnote{If it walks like a duck and quacks like a duck, then it must be a duck.} 

    \begin{figure}[H]
      \centering 
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[language=python]{Code}
          class Cat:
              def __init__(self, name, age):
                  self.name = name
                  self.age = age 

              def meow(self): 
                  print("meow")

          def print_cat(c):
              print(f"Cat: {c.name}, age {c.age}")
        \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          class Dog:
              def __init__(self, name, age):
                  self.name = name
                  self.age = age

              def bark(self): 
                  print("woof")

          def print_dog(d):
              print(f"Dog: {d.name}, age {d.age}")
        \end{lstlisting}
      \end{minipage}

      \begin{lstlisting}
        kitty = Cat("Whiskers", 3)
        pup   = Dog("Buddy", 5)

        print_cat(kitty) # works
        print_dog(pup)   # works
        print_cat(pup)   # also works though structures are different
        pup.bark(), kitty.meow()       # works  
        pup.meow() # Error: 'Dog' object has no attribute 'meow'
      \end{lstlisting}
      \caption{Python uses duck typing: any object with the right attributes can be passed.} 
      \label{fig:python_duck}
    \end{figure}
  \end{definition} 

  Duck typing and structural typing are similar (and often confused) but distinct, and the preference for one over the other is controversial. The big difference is that duck typing is ``looser'' in that type checking happens at \textit{runtime}, whether an object has the required methods/properties when they are actually used. 

  We will start by going through all the types in Python. 


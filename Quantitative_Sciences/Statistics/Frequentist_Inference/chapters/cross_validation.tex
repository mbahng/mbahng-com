\section{Cross Validation} 

  We have understood the theoretical foundations of overfitting and underfitting with the bias variance decomposition. But in practice, we don't have an ensemble of datasets; we just have one. Therefore, we don't actually know what the bias, the variance, or the noise is at all. Therefore, how do we actually \textit{know} in practice when we are underfitting or overfitting? Easy. We just split our dataset into 2 different parts: the training set and testing sets. 
  \begin{equation}
    \mathcal{D} = \mathcal{D}_{train} \sqcup \mathcal{D}_{test}
  \end{equation}
  What we usually have is a \textbf{training set} that allows us to train the model, and then to check its performance we have a \textbf{test set}. We would train the model on the training set, where we will always minimize the loss, and then we would look at the loss on the test set. Though we haven't made a testing set, since we know the true model let us just generate more data and use that as our testing set. For each model, we can calculate the optimal $\boldsymbol{\theta}$, which we will denote $\boldsymbol{\theta}^\ast$, according to the \textbf{root mean squared loss}
  \begin{equation}
    h_{\boldsymbol{\theta}^\ast} = \argmin_{h_{\boldsymbol{\theta}}} \sqrt{ \frac{1}{N} \sum_{i=1}^N \big( y^{(i)} - h_{\boldsymbol{\theta}} (\mathbf{x}^{(i)}) \big)^2 }
  \end{equation}
  where division of $N$ allows us to compare different sizes of datasets on equal footing, and the square root ensures that this is scaled correctly. Let us see how well these different order models perform on a separate set of data generated by the same function with Gaussian noise. 

  \begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{img/Degree_vs_RMS.png}
    \caption{We can see that the RMS decreases monotonically on the training error as more complex functions become more fine-tuned to the data. However, when we have a $9$th degree polynomial the RMS for the testing set dramatically increases, meaning that this model does not predict the testing set well, and performance drops. }
    \label{fig:poly_deg_vs_rms}
  \end{figure}

  Now we know that a more complex model (i.e. that captures a greater set of functions) is not necessarily the best due to overfitting. Therefore, researchers perform \textbf{cross-validation} by taking the training set $(\mathcal{X}, \mathcal{Y})$. We divide it into $S$ equal pieces 
  \begin{equation}
    \bigcup_{s=1}^S D_s = (\mathcal{X}, \mathcal{Y})
  \end{equation}
  Then, we train the model $\mathcal{M}$ on $S-1$ pieces of the data and then test it across the final piece, and do this $S$ times for every test piece, averaging its perforance across all $S$ test runs. Therefore, for every model $\mathcal{M}_k$, we must train it $S$ times, for all $K$ models, requiring $KS$ training runs. If data is particularly scarce, we set $S = N$, called the \textbf{leave-one-out} technique. Then we just choose the model with the best average test performance. 

  The following result shows that cross-validation (data splitting) leads to an estimator with risk nearly as good as the best model in the class. 


  \begin{theorem}[Gyorfi, Kohler, Krzyak, Walk (2002)]
    Let $\mathcal{M} = \{m_h\}$ be a finite class of regression estimators indexed by a parameter $h$, with $m$ being the true risk minimizer, $m_{\hat{h}}$ being the empirical risk minimizer over the whole dataset $\mathcal{D}$, and $m_{H}$ being the empirical risk minimizer over the test set $\mathcal{D}_{\mathrm{test}}$ for ordinary least squares loss. 
    \begin{align}
      m_H & = \argmin_{m_h} \frac{1}{N} \sum_{i \in \mathcal{D}_{\mathrm{test}}} (y_i - m_h(x_i))^2 \\ 
      m_{\hat{h}} & = \argmin_{m_h} \frac{1}{N} \sum_{i \in \mathcal{D}} (y_i - m_h(x_i))^2 
    \end{align}
    If the data $Y_i$ and estimators are bounded by $L$, then for any $\delta > 0$, we have 
    \begin{equation}
      \mathbb{E} \int |m_H (x) - m(x)|^2 \,d\mathbb{P}(x) \leq (1 + \delta) \mathbb{E} \int |m_{\hat{h}} (x) - m(x) |^2 \,d \mathbb{P}(x) + \frac{C (1 + \log{|M|})}{n}
    \end{equation}
    where $c = L^2 (16/\delta + 35 + 19\delta)$. 
  \end{theorem}

  \begin{code}[Minimal Example of Train Test Split in scikit-learn]
    To implement this in scikit-learn, we want to use the \texttt{train\_test\_split} class. We can also set a random state parameter to reproduce results. 
    \begin{lstlisting}
      from sklearn.model_selection import train_test_split 

      # Split into training (80\%) and test (20\%) data 
      X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=66)
    \end{lstlisting}
  \end{code}

  However, this process requires a lot of training runs and therefore may be computationally infeasible. Therefore, various \textbf{information criterion} has been proposed to efficiently select a model. 

\subsection{Leave 1 Out Cross Validation} 

  \subsubsection{Generalized (Approximate) Cross Validation} 

  \subsubsection{Cp Statistic}

\subsection{K Fold Cross Validation}


<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <title id="page-title">Literature Graph</title>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      background-color: #f5f5f5; 
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    
    .graph-container {
      position: relative;
      height: 100vh;
      width: 100vw;
      background: white;
      overflow: hidden;
    }
    
    .node { cursor: pointer; }
    .link { stroke: #999; stroke-opacity: 0.6; }
    text { font-family: Arial, sans-serif; font-size: 12px; pointer-events: none; fill: #000; }
    .arrowhead { fill: #000; }
    
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      text-align: center;
    }
    
    .info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      font-size: 12px;
      color: #666;
      max-width: 200px;
    }
    
    .legend-dropdown {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      font-size: 12px;
      color: #666;
      min-width: 200px;
      max-width: 350px;
    }
    
    .search-box {
      position: absolute;
      top: 20px;
      right: 230px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 10px;
      min-width: 200px;
    }
    
    .search-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s;
    }
    
    .search-input:focus {
      border-color: #007bff;
    }
    
    .search-results {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 8px;
      border: 1px solid #eee;
      border-radius: 4px;
      background: white;
      display: none;
    }
    
    .search-result-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f5f5f5;
      font-size: 12px;
    }
    
    .search-result-item:hover {
      background: #f8f9fa;
    }
    
    .search-result-item:last-child {
      border-bottom: none;
    }
    
    .search-result-title {
      font-weight: bold;
      color: #333;
    }
    
    .search-result-tags {
      color: #666;
      font-size: 11px;
      margin-top: 2px;
    }
    
    .legend-header {
      padding: 10px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 8px;
      transition: background-color 0.2s;
    }
    
    .legend-header:hover {
      background: rgba(240, 240, 240, 0.5);
    }
    
    .legend-title {
      font-weight: bold;
      font-size: 14px;
      color: #333;
    }
    
    .dropdown-arrow {
      transition: transform 0.2s;
      font-size: 10px;
    }
    
    .dropdown-arrow.open {
      transform: rotate(180deg);
    }
    
    .legend-content {
      padding: 0 10px 10px 10px;
      max-height: 300px;
      overflow-y: auto;
      border-top: 1px solid #eee;
    }
    
    .legend-controls {
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 3px;
      justify-content: space-between;
    }
    
    .legend-tag-name {
      cursor: pointer;
      transition: color 0.2s, text-decoration 0.2s;
    }
    
    .legend-tag-name:hover {
      color: #007bff;
      text-decoration: underline;
    }
    
    .legend-tag-name.highlighted {
      color: #007bff;
      font-weight: bold;
    }
    
    .node-highlighted {
      stroke: #ff4500 !important;
      stroke-width: 1px !important;
      filter: drop-shadow(0 0 12px rgba(255, 69, 0, 0.8)) drop-shadow(0 0 24px rgba(255, 69, 0, 0.4));
      transition: opacity 0.3s ease, filter 0.3s ease;
    }
    
    /* Ensure highlighting only affects the main node elements, not children */
    .multi-tag-node.node-highlighted path {
      stroke: #ff4500 !important;
      stroke-width: 1px !important;
    }
    
    .node-dimmed {
      opacity: 0.15 !important;
      transition: opacity 0.3s ease;
    }
    
    .legend-left {
      display: flex;
      align-items: center;
    }
    
    .legend-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      border: 1px solid #ddd;
    }
    
    .legend-toggle {
      width: 30px;
      height: 16px;
      background-color: #ccc;
      border-radius: 8px;
      position: relative;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .legend-toggle.active {
      background-color: #4CAF50;
    }
    
    .legend-toggle::after {
      content: '';
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: white;
      top: 2px;
      left: 2px;
      transition: transform 0.3s;
    }
    
    .legend-toggle.active::after {
      transform: translateX(14px);
    }
    
    /* Markdown viewer modal */
    .markdown-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      display: none;
    }
    .markdown-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      width: 95%;
      max-width: none;
      height: 95%;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .markdown-header {
      padding: 15px 20px;
      border-bottom: 1px solid #eee;
      background: #f8f9fa;
      border-radius: 8px 8px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .markdown-title {
      font-size: 18px;
      font-weight: bold;
      margin: 0;
      color: #333;
    }
    .close-btn {
      background: #ff4757;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .close-btn:hover {
      background: #ff3838;
    }
    .markdown-body {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      line-height: 1.6;
    }
    /* Markdown styling */
    .markdown-body h1, .markdown-body h2, .markdown-body h3 {
      color: #333;
      margin-top: 24px;
      margin-bottom: 12px;
    }
    .markdown-body h1 {
      font-size: 24px;
      border-bottom: 2px solid #eee;
      padding-bottom: 8px;
    }
    .markdown-body h2 {
      font-size: 20px;
    }
    .markdown-body h3 {
      font-size: 16px;
    }
    .markdown-body p {
      margin-bottom: 12px;
      color: #555;
    }
    .markdown-body code {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    .markdown-body pre {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      border-left: 4px solid #007bff;
    }
    .markdown-body blockquote {
      border-left: 4px solid #ddd;
      margin: 0;
      padding-left: 16px;
      color: #666;
      font-style: italic;
    }
    .markdown-body ul, .markdown-body ol {
      padding-left: 20px;
      margin-bottom: 12px;
    }
    .markdown-body li {
      margin-bottom: 4px;
    }
    .markdown-body a {
      color: #007bff;
      text-decoration: none;
    }
    .markdown-body a:hover {
      text-decoration: underline;
    }
    .markdown-body img {
      display: block;
      margin: 0 auto;
      max-width: 50%;
      height: auto;
    }
    /* PDF link styling */
    .markdown-body .pdf-link {
      display: inline-block;
      background: #ff6b6b;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      text-decoration: none;
      font-size: 12px;
      font-weight: bold;
      margin: 2px;
    }
    .markdown-body .pdf-link:hover {
      background: #ff5252;
      text-decoration: none;
    }
    .markdown-body .pdf-link::before {
      content: "ðŸ“„ ";
    }
    /* MathJax styling */
    .markdown-body .MathJax {
      font-size: 1em !important;
    }
    .markdown-body .MathJax_Display {
      margin: 1em 0 !important;
    }
    
    /* Tooltip styling */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-size: 12px;
      max-width: 300px;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .tooltip.visible {
      opacity: 1;
    }
    
    .tooltip-title {
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 13px;
    }
    
    .tooltip-tags {
      margin-bottom: 8px;
    }
    
    .tooltip-tag {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 3px;
      margin-right: 4px;
      margin-bottom: 2px;
      font-size: 11px;
    }
    
    .tooltip-contribution {
      border-top: 1px solid rgba(255, 255, 255, 0.3);
      padding-top: 5px;
      font-size: 11px;
      line-height: 1.3;
    }
    
    .tooltip-contribution-title {
      font-weight: bold;
      margin-bottom: 3px;
    }
    
    /* Hierarchical legend styles */
    .legend-category {
      margin-bottom: 4px;
    }
    
    .legend-left {
      display: flex;
      align-items: center;
      flex: 1;
    }
    
    .subcategory-indent {
      font-family: monospace;
      color: #999;
      margin-right: 4px;
      min-width: fit-content;
    }
    
    .category-arrow {
      margin-right: 4px;
      user-select: none;
      min-width: 12px;
      text-align: center;
    }
    
    .category-arrow.expandable {
      cursor: pointer;
    }
    
    .category-arrow.placeholder {
      cursor: default;
    }
    
    .legend-color {
      margin-right: 6px;
    }
    
    .legend-category-empty {
      /* Removed opacity to keep all categories visible and black */
    }
    
    .legend-category-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 3px 0;
      cursor: pointer;
      border-radius: 3px;
      transition: background-color 0.2s;
    }
    
    .legend-category-header:hover {
      background-color: rgba(240, 240, 240, 0.5);
    }
    
    .category-arrow {
      display: inline-block;
      width: 16px;
      text-align: center;
      font-size: 10px;
      margin-right: 4px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .category-arrow.expandable:hover {
      transform: scale(1.2);
    }
    
    .legend-top-level {
      font-weight: bold;
      font-size: 13px;
    }
    
    .legend-subcategories {
      margin-left: 20px;
      border-left: 1px solid #eee;
      padding-left: 8px;
      margin-top: 2px;
    }
    
    .legend-subcategory {
      margin-bottom: 2px;
      font-size: 11px;
    }
    
    .subcategory-indent {
      color: #999;
      font-size: 10px;
      margin-right: 4px;
      width: 12px;
      display: inline-block;
    }
    
    .hierarchy-item {
      border-bottom: 1px solid #eee;
      padding-bottom: 4px;
      margin-bottom: 6px;
    }
    
    /* Multi-level hierarchy styles */
    .legend-level-2 {
      margin-left: 10px;
      font-size: 10px;
    }
    
    .legend-level-3 {
      margin-left: 20px;
      font-size: 9px;
    }
    
    .legend-level-4 {
      margin-left: 30px;
      font-size: 8px;
    }
  </style>
</head>
<body>
  <!-- Graph Container -->
    <div class="graph-container">
      <div class="loading" id="loading">
        <div id="loading-message">Scanning Directory...</div>
        <div style="font-size: 12px; margin-top: 10px; color: #666;">Reading index file</div>
      </div>
      
      <div class="info" id="info" style="display: none;">
        <div id="file-count">0/0 papers</div>
        <div id="connection-count">0 connections</div>
        <div style="margin-top: 5px; font-size: 10px;">
          Press on a node to remove clutter<br>
          Drag to move â€¢ Scroll to zoom<br>
          <strong>Click nodes to view content</strong>
        </div>
      </div>
      
      <!-- Search Box -->
      <div class="search-box" id="search-box" style="display: none;">
        <input type="text" class="search-input" id="search-input" placeholder="Search nodes...">
        <div class="search-results" id="search-results"></div>
      </div>
      
      <!-- Legend Dropdown -->
      <div class="legend-dropdown" id="legend" style="display: none;">
        <div class="legend-header" id="legend-header">
          <span class="legend-title">Tags</span>
          <span class="dropdown-arrow">â–¼</span>
        </div>
        <div class="legend-content" id="legend-content" style="display: none;">
          <div class="legend-controls">
            <div class="legend-item">
              <span style="font-weight: bold; font-size: 11px;">Toggle All</span>
              <div class="legend-toggle active" id="toggle-all"></div>
            </div>
          </div>
          <div class="legend-items" id="legend-items">
            <!-- Legend items will be dynamically generated -->
          </div>
        </div>
      </div>
      
      <div id="graph"></div>
    </div>
  
  <!-- Markdown viewer modal -->
  <div class="markdown-modal" id="markdownModal">
    <div class="markdown-content">
      <div class="markdown-header">
        <h2 class="markdown-title" id="markdownTitle">Document Title</h2>
        <button class="close-btn" onclick="closeMarkdownModal()">Close</button>
      </div>
      <div class="markdown-body" id="markdownBody">
        <!-- Rendered markdown content will go here -->
      </div>
    </div>
  </div>
  
  <!-- Tooltip for hover -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-title" id="tooltip-title"></div>
    <div class="tooltip-tags" id="tooltip-tags"></div>
    <div class="tooltip-contribution" id="tooltip-contribution"></div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
</body>
<script>
// MathJax configuration
window.MathJax = {
  tex: {
    inlineMath: [
      ["$", "$"], 
      ["\\(", "\\)"]
    ],
    displayMath: [
      ["$$", "$$"], 
      ["\\[", "\\]"]
    ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    skipHtmlTags: ["script", "noscript", "style", "textarea", "pre"]
  }
};
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<script>
  let nodes = [];
  let links = [];
  let simulation;
  let notesData = {};
  let tagColors = {};
  let tagVisibility = {}; // Track which tags are visible
  let highlightedTag = null; // Track currently highlighted tag
  let currentDirectory = 'statistics'; // Default directory
  
  // Function to normalize tags to lowercase with dashes
  function normalizeTag(tag) {
    return tag.toLowerCase().replace(/[\s_]+/g, '-').replace(/[^a-z0-9:-]/g, '');
  }
  
  // Function to get display name from normalized tag
  function getDisplayName(normalizedTag) {
    return normalizedTag.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }
  
  // Hierarchical tag structure - top-level categories from Statistics home.html (normalized)
  const topLevelCategories = [
    'information-theory', 'signal-processing', 'function-spaces', 'concentration-of-measure',
    'frequentist-inference', 'bayesian-inference', 'optimization', 'sampling-and-integration',
    'decision-theory', 'learning-theory', 'linear-regression', 'linear-classification',
    'time-series', 'kernels-and-smoothers', 'trees', 'ensembles', 'factors-and-components',
    'clustering', 'latent-variable-models', 'graphical-models', 'deep-learning',
    'reinforcement-learning', 'computer-vision', 'natural-language-processing', 'others'
  ];
  
  // Map normalized categories to display names
  const categoryDisplayNames = {
    'information-theory': 'Information Theory',
    'signal-processing': 'Signal Processing', 
    'function-spaces': 'Function Spaces',
    'concentration-of-measure': 'Concentration of Measure',
    'frequentist-inference': 'Frequentist Inference',
    'bayesian-inference': 'Bayesian Inference',
    'optimization': 'Optimization',
    'sampling-and-integration': 'Sampling and Integration',
    'decision-theory': 'Decision Theory',
    'learning-theory': 'Learning Theory',
    'linear-regression': 'Linear Regression',
    'linear-classification': 'Linear Classification',
    'time-series': 'Time Series',
    'kernels-and-smoothers': 'Kernels and Smoothers',
    'trees': 'Trees',
    'ensembles': 'Ensembles',
    'factors-and-components': 'Factors and Components',
    'clustering': 'Clustering',
    'latent-variable-models': 'Latent Variable Models',
    'graphical-models': 'Graphical Models',
    'deep-learning': 'Deep Learning',
    'reinforcement-learning': 'Reinforcement Learning',
    'computer-vision': 'Computer Vision',
    'natural-language-processing': 'Natural Language Processing',
    'others': 'Others'
  };
  
  let hierarchicalTags = {}; // Structure: {topLevel: {subcategories: Map, papers: []}}  
  let tagHierarchy = {}; // Maps all tags to their hierarchy path
  
  // Get directory from URL parameter
  function getCurrentDirectory() {
    const urlParams = new URLSearchParams(window.location.search);
    const dir = urlParams.get('dir');
    return dir && ['math', 'physics', 'computer_science', 'economics', 'statistics', 'quantum_computing', 'blockchain', 'virtual_augmented_reality'].includes(dir) ? dir : 'statistics';
  }
  
  // Get display name for directory
  function getDirectoryDisplayName(dir) {
    const names = {
      'math': 'Math',
      'physics': 'Physics',
      'computer_science': 'Computer Science',
      'economics': 'Economics',
      'statistics': 'Statistics',
      'quantum_computing': 'Quantum Computing', 
      'blockchain': 'Blockchain',
      'virtual_augmented_reality': 'Virtual/Augmented Reality'
    };
    return names[dir] || dir.toUpperCase();
  }
  
  // Function to convert PDF wiki-links to clickable HTML links
  function convertPdfLinks(content) {
    return content.replace(/\[\[([^|\]]+\.pdf)(?:\|([^\]]+))?\]\]/g, (match, filename, displayText) => {
      const linkText = displayText || filename.replace('.pdf', '');
      // Extract directory name from PDF filename (remove .pdf extension)
      const directoryName = filename.replace('.pdf', '');
      const pdfPath = `${currentDirectory}/${directoryName}/${filename}`;
      return `<a href="${pdfPath}" target="_blank" class="pdf-link">${linkText}</a>`;
    });
  }
  
  // Function to protect math expressions from markdown processing
  function protectMathExpressions(content) {
    const mathBlocks = [];
    let counter = 0;
    
    content = content.replace(/\$\$([\s\S]*?)\$\$/g, (match) => {
      const placeholder = `MATHBLOCK${counter}MATHBLOCK`;
      mathBlocks[counter] = match;
      counter++;
      return placeholder;
    });
    
    content = content.replace(/\$([^$\n]+?)\$/g, (match) => {
      const placeholder = `MATHBLOCK${counter}MATHBLOCK`;
      mathBlocks[counter] = match;
      counter++;
      return placeholder;
    });
    
    return { content, mathBlocks };
  }
  
  // Function to restore math expressions after markdown processing
  function restoreMathExpressions(html, mathBlocks) {
    mathBlocks.forEach((mathExpr, index) => {
      const placeholder = `MATHBLOCK${index}MATHBLOCK`;
      html = html.replace(placeholder, mathExpr);
    });
    return html;
  }
  // Function to fix image paths in markdown content
  function fixImagePaths(content, filePath) {
    const fileDir = filePath.substring(0, filePath.lastIndexOf('/') + 1);
    
    return content.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, imagePath) => {
      if (imagePath.startsWith('http') || imagePath.startsWith('/')) {
        return match;
      }
      
      let fixedPath = imagePath;
      if (!imagePath.startsWith(fileDir)) {
        if (imagePath.startsWith('./')) {
          fixedPath = fileDir + imagePath.substring(2);
        } else if (imagePath.startsWith('../')) {
          const parentDir = fileDir.substring(0, fileDir.lastIndexOf('/', fileDir.length - 2) + 1);
          fixedPath = parentDir + imagePath.substring(3);
        } else {
          fixedPath = fileDir + imagePath;
        }
      }
      
      return `![${altText}](${fixedPath})`;
    });
  }
  // Modal functions with lazy loading
  async function showMarkdownModal(nodeData) {
    const modal = document.getElementById('markdownModal');
    const title = document.getElementById('markdownTitle');
    const body = document.getElementById('markdownBody');
    
    title.textContent = nodeData.label;
    body.innerHTML = '<p>Loading content...</p>';
    modal.style.display = 'block';
    
    const noteData = notesData[nodeData.id];
    if (!noteData) {
      body.innerHTML = '<p>Content not available</p>';
      return;
    }
    
    // Load full content if not already loaded
    if (!noteData.loaded) {
      try {
        const content = await loadFullMarkdownContent(noteData.filePath);
        noteData.content = content;
        noteData.loaded = true;
      } catch (error) {
        body.innerHTML = '<p>Error loading content</p>';
        return;
      }
    }
    
    if (noteData.content) {
      let contentWithFixedPaths = fixImagePaths(noteData.content, nodeData.id);
      contentWithFixedPaths = convertPdfLinks(contentWithFixedPaths);
      
      const { content: protectedContent, mathBlocks } = protectMathExpressions(contentWithFixedPaths);
      let html = marked.parse(protectedContent);
      html = restoreMathExpressions(html, mathBlocks);
      
      body.innerHTML = html;
      
      if (window.MathJax) {
        MathJax.typesetPromise([body]).catch(function (err) {
          console.log('MathJax typeset failed: ' + err.message);
        });
      }
    } else {
      body.innerHTML = '<p>Content not available</p>';
    }
  }
  
  function closeMarkdownModal() {
    document.getElementById('markdownModal').style.display = 'none';
  }
  
  // Close modal when clicking outside or pressing Escape
  document.getElementById('markdownModal').addEventListener('click', function(e) {
    if (e.target === this) {
      closeMarkdownModal();
    }
  });
  
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      closeMarkdownModal();
      hideSearchResults();
    }
  });
  
  // Search functionality
  let searchHighlightedNode = null;
  let graphZoom = null; // Store reference to zoom behavior
  
  function searchNodes(query) {
    if (!query.trim()) return [];
    const lowerQuery = query.toLowerCase();
    return nodes.filter(node => 
      node.label.toLowerCase().includes(lowerQuery) ||
      (node.tags && node.tags.some(tag => tag.toLowerCase().includes(lowerQuery)))
    ).sort((a, b) => {
      // Sort by exact match first, then by label length
      const aLabelMatch = a.label.toLowerCase().includes(lowerQuery);
      const bLabelMatch = b.label.toLowerCase().includes(lowerQuery);
      if (aLabelMatch && !bLabelMatch) return -1;
      if (!aLabelMatch && bLabelMatch) return 1;
      return a.label.length - b.label.length;
    });
  }
  
  function showSearchResults(results) {
    const resultsDiv = document.getElementById('search-results');
    resultsDiv.innerHTML = '';
    
    if (results.length === 0) {
      resultsDiv.style.display = 'none';
      return;
    }
    
    results.slice(0, 10).forEach(node => {
      const item = document.createElement('div');
      item.className = 'search-result-item';
      item.innerHTML = `
        <div class="search-result-title">${node.label}</div>
        <div class="search-result-tags">${node.tags ? node.tags.join(', ') : 'No tags'}</div>
      `;
      item.addEventListener('click', () => {
        centerOnNode(node);
        hideSearchResults();
        document.getElementById('search-input').value = node.label;
      });
      resultsDiv.appendChild(item);
    });
    
    resultsDiv.style.display = 'block';
  }
  
  function hideSearchResults() {
    document.getElementById('search-results').style.display = 'none';
  }
  
  function centerOnNode(node) {
    if (!simulation || !node || !graphZoom) return;
    
    // Clear previous highlight
    if (searchHighlightedNode) {
      d3.selectAll('.single-tag-node, .multi-tag-node').filter(d => d === searchHighlightedNode)
        .style('stroke', d => d.tags && d.tags.length > 1 ? null : '#fff')
        .style('stroke-width', d => d.tags && d.tags.length > 1 ? null : '1.5px');
    }
    
    // Highlight the new node
    searchHighlightedNode = node;
    d3.selectAll('.single-tag-node, .multi-tag-node').filter(d => d === node)
      .style('stroke', '#ff6b35')
      .style('stroke-width', '4px');
    
    // Get the SVG dimensions
    const svg = d3.select('#graph svg');
    const width = +svg.attr('width');
    const height = +svg.attr('height');
    
    // Calculate the target transform to center the node
    const targetScale = 2.0; // Zoom level
    const targetX = width / 2 - targetScale * node.x;
    const targetY = height / 2 - targetScale * node.y;
    
    // Apply smooth animated transition using the stored zoom behavior
    svg.transition()
       .duration(1000)
       .ease(d3.easeQuadInOut)
       .call(graphZoom.transform, d3.zoomIdentity.translate(targetX, targetY).scale(targetScale));
  }
  
  // Set up search input event listeners after DOM is loaded
  function setupSearchEventListeners() {
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');
    
    if (!searchInput || !searchResults) {
      // Retry after a short delay if elements aren't ready
      setTimeout(setupSearchEventListeners, 100);
      return;
    }
    
    searchInput.addEventListener('input', function(e) {
      const query = e.target.value;
      if (query.length > 0) {
        const results = searchNodes(query);
        showSearchResults(results);
      } else {
        hideSearchResults();
        // Clear highlight when search is cleared
        if (searchHighlightedNode) {
          d3.selectAll('.single-tag-node, .multi-tag-node').filter(d => d === searchHighlightedNode)
            .style('stroke', d => d.tags && d.tags.length > 1 ? null : '#fff')
            .style('stroke-width', d => d.tags && d.tags.length > 1 ? null : '1.5px');
          searchHighlightedNode = null;
        }
      }
    });
    
    searchInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        const query = e.target.value;
        if (query.length > 0) {
          const results = searchNodes(query);
          if (results.length > 0) {
            centerOnNode(results[0]);
            hideSearchResults();
          }
        }
      } else if (e.key === 'Escape') {
        hideSearchResults();
        e.target.blur();
      }
    });
    
    // Hide search results when clicking outside
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.search-box')) {
        hideSearchResults();
      }
      
      // Clear tag highlighting when clicking outside legend
      if (!e.target.closest('.legend-dropdown') && !e.target.classList.contains('legend-tag-name')) {
        clearTagHighlight();
      }
    });
  }
  
  // Function to count annotated papers (non-gray colored nodes)
  function countAnnotatedPapers(nodes) {
    return nodes.filter(node => {
      if (node.tags && node.tags.length > 0) {
        return true; // Has tags, so it's annotated
      }
      return node.color !== '#808080'; // Check color for no-tag nodes
    }).length;
  }
  
  // Function to toggle tag visibility
  function toggleTagVisibility(tag) {
    tagVisibility[tag] = !tagVisibility[tag];
    updateGraphVisibility();
  }
  
  // Function to update graph based on tag visibility
  function updateGraphVisibility() {
    if (!simulation) return;
    
    // Filter visible nodes and links
    const visibleNodes = nodes.filter(getNodeVisibility);
    const visibleLinks = links.filter(link => 
      getNodeVisibility(link.source) && getNodeVisibility(link.target)
    );
    
    // Calculate dynamic force adjustments based on visible node count
    const visibleNodeCount = visibleNodes.length;
    const totalNodeCount = nodes.length;
    const visibilityRatio = visibleNodeCount / totalNodeCount;
    
    // Adjust repulsive force - less nodes need less repulsion
    const baseRepulsion = -1000;
    const adjustedRepulsion = baseRepulsion * Math.max(0.3, visibilityRatio);
    
    // Adjust link distance - fewer nodes can be closer together
    const baseLinkDistance = 500;
    const adjustedLinkDistance = baseLinkDistance * Math.max(0.5, visibilityRatio);
    
    // Update simulation with only visible nodes and links
    simulation.nodes(visibleNodes);
    simulation.force("link").links(visibleLinks);
    
    // Update forces based on visible node count
    simulation.force("charge", d3.forceManyBody().strength(d => {
      const connections = d.link_count || 0;
      return adjustedRepulsion - (connections * 100 * visibilityRatio);
    }));
    
    simulation.force("link").distance(d => {
      const sourceConnections = d.source.link_count || 0;
      const targetConnections = d.target.link_count || 0;
      const maxConnections = Math.max(sourceConnections, targetConnections);
      
      const extraDistance = Math.min(maxConnections * 100, 800) * visibilityRatio;
      return adjustedLinkDistance + extraDistance;
    });
    
    // Update collision force for better spacing with fewer nodes
    simulation.force("collision", d3.forceCollide().radius(d => {
      const nodeRadius = 20 + Math.sqrt(d.link_count || 0) * 2;
      const paddingAdjustment = Math.max(10, 30 * (1 - visibilityRatio));
      return nodeRadius + paddingAdjustment;
    }));
    
    // Update node visibility (completely hide/show elements)
    d3.selectAll('.single-tag-node, .multi-tag-node')
      .style('display', d => getNodeVisibility(d) ? 'block' : 'none');
    
    // Update text visibility
    d3.selectAll('.texts text')
      .style('display', d => getNodeVisibility(d) ? 'block' : 'none');
    
    // Update link visibility
    d3.selectAll('.link')
      .style('display', d => {
        const sourceVisible = getNodeVisibility(d.source);
        const targetVisible = getNodeVisibility(d.target);
        return (sourceVisible && targetVisible) ? 'block' : 'none';
      });
    
    // Update arrowhead visibility
    d3.selectAll('.arrowhead')
      .style('display', d => {
        const sourceVisible = getNodeVisibility(d.source);
        const targetVisible = getNodeVisibility(d.target);
        return (sourceVisible && targetVisible) ? 'block' : 'none';
      });
    
    // Restart simulation with adjusted forces
    simulation.alpha(0.5).restart();
  }
  
  // Helper function to check if a node should be visible
  function getNodeVisibility(node) {
    if (!node.tags || node.tags.length === 0) {
      return tagVisibility['no-tags'];
    }
    
    // Check visibility based on hierarchical structure
    return node.tags.some(tag => {
      // Check if the tag itself is visible
      if (tagVisibility[tag]) return true;
      
      // Check if the tag's top-level category is visible
      const hierarchy = tagHierarchy[tag];
      if (hierarchy) {
        if (tagVisibility[hierarchy.topLevel]) return true;
        
        // Check if any parent path is visible (for hierarchical tags)
        if (hierarchy.path.length > 0) {
          for (let i = 1; i <= hierarchy.fullPath.length; i++) {
            const partialPath = hierarchy.fullPath.slice(0, i).join(':');
            if (tagVisibility[partialPath]) return true;
          }
        }
      }
      
      return false;
    });
  }
  
  // Function to get the count of papers for a specific tag or category
  function getTagCount(tag) {
    let count = 0;
    
    // Count all nodes that have this tag (directly or through hierarchy)
    nodes.forEach(node => {
      if (!node.tags || node.tags.length === 0) return;
      
      // Check if node has this tag directly or through hierarchy
      const hasTag = node.tags.some(nodeTag => {
        // Direct match
        if (nodeTag === tag || nodeTag.toLowerCase() === tag.toLowerCase()) return true;
        
        // Check hierarchical matches
        const hierarchy = tagHierarchy[nodeTag];
        if (hierarchy) {
          // Match against top-level category
          if (hierarchy.topLevel === tag) return true;
          
          // Match against any level of the hierarchy path
          for (let i = 1; i <= hierarchy.fullPath.length; i++) {
            const partialPath = hierarchy.fullPath.slice(0, i).join(':');
            if (partialPath === tag) return true;
          }
        }
        
        return false;
      });
      
      if (hasTag) {
        count++;
      }
    });
    
    return count;
  }
  
  // Function to get the count of papers with no tags
  function getNoTagsCount() {
    return nodes.filter(node => !node.tags || node.tags.length === 0).length;
  }
  
  // Function to toggle all tags on/off
  function toggleAllTags() {
    const toggleAllBtn = document.getElementById('toggle-all');
    const isCurrentlyActive = toggleAllBtn.classList.contains('active');
    
    // Set all tags to the opposite of current state
    const newState = !isCurrentlyActive;
    
    // Update toggle all button
    if (newState) {
      toggleAllBtn.classList.add('active');
    } else {
      toggleAllBtn.classList.remove('active');
    }
    
    // Update all tag visibility states
    Object.keys(tagVisibility).forEach(tag => {
      tagVisibility[tag] = newState;
    });
    
    // Update all individual toggle buttons
    document.querySelectorAll('.legend-toggle[data-tag]').forEach(toggle => {
      if (newState) {
        toggle.classList.add('active');
      } else {
        toggle.classList.remove('active');
      }
    });
    
    // Update graph visibility
    updateGraphVisibility();
  }
  
  // Function to create and populate the hierarchical legend
  function createLegend(allTags) {
    const legendContainer = document.getElementById('legend-items');
    legendContainer.innerHTML = '';
    
    // Initialize visibility for all categories and tags
    tagVisibility['no-tags'] = true;
    
    // Initialize all top-level categories as visible
    topLevelCategories.forEach(category => {
      tagVisibility[category] = true;
    });
    
    // Initialize all individual tags as visible
    allTags.forEach(tag => {
      tagVisibility[tag] = true;
    });
    
    // Add "No tags" entry for gray nodes
    const noTagItem = document.createElement('div');
    noTagItem.className = 'legend-item hierarchy-item';
    noTagItem.innerHTML = `
      <div class="legend-left">
        <div class="legend-color" style="background-color: #808080;"></div>
        <span class="legend-tag-name" data-tag="No tags">No tags [${getNoTagsCount()}]</span>
      </div>
      <div class="legend-toggle active" data-tag="no-tags"></div>
    `;
    legendContainer.appendChild(noTagItem);
    
    // Create hierarchical legend structure
    topLevelCategories.forEach(topCategory => {
      const categoryData = hierarchicalTags[topCategory];
      const hasContent = categoryData && categoryData.subcategories && categoryData.subcategories.size > 0;
      
      
      // Always show top-level categories, but dim them if they have no content
      const topLevelItem = document.createElement('div');
      topLevelItem.className = `legend-category ${hasContent ? '' : 'legend-category-empty'}`;
      
      // Create collapsible header for top-level category
      const categoryHeader = document.createElement('div');
      categoryHeader.className = 'legend-category-header';
      categoryHeader.innerHTML = `
        <div class="legend-left">
          <span class="category-arrow ${hasContent ? 'expandable' : ''}" data-category="${topCategory}">
            ${hasContent ? 'â–¶' : 'â€¢'}
          </span>
          <div class="legend-color" style="background-color: ${tagColors[topCategory] || generateCategoryColor(topCategory)};"></div>
          <span class="legend-tag-name legend-top-level" data-tag="${topCategory}">${categoryDisplayNames[topCategory] || getDisplayName(topCategory)} [${getTagCount(topCategory)}]</span>
        </div>
        <div class="legend-toggle ${tagVisibility[topCategory] ? 'active' : ''}" data-tag="${topCategory}"></div>
      `;
      
      topLevelItem.appendChild(categoryHeader);
      
      // Create subcategory container (initially hidden)
      if (hasContent) {
        const subcategoryContainer = document.createElement('div');
        subcategoryContainer.className = 'legend-subcategories';
        subcategoryContainer.style.display = 'none';
        subcategoryContainer.setAttribute('data-category', topCategory);
        
        // Recursively add nested subcategories
        renderNestedCategories(subcategoryContainer, categoryData.subcategories, [topCategory], 1);
        
        topLevelItem.appendChild(subcategoryContainer);
      }
      
      legendContainer.appendChild(topLevelItem);
    });
    
    // Add event listeners
    setupLegendEventListeners();
  }
  
  // Recursive function to render nested categories
  function renderNestedCategories(container, subcategoriesMap, pathSoFar, level) {
    subcategoriesMap.forEach((categoryData, categoryName) => {
      const currentPath = [...pathSoFar, categoryName];
      const fullTag = currentPath.join(':');
      const hasNestedContent = categoryData.subcategories.size > 0;
      
      const subItem = document.createElement('div');
      subItem.className = `legend-item legend-subcategory legend-level-${level}`;
      
      // Create indentation based on level
      const indent = '  '.repeat(level - 1) + 'â””';
      
      subItem.innerHTML = `
        <div class="legend-left">
          <div class="subcategory-indent">${indent}</div>
          <span class="category-arrow ${hasNestedContent ? 'expandable' : 'placeholder'}" ${hasNestedContent ? `data-category="${fullTag}"` : ''}>${hasNestedContent ? 'â–¶' : ''}</span>
          <div class="legend-color" style="background-color: ${getTagColor(fullTag, currentPath)};"></div>
          <span class="legend-tag-name" data-tag="${fullTag}">${getDisplayName(categoryName)} [${getTagCount(fullTag)}]</span>
        </div>
        <div class="legend-toggle ${tagVisibility[fullTag] ? 'active' : ''}" data-tag="${fullTag}"></div>
      `;
      
      container.appendChild(subItem);
      
      // If there are nested subcategories, add them
      if (hasNestedContent) {
        const nestedContainer = document.createElement('div');
        nestedContainer.className = 'legend-subcategories';
        nestedContainer.style.display = 'none';
        nestedContainer.setAttribute('data-category', fullTag);
        
        renderNestedCategories(nestedContainer, categoryData.subcategories, currentPath, level + 1);
        container.appendChild(nestedContainer);
      }
    });
  }
  
  // Helper function to get color for a tag based on its hierarchy
  function getTagColor(fullTag, pathArray) {
    // Try exact match first
    if (tagColors[fullTag]) return tagColors[fullTag];
    
    // Try hierarchy lookup
    const hierarchy = tagHierarchy[fullTag];
    if (hierarchy && tagColors[hierarchy.topLevel]) {
      // Generate variation based on depth
      const depth = pathArray.length - 1;
      const topLevelIndex = topLevelCategories.indexOf(hierarchy.topLevel);
      const baseHue = (topLevelIndex * 25) % 360;
      const depthVariation = depth * 20;
      const lightnessVariation = Math.min(depth * 10, 30);
      
      return `hsl(${(baseHue + depthVariation) % 360}, ${Math.max(45 - depth * 5, 25)}%, ${Math.min(65 + lightnessVariation, 85)}%)`;
    }
    
    // Fallback
    return generateSubcategoryColor(pathArray[0]);
  }
  
  // Generate colors for categories
  function generateCategoryColor(category) {
    const normalizedCategory = normalizeTag(category);
    const index = topLevelCategories.indexOf(normalizedCategory);
    const hue = (index >= 0 ? index * 25 : Math.abs(normalizedCategory.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) * 137.508) % 360;
    return `hsl(${hue}, 65%, 55%)`;
  }
  
  function generateSubcategoryColor(topCategory) {
    const normalizedTopCategory = normalizeTag(topCategory);
    const index = topLevelCategories.indexOf(normalizedTopCategory);
    const hue = (index >= 0 ? index * 25 : Math.abs(normalizedTopCategory.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) * 137.508) % 360;
    return `hsl(${hue}, 45%, 70%)`;
  }
  
  // Function to isolate a specific tag (turn off all others)
  function isolateTag(targetTag) {
    // Turn off all tags except the target
    Object.keys(tagVisibility).forEach(tag => {
      tagVisibility[tag] = (tag === targetTag);
    });
    
    // Update all toggle buttons to reflect new state
    document.querySelectorAll('.legend-toggle[data-tag]').forEach(toggle => {
      const tag = toggle.getAttribute('data-tag');
      if (tag === targetTag) {
        toggle.classList.add('active');
      } else {
        toggle.classList.remove('active');
      }
    });
    
    // Update toggle all button (should be inactive since not all are on)
    const toggleAllBtn = document.getElementById('toggle-all');
    toggleAllBtn.classList.remove('active');
    
    // Update graph visibility
    updateGraphVisibility();
  }

  // Setup all legend event listeners
  function setupLegendEventListeners() {
    // Toggle visibility event listeners
    document.querySelectorAll('.legend-toggle[data-tag]').forEach(toggle => {
      toggle.addEventListener('click', function(e) {
        e.stopPropagation();
        const tag = this.getAttribute('data-tag');
        this.classList.toggle('active');
        toggleTagVisibility(tag);
      });
      
      // Right-click to isolate this tag
      toggle.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const tag = this.getAttribute('data-tag');
        isolateTag(tag);
      });
    });
    
    // Highlight event listeners
    document.querySelectorAll('.legend-tag-name').forEach(tagName => {
      tagName.addEventListener('click', function(e) {
        e.stopPropagation();
        const tag = this.getAttribute('data-tag');
        highlightNodesWithTag(tag);
      });
      
      // Right-click to isolate this tag
      tagName.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const tag = this.getAttribute('data-tag');
        isolateTag(tag);
      });
    });
    
    // Category expansion event listeners
    document.querySelectorAll('.category-arrow.expandable').forEach(arrow => {
      arrow.addEventListener('click', function(e) {
        e.stopPropagation();
        const category = this.getAttribute('data-category');
        toggleCategoryExpansion(category);
      });
    });
    
    // Top-level category header click listeners
    document.querySelectorAll('.legend-category-header').forEach(header => {
      header.addEventListener('click', function(e) {
        const arrow = this.querySelector('.category-arrow.expandable');
        if (arrow) {
          const category = arrow.getAttribute('data-category');
          toggleCategoryExpansion(category);
        }
      });
    });
    
    // Toggle all button
    document.getElementById('toggle-all').addEventListener('click', toggleAllTags);
    
    // Dropdown header
    document.getElementById('legend-header').addEventListener('click', toggleLegendDropdown);
  }
  
  // Toggle category expansion
  function toggleCategoryExpansion(category) {
    const arrow = document.querySelector(`[data-category="${category}"].category-arrow`);
    const subcategories = document.querySelector(`.legend-subcategories[data-category="${category}"]`);
    
    if (subcategories) {
      const isExpanded = subcategories.style.display !== 'none';
      subcategories.style.display = isExpanded ? 'none' : 'block';
      arrow.textContent = isExpanded ? 'â–¶' : 'â–¼';
    }
  }
  
  // Function to toggle legend dropdown
  function toggleLegendDropdown() {
    const content = document.getElementById('legend-content');
    const arrow = document.querySelector('.dropdown-arrow');
    
    if (content.style.display === 'none') {
      content.style.display = 'block';
      arrow.classList.add('open');
    } else {
      content.style.display = 'none';
      arrow.classList.remove('open');
    }
  }
  
  // Function to highlight nodes with a specific tag
  function highlightNodesWithTag(tag) {
    if (highlightedTag === tag) {
      // If the same tag is clicked again, clear the highlight
      clearTagHighlight();
      return;
    }
    
    // Clear previous highlights completely first
    clearTagHighlight();
    
    // Set the new highlighted tag
    highlightedTag = tag;
    
    // Highlight the clicked tag in the legend
    d3.selectAll('.legend-tag-name').filter(function() {
      return this.getAttribute('data-tag') === tag || this.textContent === tag;
    }).classed('highlighted', true);
    
    // Highlight nodes with the selected tag
    d3.selectAll('.single-tag-node, .multi-tag-node').each(function(d) {
      let hasTag = false;
      
      if (tag === 'No tags') {
        hasTag = !d.tags || d.tags.length === 0;
      } else {
        // Check if node has this tag directly
        if (d.tags) {
          hasTag = d.tags.some(nodeTag => {
            // Direct match
            if (nodeTag === tag || nodeTag.toLowerCase() === tag.toLowerCase()) return true;
            
            // Check hierarchical matches
            const hierarchy = tagHierarchy[nodeTag];
            if (hierarchy) {
              // Match against top-level category
              if (hierarchy.topLevel === tag) return true;
              
              // Match against any level of the hierarchy path
              for (let i = 1; i <= hierarchy.fullPath.length; i++) {
                const partialPath = hierarchy.fullPath.slice(0, i).join(':');
                if (partialPath === tag) return true;
              }
            }
            
            return false;
          });
        }
      }
      
      if (hasTag) {
        d3.select(this).classed('node-highlighted', true);
      } else {
        d3.select(this).classed('node-dimmed', true);
      }
    });
  }
  
  // Function to clear tag highlighting
  function clearTagHighlight() {
    highlightedTag = null;
    d3.selectAll('.single-tag-node, .multi-tag-node').classed('node-highlighted', false).classed('node-dimmed', false);
    d3.selectAll('.legend-tag-name').classed('highlighted', false);
  }
  
  // Function to reapply highlighting (useful after simulation updates)
  function reapplyHighlighting() {
    if (!highlightedTag) return;
    
    d3.selectAll('.single-tag-node, .multi-tag-node').each(function(d) {
      const hasTag = highlightedTag === 'No tags' ? 
        (!d.tags || d.tags.length === 0) : 
        (d.tags && d.tags.some(nodeTag => {
          return nodeTag === highlightedTag || nodeTag.toLowerCase() === highlightedTag.toLowerCase();
        }));
      
      if (hasTag) {
        d3.select(this).classed('node-highlighted', true).classed('node-dimmed', false);
      } else {
        d3.select(this).classed('node-highlighted', false).classed('node-dimmed', true);
      }
    });
  }
  
  async function init() {
    try {
      // Get current directory and update page
      currentDirectory = getCurrentDirectory();
      const displayName = getDirectoryDisplayName(currentDirectory);
      
      document.getElementById('page-title').textContent = `${displayName} Literature Graph`;
      document.getElementById('loading-message').textContent = `Scanning ${displayName} Directory...`;
      
      updateLoading('Reading index file...');
      const markdownFiles = await scanDirectory();
      
      if (markdownFiles.length === 0) {
        throw new Error('No markdown files found in index');
      }
      
      updateLoading(`Found ${markdownFiles.length} files, loading metadata...`);
      const { notes, links: fileLinks } = await loadMarkdownMetadata(markdownFiles);
      
      notesData = notes;
      
      updateLoading('Analyzing connections...');
      
      const allTags = collectAllTags(notes);
      tagColors = generateTagColors(allTags);
      console.log(`Found ${allTags.length} unique tags:`, allTags);
      
      const { nodes: graphNodes, edges } = generateGraphData(notes, fileLinks);
      
      nodes = graphNodes;
      links = edges;
      
      updateLoading('Creating visualization...');
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('info').style.display = 'block';
        document.getElementById('legend').style.display = 'block';
        document.getElementById('search-box').style.display = 'block';
        
        // Display paper and connection counts
        const totalCount = nodes.length;
        document.getElementById('file-count').textContent = `${totalCount} papers`;
        
        document.getElementById('connection-count').textContent = `${links.length} connections`;
        
        // Create the legend
        createLegend(allTags);
        
        createGraph();
      }, 500);
      
    } catch (error) {
      document.getElementById('loading').innerHTML = 
        '<div>Error scanning directory</div><div style="font-size: 12px; color: #999;">' + error.message + '</div>';
      console.error(error);
    }
  }
  
  function updateLoading(message) {
    const loadingDiv = document.getElementById('loading');
    loadingDiv.querySelector('div').textContent = message;
  }
  
  async function scanDirectory() {
    const indexFile = `${currentDirectory}/index_${currentDirectory}.md`;
    try {
      const response = await fetch(indexFile);
      if (response.ok) {
        const content = await response.text();
        const files = parseIndexFile(content);
        if (files.length > 0) {
          return files;
        }
      }
    } catch (e) {
      console.warn(`Could not load index file: ${indexFile}`);
    }
    return [];
  }
  
  function parseIndexFile(content) {
    const files = [];
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      if (!trimmedLine || trimmedLine.startsWith('#')) {
        continue;
      }
      
      if (trimmedLine.endsWith('.md')) {
        let filename = trimmedLine.replace(/^[-*+]\s*/, '')
                                  .replace(/^\d+\.\s*/, '')
                                  .replace(/^\[([^\]]*)\]\([^)]*\)/, '$1')
                                  .trim();
        
        if (filename && !filename.includes('/')) {
          // Extract directory name from filename (remove .md extension)
          const directoryName = filename.replace('.md', '');
          const fullPath = `${currentDirectory}/${directoryName}/${filename}`;
          if (!files.includes(fullPath)) {
            files.push(fullPath);
          }
        }
      }
    }
    
    return files.sort();
  }
  
  function extractTagsFromContent(content) {
    const lines = content.split('\n');
    if (lines.length < 2) return [];
    
    const secondLine = lines[1].trim();
    if (!secondLine) return [];
    
    const tagMatches = secondLine.match(/#[\w\s:-]+/g);
    return tagMatches ? tagMatches.map(tag => normalizeTag(tag.substring(1).trim())) : [];
  }
  
  // Function to process hierarchical tags and build hierarchy
  function processHierarchicalTags(allTags) {
    console.log('Processing', allTags.length, 'tags');
    
    // Initialize hierarchical structure
    hierarchicalTags = {};
    tagHierarchy = {};
    
    // Initialize all top-level categories (they are already normalized)
    topLevelCategories.forEach(category => {
      hierarchicalTags[category] = {
        subcategories: new Map(), // Use Map to handle nested structure
        papers: new Set()
      };
    });
    
    
    // Process each tag
    allTags.forEach(tag => {
      if (tag.includes(':')) {
        // Hierarchical format: "X:Y" or "X:Y:Z" etc.
        const parts = tag.split(':').map(part => part.trim());
        const topLevelPart = parts[0];
        
        // Normalize the first part and try to match to a top-level category
        const normalizedTopLevel = normalizeTag(topLevelPart);
        const matchedTopLevel = findMatchingTopLevel(normalizedTopLevel);
        
        if (matchedTopLevel) {
          const topLevel = matchedTopLevel;
          const hierarchyPath = parts.slice(1).map(part => normalizeTag(part)); // Normalize each part
          
          // Store the full hierarchy path
          tagHierarchy[tag] = {
            topLevel: topLevel,
            path: hierarchyPath,
            fullPath: [topLevel, ...hierarchyPath]
          };
          
          // Ensure top-level category exists before accessing
          if (!hierarchicalTags[topLevel]) {
            console.warn(`Top-level category "${topLevel}" not found, creating it`);
            hierarchicalTags[topLevel] = {
              subcategories: new Map(),
              papers: new Set()
            };
          }
          
          // Build nested structure in hierarchicalTags
          addToHierarchy(hierarchicalTags[topLevel].subcategories, hierarchyPath);
          
        } else {
          // If first part doesn't match, treat entire tag as subcategory of "Others"
          const normalizedTag = normalizeTag(tag);
          tagHierarchy[tag] = {
            topLevel: 'others',
            path: [normalizedTag],
            fullPath: ['others', normalizedTag]
          };
          
          // Ensure "others" category exists
          if (!hierarchicalTags['others']) {
            hierarchicalTags['others'] = {
              subcategories: new Map(),
              papers: new Set()
            };
          }
          
          addToHierarchy(hierarchicalTags['others'].subcategories, [normalizedTag]);
        }
      } else {
        // Simple tag - try to match to top-level categories (already normalized)
        const matchedTopLevel = findMatchingTopLevel(tag);
        
        if (matchedTopLevel) {
          tagHierarchy[tag] = {
            topLevel: matchedTopLevel,
            path: [],
            fullPath: [matchedTopLevel]
          };
          
          // Ensure the matched top-level category exists in hierarchicalTags
          if (!hierarchicalTags[matchedTopLevel]) {
            console.warn(`Matched top-level category "${matchedTopLevel}" not found, creating it`);
            hierarchicalTags[matchedTopLevel] = {
              subcategories: new Map(),
              papers: new Set()
            };
          }
          
          // For simple tags that match top-level categories, we don't add them as subcategories
          // They are just assigned to the top-level category directly
        } else {
          // Assign to "others" as subcategory
          tagHierarchy[tag] = {
            topLevel: 'others',
            path: [tag],
            fullPath: ['others', tag]
          };
          
          // Ensure "others" category exists
          if (!hierarchicalTags['others']) {
            hierarchicalTags['others'] = {
              subcategories: new Map(),
              papers: new Set()
            };
          }
          
          addToHierarchy(hierarchicalTags['others'].subcategories, [tag]);
        }
      }
    });
    
    console.log('Processed hierarchy for', Object.keys(tagHierarchy).length, 'tags');
  }
  
  // Helper function to find matching top-level category
  function findMatchingTopLevel(normalizedTag) {
    // Direct match (since both are normalized)
    if (topLevelCategories.includes(normalizedTag)) {
      return normalizedTag;
    }
    
    // Only allow exact matches - no partial word matching
    return null;
  }
  
  // Helper function to add hierarchical paths to nested Map structure
  function addToHierarchy(subcategoriesMap, path) {
    if (!subcategoriesMap) {
      console.error('subcategoriesMap is undefined!', subcategoriesMap);
      return;
    }
    
    if (path.length === 0) return;
    
    const currentLevel = path[0];
    const remainingPath = path.slice(1);
    
    if (!subcategoriesMap.has(currentLevel)) {
      subcategoriesMap.set(currentLevel, {
        subcategories: new Map(),
        papers: new Set()
      });
    }
    
    if (remainingPath.length > 0) {
      addToHierarchy(subcategoriesMap.get(currentLevel).subcategories, remainingPath);
    }
  }
  
  function extractContributionFromContent(content) {
    const lines = content.split('\n');
    const contributionSection = [];
    let inContribution = false;
    let contributionStarted = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Look for "Contribution" or "Our Contribution" headers
      if (line.match(/^#{1,3}\s*(Our\s+)?Contribution/i)) {
        inContribution = true;
        contributionStarted = true;
        continue;
      }
      
      // Stop at the next header of equal or higher level
      if (contributionStarted && line.match(/^#{1,3}\s+/)) {
        break;
      }
      
      // Collect content under the contribution section
      if (inContribution && line) {
        contributionSection.push(line);
      }
    }
    
    return contributionSection.join(' ').trim();
  }
  
  // Tooltip functions
  function showTooltip(event, nodeData) {
    const tooltip = document.getElementById('tooltip');
    const tooltipTitle = document.getElementById('tooltip-title');
    const tooltipTags = document.getElementById('tooltip-tags');
    const tooltipContribution = document.getElementById('tooltip-contribution');
    
    // Set title
    tooltipTitle.textContent = nodeData.label;
    
    // Set tags
    tooltipTags.innerHTML = '';
    if (nodeData.tags && nodeData.tags.length > 0) {
      nodeData.tags.forEach(tag => {
        const tagSpan = document.createElement('span');
        tagSpan.className = 'tooltip-tag';
        tagSpan.textContent = tag;
        tooltipTags.appendChild(tagSpan);
      });
    } else {
      tooltipTags.innerHTML = '<span class="tooltip-tag">No tags</span>';
    }
    
    // Set contribution (only if content is already loaded)
    tooltipContribution.innerHTML = '';
    const noteContent = notesData[nodeData.id];
    if (noteContent && noteContent.loaded && noteContent.content) {
      const contribution = extractContributionFromContent(noteContent.content);
      if (contribution) {
        const contributionTitle = document.createElement('div');
        contributionTitle.className = 'tooltip-contribution-title';
        contributionTitle.textContent = 'Contribution:';
        tooltipContribution.appendChild(contributionTitle);
        
        const contributionText = document.createElement('div');
        contributionText.textContent = contribution.substring(0, 200) + (contribution.length > 200 ? '...' : '');
        tooltipContribution.appendChild(contributionText);
      }
    } else if (noteContent && !noteContent.loaded) {
      tooltipContribution.innerHTML = '<div style="font-style: italic;">Click to load content</div>';
    }
    
    // Position tooltip
    const rect = event.target.getBoundingClientRect();
    tooltip.style.left = (event.pageX + 10) + 'px';
    tooltip.style.top = (event.pageY - 10) + 'px';
    
    // Show tooltip
    tooltip.classList.add('visible');
  }
  
  function hideTooltip() {
    const tooltip = document.getElementById('tooltip');
    tooltip.classList.remove('visible');
  }
  
  function generateTagColors(allTags) {
    const tagColorMap = {};
    
    // First, generate colors for top-level categories
    topLevelCategories.forEach((category, index) => {
      const hue = (index * 25) % 360;
      tagColorMap[category] = `hsl(${hue}, 65%, 55%)`;
    });
    
    // Then generate colors for individual tags
    allTags.forEach((tag, index) => {
      if (!tagColorMap[tag]) {
        // Check if this tag belongs to a hierarchical structure
        const hierarchy = tagHierarchy[tag];
        if (hierarchy) {
          const topLevelIndex = topLevelCategories.indexOf(hierarchy.topLevel);
          if (topLevelIndex >= 0) {
            const baseHue = (topLevelIndex * 25) % 360;
            // Create variations based on hierarchy depth
            const depth = hierarchy.path.length;
            const depthVariation = depth * 20;
            const lightnessVariation = Math.min(depth * 10, 30);
            
            tagColorMap[tag] = `hsl(${(baseHue + depthVariation) % 360}, ${Math.max(55 - depth * 5, 30)}%, ${Math.min(65 + lightnessVariation, 80)}%)`;
          } else {
            // Fallback color
            const hue = (index * 137.508) % 360;
            tagColorMap[tag] = `hsl(${hue}, 60%, 60%)`;
          }
        } else {
          // Standard color generation for non-hierarchical tags
          const hue = (index * 137.508) % 360;
          const saturation = 60 + (index % 3) * 15;
          const lightness = 45 + (index % 4) * 10;
          tagColorMap[tag] = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
      }
    });
    
    return tagColorMap;
  }
  
  function collectAllTags(notes) {
    const allTags = new Set();
    
    Object.values(notes).forEach(note => {
      if (note.tags && note.tags.length > 0) {
        note.tags.forEach(tag => allTags.add(tag));
      }
    });
    
    const tagArray = Array.from(allTags).sort();
    
    // Process hierarchical tags
    processHierarchicalTags(tagArray);
    
    return tagArray;
  }
  
  function getColorForTags(tags) {
    if (!tags || tags.length === 0) {
      return '#808080';
    }
    
    // For single tag, return solid color
    if (tags.length === 1) {
      const tag = tags[0];
      // Try exact match first
      if (tagColors[tag]) return tagColors[tag];
      
      // Try hierarchical lookup
      const hierarchy = tagHierarchy[tag];
      if (hierarchy && tagColors[hierarchy.topLevel]) {
        return tagColors[hierarchy.topLevel];
      }
      
      // Fallback
      return tagColors[tag.toLowerCase()] || '#96CEB4';
    }
    
    // For multiple tags, create a gradient
    const colors = tags.slice(0, 4).map(tag => {
      if (tagColors[tag]) return tagColors[tag];
      
      const hierarchy = tagHierarchy[tag];
      if (hierarchy && tagColors[hierarchy.topLevel]) {
        return tagColors[hierarchy.topLevel];
      }
      
      return tagColors[tag.toLowerCase()] || '#96CEB4';
    });
    
    return createGradientId(colors);
  }
  
  function createGradientId(colors) {
    // Convert HSL colors to simple hex-like IDs by hashing
    const colorHash = colors.map(c => {
      if (c.startsWith('hsl')) {
        // Extract hue value from hsl string and convert to simple hash
        const hueMatch = c.match(/hsl\((\d+(?:\.\d+)?)/);
        const hue = hueMatch ? Math.round(parseFloat(hueMatch[1])) : 0;
        return hue.toString(16).padStart(3, '0');
      }
      return c.replace('#', '');
    }).join('');
    
    const patternId = `pie${colorHash}`;
    return `url(#${patternId})`;
  }
  
  function createMultiTagNode(g, nodeData, radius) {
    const colors = nodeData.tags.slice(0, 4).map(tag => tagColors[tag.toLowerCase()] || '#96CEB4');
    
    const nodeGroup = g.append('g')
      .attr('class', 'multi-tag-node')
      .datum(nodeData);
    
    colors.forEach((color, index) => {
      const startAngle = (index * 360) / colors.length - 90; // Start from top
      const endAngle = ((index + 1) * 360) / colors.length - 90;
      
      const startAngleRad = (startAngle * Math.PI) / 180;
      const endAngleRad = (endAngle * Math.PI) / 180;
      
      const x1 = radius * Math.cos(startAngleRad);
      const y1 = radius * Math.sin(startAngleRad);
      const x2 = radius * Math.cos(endAngleRad);
      const y2 = radius * Math.sin(endAngleRad);
      
      const largeArcFlag = endAngle - startAngle > 180 ? 1 : 0;
      
      const pathData = [
        `M 0 0`,
        `L ${x1} ${y1}`,
        `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
        'Z'
      ].join(' ');
      
      nodeGroup.append('path')
        .attr('d', pathData)
        .attr('fill', color)
        .attr('stroke', '#fff')
        .attr('stroke-width', index === 0 ? 1.5 : 0); // Only stroke the first slice to avoid overlapping strokes
    });
    
    return nodeGroup;
  }
  
  function createGradients(svg, nodes) {
    const defs = svg.select('defs');
    const gradientMap = new Map();
    
    nodes.forEach(node => {
      if (node.tags && node.tags.length > 1) {
        const colors = node.tags.slice(0, 4).map(tag => tagColors[tag.toLowerCase()] || '#96CEB4');
        
        // Use the same ID generation logic as createGradientId
        const colorHash = colors.map(c => {
          if (c.startsWith('hsl')) {
            const hueMatch = c.match(/hsl\((\d+(?:\.\d+)?)/);
            const hue = hueMatch ? Math.round(parseFloat(hueMatch[1])) : 0;
            return hue.toString(16).padStart(3, '0');
          }
          return c.replace('#', '');
        }).join('');
        
        const patternId = `pie${colorHash}`;
        
        if (!gradientMap.has(patternId)) {
          gradientMap.set(patternId, colors);
          createPieSlicePattern(svg, colors, patternId);
        }
      }
    });
  }
  
  // Fast metadata loading - only loads first few lines for tags and basic links
  async function loadMarkdownMetadata(filePaths) {
    const notes = {};
    const links = {};
    let loaded = 0;
    
    // Load files in parallel batches of 10
    const batchSize = 10;
    for (let i = 0; i < filePaths.length; i += batchSize) {
      const batch = filePaths.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (filePath) => {
        try {
          const response = await fetch(filePath);
          if (!response.ok) {
            console.warn(`Could not load ${filePath}: ${response.status}`);
            return;
          }
          
          const content = await response.text();
          const fileName = filePath.toLowerCase();
          
          // Extract only first 500 characters for tags and basic links
          const preview = content.substring(0, 500);
          const tags = extractTagsFromContent(preview);
          
          notes[fileName] = {
            content: null, // Will be loaded lazily when needed
            html: null,
            tags: tags,
            filePath: filePath,
            loaded: false
          };
          
          // Extract basic links from preview
          links[fileName] = [];
          const linkPatterns = [
            /\[\[(.*?)\]\]/g,
            /\[([^\]]+)\]\(([^)]+)\)/g,
            /!\[\[(.*?)\]\]/g
          ];
          
          for (const pattern of linkPatterns) {
            let match;
            while ((match = pattern.exec(preview)) !== null) {
              let link = match[1];
              link = link.split('|')[0];
              link = link.split('#')[0];
              link = link.trim().toLowerCase();
              if (link) {
                links[fileName].push(link);
              }
            }
          }
          
          // Increment and update loading message for each file
          loaded++;
          updateLoading(`Loaded metadata ${loaded}/${filePaths.length} files...`);
          
        } catch (error) {
          console.warn(`Error loading ${filePath}:`, error);
        }
      }));
      
      await new Promise(resolve => setTimeout(resolve, 1));
    }
    
    return { notes, links };
  }

  // Full file loading function for when content is actually needed
  async function loadFullMarkdownContent(filePath) {
    try {
      const response = await fetch(filePath);
      if (!response.ok) {
        throw new Error(`Failed to load: ${response.status}`);
      }
      
      const content = await response.text();
      return content;
    } catch (error) {
      console.warn(`Error loading full content for ${filePath}:`, error);
      return '';
    }
  }
  
  function generateGraphData(notes, links) {
    function getNodeDisplayName(filePath) {
      // Extract filename from path like "statistics/2013srivastava_dropout/2013srivastava_dropout.md"
      const fileName = filePath.split('/').pop().replace('.md', '');
      
      if (fileName.toLowerCase() === 'readme') return 'README';
      
      const match = fileName.match(/^(\d{4})([^_]+)_(.+)$/);
      if (match) {
        const [, year, author, titlePart] = match;
        const title = titlePart.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const authorName = author.charAt(0).toUpperCase() + author.slice(1);
        return `${title} (${authorName}, ${year})`;
      }
      
      const cleaned = fileName.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      return cleaned;
    }
    
    const nodes = Object.keys(notes).map(note => ({
      id: note,
      label: getNodeDisplayName(note),
      tags: notes[note].tags
    }));
    
    const edges = [];
    const nodeLinkCount = {};
    
    Object.keys(notes).forEach(note => {
      nodeLinkCount[note] = 0;
    });
    
    for (const [src, dstList] of Object.entries(links)) {
      for (const dst of dstList) {
        const potentialTargets = [
          dst,
          dst + '.md',
          `${currentDirectory}/` + dst.replace('.md', '') + '/' + dst,
          `${currentDirectory}/` + dst.replace('.md', '') + '/' + dst + '.md'
        ];
        
        let matched = false;
        for (const target of potentialTargets) {
          if (notes[target.toLowerCase()]) {
            edges.push({ source: src, target: target.toLowerCase() });
            nodeLinkCount[src] += 1;
            nodeLinkCount[target.toLowerCase()] += 1;
            matched = true;
            break;
          }
        }
      }
    }
    
    nodes.forEach(node => {
      node.link_count = nodeLinkCount[node.id] || 0;
      // Don't set color here for multi-tag nodes, we'll handle it in the graph creation
      if (!node.tags || node.tags.length <= 1) {
        node.color = getColorForTags(node.tags);
      }
    });
    
    return { nodes, edges };
  }
  
  function createGraph() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    const svg = d3.select("#graph")
      .append("svg")
      .attr("width", width)
      .attr("height", height);
    
    const g = svg.append("g");
    
    const defs = svg.append("defs");
    
    // Remove old marker definition since we're using direct polygons
    
    // No need to create patterns anymore - multi-tag nodes are created directly
    
    graphZoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on("zoom", zoomed);
    
    svg.call(graphZoom);
    
    function zoomed() {
      g.attr("transform", d3.event.transform);
    }
    
    simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(d => {
        // Dynamic distance based on connectivity of both nodes
        const sourceConnections = d.source.link_count || 0;
        const targetConnections = d.target.link_count || 0;
        const maxConnections = Math.max(sourceConnections, targetConnections);
        
        // Base distance + extra distance for highly connected nodes
        const baseDistance = 500;
        const extraDistance = Math.min(maxConnections * 100, 800); // Cap at 800 extra
        
        return baseDistance + extraDistance;
      }))
      .force("charge", d3.forceManyBody().strength(d => {
        // Stronger repulsion for highly connected nodes
        const connections = d.link_count || 0;
        return -1000 - (connections * 100);
      }))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collision", d3.forceCollide().radius(d => {
        // Collision radius based on node size + padding
        const nodeRadius = 20 + Math.sqrt(d.link_count || 0) * 2;
        return nodeRadius + 10; // Add 10px padding
      }))
      .force("y", d3.forceY().y(d => {
        // Extract year from node ID (format: YYYY)
        const yearMatch = d.id.match(/(\d{4})/);
        const year = yearMatch ? parseInt(yearMatch[1]) : 2000;
        
        // Get connection count (papers with more connections are likely more recent/derived)
        const connections = d.link_count || 0;
        
        // Calculate target Y position
        // Earlier years (source papers) go to top, later years to bottom
        // Papers with fewer connections also tend towards top
        const yearFactor = (year - 1900) / (2024 - 1900); // Normalize to 0-1
        
        // Combined factor: year has more weight (0.7) than connections (0.3)
        const combinedFactor = yearFactor
        
        // Map to Y position using full height with padding
        return height * 0.05 + combinedFactor * height * 7;
      }).strength(0.1))
      .alphaDecay(0.05)
      .alphaMin(0.001)
      .on("tick", ticked);
    
    // Run simulation shorter for faster initial display
    for (let i = 0; i < 50; ++i) simulation.tick();
    
    const link = g.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(links)
      .enter().append("line")
      .attr("class", "link")
      .attr("stroke", "#000")
      .attr("stroke-opacity", 0.6)
      .on("mouseover", function(d) {
        // Highlight this edge
        d3.select(this).attr("stroke-opacity", 0.8).attr("stroke-width", 3);
        
        // Highlight connected arrowhead
        arrowheads.filter(arrow => arrow === d)
          .attr("opacity", 0.8);
        
        // Highlight connected nodes
        nodeContainer.selectAll(".single-tag-node, .multi-tag-node")
          .filter(node => node === d.source || node === d.target)
          .style("stroke", "#ff6b35")
          .style("stroke-width", "4px");
      })
      .on("mouseout", function(d) {
        // Reset edge
        d3.select(this).attr("stroke-opacity", 0.6).attr("stroke-width", 1);
        
        // Reset arrowhead
        arrowheads.filter(arrow => arrow === d)
          .attr("opacity", 0.6);
        
        // Reset nodes
        nodeContainer.selectAll(".single-tag-node, .multi-tag-node")
          .filter(node => node === d.source || node === d.target)
          .style("stroke", d => d.tags && d.tags.length > 1 ? null : "#fff")
          .style("stroke-width", d => d.tags && d.tags.length > 1 ? null : "1.5px");
      });
    
    // Create arrowheads as separate elements positioned in the middle
    const arrowheads = g.append("g")
      .attr("class", "arrowheads")
      .selectAll("polygon")
      .data(links)
      .enter().append("polygon")
      .attr("class", "arrowhead")
      .attr("fill", "#000")
      .attr("opacity", 0.6)
      .attr("points", "0,-12 24,0 0,12");
    
    // Create container for all nodes
    const nodeContainer = g.append("g").attr("class", "nodes");
    
    // Create single-tag nodes as circles
    const singleTagNodes = nodeContainer.selectAll(".single-tag-node")
      .data(nodes.filter(d => !d.tags || d.tags.length <= 1))
      .enter().append("circle")
      .attr("class", "node single-tag-node")
      .attr("r", d => 20 + Math.sqrt(d.link_count || 0) * 2)
      .attr("fill", d => d.color || getColorForTags(d.tags))
      .attr("stroke", "#fff")
      .attr("stroke-width", 1.5)
      .on("click", function(d) {
        showMarkdownModal(d);
      })
      .on("mouseover", function(d) {
        showTooltip(d3.event, d);
      })
      .on("mouseout", function(d) {
        hideTooltip();
      })
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));
    
    // Create multi-tag nodes as pie slices
    const multiTagNodeData = nodes.filter(d => d.tags && d.tags.length > 1);
    multiTagNodeData.forEach(nodeData => {
      const radius = 20 + Math.sqrt(nodeData.link_count || 0) * 2;
      const multiTagNode = createMultiTagNode(nodeContainer, nodeData, radius);
      
      multiTagNode
        .attr("class", "node multi-tag-node")
        .on("click", function(d) {
          showMarkdownModal(d);
        })
        .on("mouseover", function(d) {
          showTooltip(d3.event, d);
        })
        .on("mouseout", function(d) {
          hideTooltip();
        })
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));
    });
    
    // Combine both types for simulation
    const node = nodeContainer.selectAll(".single-tag-node, .multi-tag-node");
    
    const text = g.append("g")
      .attr("class", "texts")
      .selectAll("text")
      .data(nodes)
      .enter().append("text")
      .attr("x", 8)
      .attr("y", ".31em")
      .text(d => d.label)
      .style("font-size", "15px")
      .style("fill", "#333");
    
    function ticked() {
      link
        .each(function(d) {
          const dx = d.target.x - d.source.x;
          const dy = d.target.y - d.source.y;
          const dr = Math.sqrt(dx * dx + dy * dy);
          
          const sourceRadius = 20 + Math.sqrt(d.source.link_count || 0) * 2;
          const targetRadius = 20 + Math.sqrt(d.target.link_count || 0) * 2;
          
          const offsetX = (dx / dr) * sourceRadius;
          const offsetY = (dy / dr) * sourceRadius;
          const targetOffsetX = (dx / dr) * targetRadius;
          const targetOffsetY = (dy / dr) * targetRadius;
          
          d3.select(this)
            .attr("x1", d.source.x + offsetX)
            .attr("y1", d.source.y + offsetY)
            .attr("x2", d.target.x - targetOffsetX)
            .attr("y2", d.target.y - targetOffsetY);
        });
      
      // Position arrowheads in the middle of edges
      arrowheads
        .each(function(d) {
          const dx = d.target.x - d.source.x;
          const dy = d.target.y - d.source.y;
          const dr = Math.sqrt(dx * dx + dy * dy);
          
          // Calculate middle point
          const midX = d.source.x + dx / 2;
          const midY = d.source.y + dy / 2;
          
          // Calculate rotation angle (add 180 degrees to point in correct direction)
          const angle = Math.atan2(dy, dx) * 180 / Math.PI + 180;
          
          d3.select(this)
            .attr("transform", `translate(${midX},${midY}) rotate(${angle})`);
        });
      
      // Update single-tag nodes (circles)
      nodeContainer.selectAll(".single-tag-node")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
      
      // Update multi-tag nodes (groups)
      nodeContainer.selectAll(".multi-tag-node")
        .attr("transform", d => `translate(${d.x},${d.y})`);
      
      text
        .attr("x", d => d.x + 8)
        .attr("y", d => d.y + 4);
    }
    
    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    
    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }
    
    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
      // Reapply highlighting after drag ends
      setTimeout(reapplyHighlighting, 100);
    }
    
    // Setup search functionality
    setupSearchEventListeners();
  }
  
  window.addEventListener('resize', function() {
    if (simulation) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      d3.select("#graph svg").attr("width", width).attr("height", height);
      simulation.force("center", d3.forceCenter(width / 2, height / 2));
      simulation.alpha(0.3).restart();
    }
  });
  
  init();
</script>
</html>

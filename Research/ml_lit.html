<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ML Literature Graph</title>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      background-color: #ffffff; 
      font-family: Arial, sans-serif;
    }
    .node { cursor: move; }
    .link { stroke: #999; stroke-opacity: 0.6; }
    text { font-family: Arial, sans-serif; font-size: 12px; pointer-events: none; fill: #000; }
    .arrowhead { fill: #999; }
    svg { width: 100vw; height: 100vh; }
    
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      text-align: center;
    }
    
    .info {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      font-size: 12px;
      color: #666;
      max-width: 200px;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div>Scanning ML Directory...</div>
    <div style="font-size: 12px; margin-top: 10px; color: #666;">Reading index file</div>
  </div>
  
  <div class="info" id="info" style="display: none;">
    <div id="file-count">0 files found</div>
    <div id="connection-count">0 connections</div>
    <div style="margin-top: 5px; font-size: 10px;">
      <strong>Auto-detected from index</strong><br>
      Drag to move â€¢ Scroll to zoom
    </div>
  </div>
  
  <div id="graph"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
  
  <script>
    let nodes = [];
    let links = [];
    let simulation;
    
    let tagColors = {};
    
    async function init() {
      try {
        updateLoading('Reading index file...');
        const markdownFiles = await scanDirectory('ml/');
        
        if (markdownFiles.length === 0) {
          throw new Error('No markdown files found in index');
        }
        
        updateLoading(`Found ${markdownFiles.length} files, loading...`);
        const { notes, links: fileLinks } = await loadMarkdownFiles(markdownFiles);
        
        updateLoading('Analyzing connections...');
        
        // Collect all unique tags and generate colors
        const allTags = collectAllTags(notes);
        tagColors = generateTagColors(allTags);
        console.log(`Found ${allTags.length} unique tags:`, allTags);
        
        const { nodes: graphNodes, edges } = generateGraphData(notes, fileLinks);
        
        nodes = graphNodes;
        links = edges;
        
        updateLoading('Creating visualization...');
        setTimeout(() => {
          document.getElementById('loading').style.display = 'none';
          document.getElementById('info').style.display = 'block';
          document.getElementById('file-count').textContent = `${nodes.length} papers`;
          document.getElementById('connection-count').textContent = `${links.length} connections`;
          createGraph();
        }, 500);
        
      } catch (error) {
        document.getElementById('loading').innerHTML = 
          '<div>Error scanning directory</div><div style="font-size: 12px; color: #999;">' + error.message + '</div>';
        console.error(error);
      }
    }
    
    function updateLoading(message) {
      const loadingDiv = document.getElementById('loading');
      loadingDiv.querySelector('div').textContent = message;
    }
    
    async function scanDirectory(dirPath) {
      // Try to parse the index file to get the file list
      const indexFile = 'ml/index_ml.md';
      try {
        const response = await fetch(indexFile);
        if (response.ok) {
          const content = await response.text();
          const files = parseIndexFile(content, dirPath);
          if (files.length > 0) {
            return files;
          }
        }
      } catch (e) {
        // Index file doesn't exist, try next
      }
      // If no index file found, return empty array
      return [];
    }
    
    function parseIndexFile(content, basePath) {
      const files = [];
      
      // Parse markdown links: [text](filename.md) or [[filename]] or just filename.md
      const patterns = [
        /\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g, // [[file.md|display]] or [[file.md]]
      ];
      
      for (const pattern of patterns) {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          let filename = match[1] || match[2];
          
          // Clean up the filename
          filename = filename.trim();
          
          // Remove any pipe syntax content (everything after |)
          if (filename.includes('|')) {
            filename = filename.split('|')[0].trim();
          }
          
          // Add .md if missing
          if (!filename.endsWith('.md')) {
            filename += '.md';
          }
          
          // Skip if it looks like a URL or contains spaces (probably not a file)
          if (filename.includes('http') || filename.includes('pdf') || filename.includes('img') || filename.includes(' ')) {
            continue;
          }
          
          // Add base path if not already present
          let fullPath = filename;
          if (!fullPath.startsWith(basePath)) {
            fullPath = basePath + filename;
          }
          
          // Add to files if not already present
          if (!files.includes(fullPath)) {
            files.push(fullPath);
          }
        }
      }
      
      return files.sort();
    }
    
    function extractTagsFromContent(content) {
      const lines = content.split('\n');
      if (lines.length < 2) return [];
      
      const secondLine = lines[1].trim();
      if (!secondLine) return [];
      
      // Extract tags that start with #
      const tagMatches = secondLine.match(/#[\w-]+/g);
      return tagMatches ? tagMatches.map(tag => tag.substring(1)) : [];
    }
    
    function generateTagColors(allTags) {
      const colors = [];
      
      // Generate a diverse set of colors using HSL
      for (let i = 0; i < allTags.length; i++) {
        const hue = (i * 137.508) % 360; // Golden angle for good distribution
        const saturation = 60 + (i % 3) * 15; // Vary saturation between 60-90%
        const lightness = 45 + (i % 4) * 10;  // Vary lightness between 45-75%
        colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
      }
      
      // Create mapping from tags to colors
      const tagColorMap = {};
      allTags.forEach((tag, index) => {
        tagColorMap[tag] = colors[index];
      });
      
      return tagColorMap;
    }
    
    function generateTagColors(allTags) {
      const colors = [];
      
      // Generate a diverse set of colors using HSL
      for (let i = 0; i < allTags.length; i++) {
        const hue = (i * 137.508) % 360; // Golden angle for good distribution
        const saturation = 60 + (i % 3) * 15; // Vary saturation between 60-90%
        const lightness = 45 + (i % 4) * 10;  // Vary lightness between 45-75%
        colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
      }
      
      // Create mapping from tags to colors
      const tagColorMap = {};
      allTags.forEach((tag, index) => {
        tagColorMap[tag] = colors[index];
      });
      
      return tagColorMap;
    }
    
    function collectAllTags(notes) {
      const allTags = new Set();
      
      Object.values(notes).forEach(note => {
        if (note.tags && note.tags.length > 0) {
          note.tags.forEach(tag => allTags.add(tag.toLowerCase()));
        }
      });
      
      return Array.from(allTags).sort();
    }
    
    function getColorForTags(tags) {
      if (!tags || tags.length === 0) {
        return '#808080'; // Grey for no tags
      }
      
      // Use the first tag to determine color
      const firstTag = tags[0].toLowerCase();
      return tagColors[firstTag] || '#96CEB4'; // Default green if tag not found
    }
    
    async function loadMarkdownFiles(filePaths) {
      const notes = {};
      const links = {};
      let loaded = 0;
      
      for (const filePath of filePaths) {
        try {
          const response = await fetch(filePath);
          if (!response.ok) {
            console.warn(`Could not load ${filePath}: ${response.status}`);
            continue;
          }
          
          const content = await response.text();
          const fileName = filePath.toLowerCase();
          
          // Extract tags from the second line
          const tags = extractTagsFromContent(content);
          
          notes[fileName] = {
            content: content,
            html: marked.parse(content),
            tags: tags
          };
          
          links[fileName] = [];
          
          // Extract links using regex patterns
          const linkPatterns = [
            /\[\[(.*?)\]\]/g,           // [[link]]
            /\[([^\]]+)\]\(([^)]+)\)/g, // [text](link)  
            /!\[\[(.*?)\]\]/g           // ![[image]]
          ];
          
          for (const pattern of linkPatterns) {
            let match;
            while ((match = pattern.exec(content)) !== null) {
              let link = match[1];
              link = link.split('|')[0];
              link = link.split('#')[0];
              link = link.trim().toLowerCase();
              if (link) {
                links[fileName].push(link);
              }
            }
          }
          
          loaded++;
          if (loaded % 5 === 0 || loaded === filePaths.length) {
            updateLoading(`Loaded ${loaded}/${filePaths.length} files...`);
            await new Promise(resolve => setTimeout(resolve, 10));
          }
          
        } catch (error) {
          console.warn(`Error loading ${filePath}:`, error);
        }
      }
      
      return { notes, links };
    }
    
    function generateGraphData(notes, links) {
      function getDisplayName(filePath) {
        const fileName = filePath.replace('ml/', '').replace('.md', '');
        
        if (fileName.toLowerCase() === 'readme') return 'README';
        
        // Format: {4 digit year}{author}_{title} (e.g., "2017Vaswani_attention_is_all_you_need")
        const match = fileName.match(/^(\d{4})([^_]+)_(.+)$/);
        if (match) {
          const [, year, author, titlePart] = match;
          const title = titlePart.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          const authorName = author.charAt(0).toUpperCase() + author.slice(1);
          return `${title} (${authorName}, ${year})`;
        }
        
        // Fallback: just clean up the filename
        const cleaned = fileName.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        return cleaned;
      }
      
      const nodes = Object.keys(notes).map(note => ({
        id: note,
        label: getDisplayName(note),
        content: notes[note].content,
        tags: notes[note].tags
      }));
      
      const edges = [];
      const nodeLinkCount = {};
      
      Object.keys(notes).forEach(note => {
        nodeLinkCount[note] = 0;
      });
      
      for (const [src, dstList] of Object.entries(links)) {
        for (const dst of dstList) {
          const potentialTargets = [
            dst,
            'ml/' + dst,
            'ml/' + dst + '.md',
            dst + '.md'
          ];
          
          let matched = false;
          for (const target of potentialTargets) {
            if (notes[target.toLowerCase()]) {
              edges.push({ source: src, target: target.toLowerCase() });
              nodeLinkCount[src] += 1;
              nodeLinkCount[target.toLowerCase()] += 1;
              matched = true;
              break;
            }
          }
        }
      }
      
      nodes.forEach(node => {
        node.link_count = nodeLinkCount[node.id] || 0;
        node.color = getColorForTags(node.tags);
        delete node.content;
      });
      
      return { nodes, edges };
    }
    
    function createGraph() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      const svg = d3.select("#graph")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      
      const g = svg.append("g");
      
      // Define arrowhead marker
      svg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 25)
        .attr("refY", 0)
        .attr("markerWidth", 15)
        .attr("markerHeight", 15)
        .attr("orient", "auto-start-reverse")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("class", "arrowhead");
      
      const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", zoomed);
      
      svg.call(zoom);
      
      function zoomed() {
        g.attr("transform", d3.event.transform);
      }
      
      simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(200))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .alphaDecay(0.02)
        .alphaMin(0.001)
        .on("tick", ticked);
      
      const link = g.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("marker-start", "url(#arrowhead)");
      
      const node = g.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", d => 20 + Math.sqrt(d.link_count || 0) * 2)
        .attr("fill", d => d.color)
        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)
        .on("click", function(d) {
          window.open(d.id, '_blank')
        })
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));
      
      const text = g.append("g")
        .attr("class", "texts")
        .selectAll("text")
        .data(nodes)
        .enter().append("text")
        .attr("x", 15)
        .attr("y", ".31em")
        .text(d => d.label)
        .style("font-size", "20px")
        .style("fill", "#333");
      
      function ticked() {
        link
          .each(function(d) {
            // Calculate the distance between nodes
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const dr = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate the radius of the source node
            const sourceRadius = 20 + Math.sqrt(d.source.link_count || 0) * 2;
            
            // Shorten the line to stop at the edge of the source node
            const offsetX = (dx / dr) * sourceRadius;
            const offsetY = (dy / dr) * sourceRadius;
            
            d3.select(this)
              .attr("x1", d.source.x + offsetX)
              .attr("y1", d.source.y + offsetY)
              .attr("x2", d.target.x)
              .attr("y2", d.target.y);
          });
        
        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
        
        text
          .attr("x", d => d.x + 15)
          .attr("y", d => d.y + 4);
      }
      
      function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      
      function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      }
      
      function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', function() {
      if (simulation) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        d3.select("#graph svg").attr("width", width).attr("height", height);
        simulation.force("center", d3.forceCenter(width / 2, height / 2));
        simulation.alpha(0.3).restart();
      }
    });
    
    // Start the application
    init();
  </script>
</body>
</html>

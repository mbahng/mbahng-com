\section{Logic Gates}

  We have seen in our theoretical computer science that the $\NAND$ gate is univeral, and we have implemented it with transistors in the previous chapter. Therefore using syntactic sugar, we can apply the rest of the elementary gates. The common unary and binary logic gates are listed below as a refresher. 

  \begin{figure}[H]
    \centering 
    \begin{subfigure}[b]{0.32\textwidth}
      \centering
      \begin{tikzpicture}[circuit logic US]
        \node[and gate, draw, logic gate inputs=nn] (A) at (0,0) {};
        \node[above=0.3cm of A] {AND};
        \draw (A.input 1) -- ++(-0.5,0);
        \draw (A.input 2) -- ++(-0.5,0);
        \draw (A.output) -- ++(0.5,0);
      \end{tikzpicture}
      \caption{AND Gate}
      \label{fig:and}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.32\textwidth}
      \centering
      \begin{tikzpicture}[circuit logic US]
        \node[or gate, draw, logic gate inputs=nn] (O) at (0,0) {};
        \node[above=0.3cm of O] {OR};
        \draw (O.input 1) -- ++(-0.5,0);
        \draw (O.input 2) -- ++(-0.5,0);
        \draw (O.output) -- ++(0.5,0);
      \end{tikzpicture}
      \caption{OR Gate}
      \label{fig:or}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.32\textwidth}
      \centering
      \begin{tikzpicture}[circuit logic US]
        \node[not gate, draw] (N) at (0,0) {};
        \node[above=0.3cm of N] {NOT};
        \draw (N.input) -- ++(-0.5,0);
        \draw (N.output) -- ++(0.5,0);
      \end{tikzpicture}
      \caption{NOT Gate}
      \label{fig:not}
    \end{subfigure}
    
    \begin{subfigure}[b]{0.32\textwidth}
      \centering
      \begin{tikzpicture}[circuit logic US]
        \node[nand gate, draw, logic gate inputs=nn] (AN) at (0,0) {};
        \node[above=0.3cm of AN] {NAND};
        \draw (AN.input 1) -- ++(-0.5,0);
        \draw (AN.input 2) -- ++(-0.5,0);
        \draw (AN.output) -- ++(0.5,0);
      \end{tikzpicture}
      \caption{NAND Gate}
      \label{fig:nand}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.32\textwidth}
      \centering
      \begin{tikzpicture}[circuit logic US]
        \node[nor gate, draw, logic gate inputs=nn] (NO) at (0,0) {};
        \node[above=0.3cm of NO] {NOR};
        \draw (NO.input 1) -- ++(-0.5,0);
        \draw (NO.input 2) -- ++(-0.5,0);
        \draw (NO.output) -- ++(0.5,0);
      \end{tikzpicture}
      \caption{NOR Gate}
      \label{fig:nor}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.32\textwidth}
      \centering
      \begin{tikzpicture}[circuit logic US]
        \node[xor gate, draw, logic gate inputs=nn] (X) at (0,0) {};
        \node[above=0.3cm of X] {XOR};
        \draw (X.input 1) -- ++(-0.5,0);
        \draw (X.input 2) -- ++(-0.5,0);
        \draw (X.output) -- ++(0.5,0);
      \end{tikzpicture}
      \caption{XOR Gate}
      \label{fig:xor}
    \end{subfigure}
    \caption{Common Logic Gates}
    \label{fig:logic-gates}    
  \end{figure}

  \begin{definition}[Multi-Bit NOT Gate]
    
  \end{definition}

  \begin{definition}[Multi-Bit AND Gate]
    
  \end{definition}

  \begin{definition}[Multi-Bit OR Gate]
    
  \end{definition}

  \begin{definition}[Multi-Bit NAND Gate]
    
  \end{definition}

  \begin{definition}[Multi-Bit XOR Gate]
    
  \end{definition}

  \begin{definition}[Multi-Bit Multiplexor Gate]
    
  \end{definition}

  \begin{definition}[Multi-Bit Demultiplexor Gate]
    
  \end{definition}


  boolean operations

\subsection{Hardware Description Languages (HDL)}

  Clearly, engineers don't probably spend their days endlessly drawing little gates on paper. Thankfully, we have established that \textit{straight-line programs} are an equivalent model of finite computation, and so we can use lexical programs to model boolean circuits. These programs are called \textbf{hardware description languages (HDL)} and are used to model and design these digital systems. Historically, \textit{Verilog} was the most dominant, but it has been largely replaced by \textit{SystemVerilog} and \textit{VHDL}. Regardless, both of these are a superset of Verilog, and we will begin with this. 

  \begin{definition}[Function Module]
    A \textbf{module} represents some sort of class. 
    \begin{enumerate}
      \item The \textbf{ports} represent the inputs and outputs of a gate, represented with the \texttt{input} and \texttt{output} keywords. It is conventional to put the outputs first and then the inputs. 
      \item The output value is determined by some logic using the \texttt{assign} keyword. 
    \end{enumerate}

    \begin{lstlisting}
      module nand_gate(
        input a, b,
        output y
      );
        assign y = ~(a & b);
      endmodule 
    \end{lstlisting}
  \end{definition}

  \begin{definition}[Test Bench Module]
    A \textbf{testbench module} represents a suite of inputs that you want to test. 
    \begin{enumerate}
      \item Variables that store values---like registers---are specified with the \texttt{reg} keyword. 
      \item Signals that are continuously driven (i.e. cannot store states) and are automatically updated when inputs changes are specified with the \texttt{wire} keyword. 
      \item The \textbf{device under test (dut)} connects the testbench signals to the DUT ports using named port connections. 
    \end{enumerate}

    \begin{lstlisting}[language=Verilog]
      module nand_gate_tb;
        reg a, b; // registers that hold states
        wire y;

        // Instantiate device under test
        nand_gate dut(.a(a), .b(b), .y(y));

        initial begin
          // Enable waveform dumping
          $dumpfile("nand_gate.vcd");
          $dumpvars(0, nand_gate_tb);

          // Test all input combinations
          a = 0; b = 0; #10;
          a = 0; b = 1; #10;
          a = 1; b = 0; #10;
          a = 1; b = 1; #10;

          $display("Test complete");
          $finish;
        end

        // Monitor changes
        initial
          $monitor("At time %t: a=%b, b=%b, y=%b", $time, a, b, y);
      endmodule
    \end{lstlisting}
  \end{definition}


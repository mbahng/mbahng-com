There are many assembly languages out there and various syntaxes. \textit{Intel syntax} specifies memory operands without any special prefixes. Square brackets [] are used to denote memory addresses. For example, mov eax, [ebx] means move the contents of the memory location pointed to by ebx into eax. In \textit{AT\&T syntax}, memory operands are denoted with parentheses () and include the \% prefix for registers. An instruction moving data from a memory location into a register might look like movl (\%ebx), \%eax, with additional prefixes for immediate values and segment overrides. In here, we will talk about the three most popular architectures. 

\begin{definition}[x86]
  \textbf{x86 Assembly} is the assembly language for Intel and AMD processors using the x86 architecture. Both AT\&T and Intel syntax are available. Tools or environments often allow switching between the two, with AT\&T being the default in GNU tools like GDB.

  The x86 architecture is a CISC architecture, which is the most common architecture for personal computers. Here are important properties: 
  \begin{enumerate} 
    \item It is a complex instruction set computer (CISC) architecture, which means that it has a large set of complex instructions\footnote{https://en.wikipedia.org/wiki/X86\_instruction\_listings}. 
    \item Byte-addressing is enabled and words are stored in little-endian format.
    \item In the x86\_64 architecture, registers are 8 bytes long (and 4 bytes in x86\_32) and there are 16 total general purpose registers, for a total of only 128 bytes (very small compared to many GB of memory). Other special purpose registers are also documented in the wikipedia page, but it is not fully documented. 
  \end{enumerate}
\end{definition}

\begin{definition}[ARM]
  \textbf{ARM Assembly} is the assembly language for ARM processors. Has its own unique syntax, not categorized as AT\&T or Intel. ARM syntax is closely tied to its instruction set architecture and is distinct from the x86 conventions. It is mainly in phones, tablets, laptops. 
\end{definition}

\begin{definition}[RISC-V]
  
\end{definition}

A debatable 4th mainstream one is the MIPs assembly, which is based off of the MIPS RISC archiecture used in embedded systems such as digital home and networking equipment. Historically through, there are many many more variants. \textit{PowerPC assembly} is the assembly language for PowerPC processors. PowerPC has its own syntax style, tailored to its architecture and instruction set, distinct from the AT\&T and Intel syntax models. \textit{6502 Assembly} is used in many early microcomputers and gaming consoles. Utilizes a syntax unique to the 6502 processor, not following AT\&T or Intel conventions. \textit{Z80 Assembly} is associated with the Z80 microprocessor, used in numerous computing devices in the late 20th century. Z80 assembly language has its own syntax that does not adhere to AT\&T or Intel syntax guidelines.


Just like how memory addressing is different between 32 and 64 bit machines, CPUs also use these schemes. While 32-bit processors have $2^{32}$ possible addresses in their cache, it turns out that 64-bit processors have a 48-address space. This is because CPU manufacturers took a shortcut. They use an instruction set which allows a full 64-bit address space, but current CPUs just only use the last 48-bits. The alternative was wasting transistors on handling a bigger address space which wasn't going to be needed for many years (since 48-bits is about 256TB). Just a bit of history for you. Finally, just to briefly mention, the input/output device, as the name suggests, processes inputs and displays outputs, which is how you can see what the program does. 


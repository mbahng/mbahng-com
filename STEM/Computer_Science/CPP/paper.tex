\documentclass{article}

% packages
  % basic stuff for rendering math
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath} 
  \usepackage{amssymb}
  % \usepackage{amsthm}

  % extra math symbols and utilities
  \usepackage{mathtools}        % for extra stuff like \coloneqq
  \usepackage{mathrsfs}         % for extra stuff like \mathsrc{}
  \usepackage{centernot}        % for the centernot arrow 
  \usepackage{bm}               % for better boldsymbol/mathbf 
  \usepackage{enumitem}         % better control over enumerate, itemize
  \usepackage{hyperref}         % for hypertext linking
  \usepackage{fancyvrb}          % for better verbatim environments
  \usepackage{newverbs}         % for texttt{}
  \usepackage{xcolor}           % for colored text 
  \usepackage{listings}         % to include code
  \usepackage{lstautogobble}    % helper package for code
  \usepackage{parcolumns}       % for side by side columns for two column code
  

  % page layout
  \usepackage{fancyhdr}         % for headers and footers 
  \usepackage{lastpage}         % to include last page number in footer 
  \usepackage{parskip}          % for no indentation and space between paragraphs    
  \usepackage[T1]{fontenc}      % to include \textbackslash
  \usepackage{footnote}
  \usepackage{etoolbox}

  % for custom environments
  \usepackage{tcolorbox}        % for better colored boxes in custom environments
  \tcbuselibrary{breakable}     % to allow tcolorboxes to break across pages

  % figures
  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{float}            % for [H] figure placement
  \usepackage{tikz}
  \usepackage{tikz-cd}
  \usepackage{circuitikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usepackage{graphicx}
  \usepackage{algorithmic}
  \usepackage{caption} 
  \usepackage{subcaption}
  \captionsetup{font=small}

  % for tabular stuff 
  \usepackage{dcolumn}

  \usepackage[nottoc]{tocbibind}
  \pdfsuppresswarningpagegroup=1
  \hfuzz=5.002pt                % ignore overfull hbox badness warnings below this limit

% New and replaced operators
  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator{\pos}{pos}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\braket}[2]{\langle #1 | #2 \rangle}
  \newcommand{\qed}{\hfill$\blacksquare$}     % I like QED squares to be black

% Custom Environments
  \newtcolorbox[auto counter, number within=section]{question}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Question \thetcbcounter ~(#1)}
  }

  \newtcolorbox[auto counter, number within=section]{exercise}[1][]
  {
    colframe = teal!25,
    colback  = teal!10,
    coltitle = teal!20!black,  
    breakable, 
    title = \textbf{Exercise \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{solution}[1][]
  {
    colframe = violet!25,
    colback  = violet!10,
    coltitle = violet!20!black,  
    breakable, 
    title = \textbf{Solution \thetcbcounter}
  }
  \newtcolorbox[auto counter, number within=section]{lemma}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Lemma \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{theorem}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Theorem \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proposition}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Proposition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{corollary}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Corollary \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proof}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Proof. }
  } 
  \newtcolorbox[auto counter, number within=section]{definition}[1][]
  {
    colframe = yellow!25,
    colback  = yellow!10,
    coltitle = yellow!20!black,  
    breakable, 
    title = \textbf{Definition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{example}[1][]
  {
    colframe = blue!25,
    colback  = blue!10,
    coltitle = blue!20!black,  
    breakable, 
    title = \textbf{Example \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{code}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Code \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{algo}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Algorithm \thetcbcounter ~(#1)}
  } 

  \BeforeBeginEnvironment{example}{\savenotes}
  \AfterEndEnvironment{example}{\spewnotes}
  \BeforeBeginEnvironment{lemma}{\savenotes}
  \AfterEndEnvironment{lemma}{\spewnotes}
  \BeforeBeginEnvironment{theorem}{\savenotes}
  \AfterEndEnvironment{theorem}{\spewnotes}
  \BeforeBeginEnvironment{corollary}{\savenotes}
  \AfterEndEnvironment{corollary}{\spewnotes}
  \BeforeBeginEnvironment{proposition}{\savenotes}
  \AfterEndEnvironment{proposition}{\spewnotes}
  \BeforeBeginEnvironment{definition}{\savenotes}
  \AfterEndEnvironment{definition}{\spewnotes}
  \BeforeBeginEnvironment{exercise}{\savenotes}
  \AfterEndEnvironment{exercise}{\spewnotes}
  \BeforeBeginEnvironment{proof}{\savenotes}
  \AfterEndEnvironment{proof}{\spewnotes}
  \BeforeBeginEnvironment{solution}{\savenotes}
  \AfterEndEnvironment{solution}{\spewnotes}
  \BeforeBeginEnvironment{question}{\savenotes}
  \AfterEndEnvironment{question}{\spewnotes}
  \BeforeBeginEnvironment{code}{\savenotes}
  \AfterEndEnvironment{code}{\spewnotes}
  \BeforeBeginEnvironment{algo}{\savenotes}
  \AfterEndEnvironment{algo}{\spewnotes}

  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \definecolor{darkblue}{rgb}{0,0,139}
  \definecolor{lightgray}{gray}{0.93}
  \renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$\textcolor{blue}{#1}}

  % default options for listings (for code)
  \lstset{
    autogobble,
    frame=ltbr,
    language=C++,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=fullflexible,
    keepspaces=true,
    basicstyle={\small\ttfamily},
    numbers=left,
    firstnumber=1,                        % start line number at 1
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{lightgray}, 
    breaklines=true,                      % break lines
    breakatwhitespace=true,
    tabsize=3, 
    xleftmargin=2em, 
    framexleftmargin=1.5em, 
    stepnumber=1
  }

% Page style
  \pagestyle{fancy}
  \fancyhead[L]{C++}
  \fancyhead[C]{Muchang Bahng}
  \fancyhead[R]{Winter 2024} 
  \fancyfoot[C]{\thepage / \pageref{LastPage}}
  \renewcommand{\footrulewidth}{0.4pt}          % the footer line should be 0.4pt wide
  \renewcommand{\thispagestyle}[1]{}  % needed to include headers in title page

\begin{document}

\title{C++}
\author{Muchang Bahng}
\date{Winter 2024}

\maketitle
\tableofcontents
\pagebreak

\section{Basics} 

  We define a bunch of terms. This may seem unnecessary, but it becomes very useful when getting into the weeds of C++. 

  \begin{definition}[Variables]
    \begin{enumerate}
      \item A \textbf{literal} is a value that is directly inserted into code, e.g. \texttt{5}, \texttt{3.2}, \texttt{'a'}.\footnote{Usually, using literals by themselves such as \texttt{return 4;} should be avoided since the reader can't determine what it represents through the identifier name. We must resort to a comment or external documentation. } 
      \item A \textbf{variable} can be assigned to a literal, e.g. \texttt{x}. 
      \item The \textbf{identifier} is simply the name of the variable. 
      \item An \textbf{operation} consists of an \textbf{operator} (\texttt{+}) and one or more \textbf{operands} (\texttt{3}, \texttt{4.3}).  
      \item An \textbf{expression} is simply a line of code containing variables, operations, and literals, e.g. \texttt{int x = 3 + 4;} 
      \item The process of executing an expression is called \textbf{evaluation}. 
    \end{enumerate}

    Variables can be \textbf{constructed} in two ways. 
    \begin{enumerate}
      \item We first \textbf{declare} a variable, which tells the compiler about the existence of the variable (\texttt{int x;}). Then, we can \textbf{define} the variable, which assigns it a literal (\texttt{x = 4;}). 
      \item We can \textbf{initialize} a variable, which both declares it and defines it at once (\texttt{int x = 4;}).
    \end{enumerate}
  \end{definition}

  \begin{definition}[Functions]
    \begin{enumerate}
      \item The \textbf{declaration} of a function states the existence of the function. 
        \begin{lstlisting}
          double foo(int x, double y); // one way 
          double foo(int, double); // another way 
        \end{lstlisting}
        This declaration is also called the \textbf{function prototype}, or the \textbf{function identifier}. 

      \item The \textbf{definition} of a function tells us the actual implementation. 
        \begin{lstlisting}
          double foo(int x, double y) {
            ...
          }
        \end{lstlisting}
    \end{enumerate}
  \end{definition}

\section{Translation} 

    \textbf{Translating} C++ code to a binary consists of multiple steps: 
    \begin{enumerate}
      \item Preprocessing the code. 
      \item Compiling each file independently. 
      \item Linking all the files. 
    \end{enumerate}
    Conventionally, all of these are called \textit{compiling}, but it really isn't. 

  \subsection{Preprocessing} 

    When preprocessing, we do some boring stuff like removing comments. However, the main job is to take care of \textbf{preprocessing directives}, which are expressions with the \texttt{\#} symbol. The most obvious is the \texttt{\#include} directives, which \textbf{replaces the include directive with the contents of the included file}. That is, \texttt{\#include} is really just a way to substitute code.  
    \begin{enumerate}
      \item including with angle brackets, e.g. \texttt{\#include <iostream>}, means that the compiler is looking for this file in the standard library files. 
      \item including with double quotes, e.g. \texttt{\#include "tensor.h"}, means that the compiler is looking for this file locally in your project directory. It means you've written it. 
    \end{enumerate}
    
    Other directives is the \texttt{\#define} directive. 
    \begin{enumerate}
      \item You can define it to substitute text. It is conventionally in all upper-case.  
        \begin{lstlisting}
          #define NAME "Muchang"  // all instances of NAME will be replaced with "Muchang"
        \end{lstlisting}
      \item Or you can define it without substitution text, where further occurrences of \texttt{NAME} will be replaced by nothing. 
        \begin{lstlisting}
          #define NAME 
        \end{lstlisting}
    \end{enumerate}

    The second isn't used for substitution, but rather for \textbf{conditional compilation}, which can be useful. You just wrap C++ statements around as such.

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      #ifdef NAME 
      ... 
      #endif
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      #ifndef NAME 
      ... 
      #endif
      
    \end{lstlisting}
    \end{minipage} 

    To see the output after preprocessing, use the \texttt{-E} flag. 
    \begin{lstlisting}
      g++ main.cpp -E
    \end{lstlisting}

  \subsection{Compilation} 

    We only compile files one at a time and independently. When the compiler compiles a file, it goes through each line sequentially. Therefore, we must ensure that all functions/variables/classes are \textit{declared} first before they are called. \textit{Forward declaration} makes this a lot easier. 

    There is a difference between a declaration and a definition. 

    \begin{definition}[ODR]
      Remember the ODR (One Definition Rule): 
      \begin{enumerate}
        \item Within a file, each function, variable, type, or template in a given scope can only have one definition. Definitions occurring in different scopes (e.g. local variables defined inside different functions, or functions defined inside different namespaces) do not violate this rule. 

        \item Within a program, each function or variable in a given scope can only have one definition.\footnote{This rule exists because programs can have more than one file. For example, if you have two definitions of \texttt{int add(int, int)} in two different files, the linker does not know which one to connect the declaration to.}
      \end{enumerate}
      To be honest, ODR 2 really implies ODR 1, since once the directives are preprocessed or the object files are linked, we are really left with one executable file. 
    \end{definition} 

    \begin{example}[ODR 1 Violation] 
      The following shows that in the same file, there are multiple variables defined in the function scope of \texttt{main}, and there are two definitions of \texttt{foo} in the global scope. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          int main() {
            int x; 
            int x;

            return 0;
          } 
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          int foo() { return 5; }
          int foo() { return 5; }

          int main() {
            std::cout << foo();
            return 0;
          } 
        \end{lstlisting}
      \end{minipage}
    \end{example}

    \begin{example}[ODR 2 Violation]
      Say that \texttt{main.cpp} has the \texttt{main()} method that calls on \texttt{int add(int x, int y)}, which is forward declared. However, say that we define add in two places. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // foo.cpp 
          int add(int x, int y) {
            return x + y; 
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // bar.cpp 
          int add(int x, int y) {
            return x + y; 
          }
        \end{lstlisting}
      \end{minipage}
      Then, if we run \texttt{g++ main.cpp foo.cpp bar.cpp}, the linker will complain that there is a function redefinition. 
    \end{example}

  \subsection{Linking} 

    Remember, declaration is not the same thing as definition. When we do the linking, we go through all the source files in our project and match all the declarations with our definitions. The source files must all be written in the compile command. 

    \begin{lstlisting}
      g++ main.cpp add.cpp
      g++ add.cpp main.cpp
    \end{lstlisting}

    This should not be order dependent. The source files can be 

    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        // main.cpp 
        int add(int x, int y); // declaration

        int main() {  
          int z = add(2, 3); 
          return 0; 
        }
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        // add.cpp
        // definition
        int add(int x, int y) { 
          return x + y;
        }
        .
        .
      \end{lstlisting}
    \end{minipage}
  
  \subsection{Header Files} 

    To be honest, we can just include forward declarations everywhere, but this does not scale well to large projects. If we had a set of declarations that we wanted to use over a bunch of files, we can package them nicely using a \textbf{header file}. 
    
    If we have a bunch of functions and classes written in \texttt{foo.cpp}, then it is conventional to write a \texttt{foo.h} that contains all the declarations of these expressions. Then, whenever we need to write a new file \texttt{bar.cpp} that uses functions from \texttt{foo.cpp}, we can just \texttt{\#include "foo.h"}, which replaces this directive (by the preprocessor) with all the forward declarations in \texttt{foo.h}. Boom easy. 

    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        // add.cpp
        int add(int x, int y) { 
          return x + y;
        }
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        // add.h 
        int add(int x, int y); 
        .
        .
      \end{lstlisting}
    \end{minipage}

    Therefore when we call \texttt{add} in \texttt{main.cpp}, we can just \texttt{\#include "add.h"} to put in the declarations, making everything good. Conventionally, it is best practice for a source file to also include its paired header (e.g. \texttt{add.cpp} should also contain \texttt{\#include "add.h"} at the top). This allows the compiler to discover inconsistencies between the two files, and this extra cost is negligible.\footnote{\href{here}{https://www.learncpp.com/cpp-tutorial/cpp-faq/\#pairedheader}} 

    \begin{example}[Definitions inside Header Files]
      You should not add definitions (only declarations) to header files since if they are included in multiple header files, then we would have different definitions of the same function, leading to ODR 2 violation. Take a look at the following. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // square.h
          int getSquareSides() {
              return 4;
          } 
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // wave.h 
          #include "square.h"
        \end{lstlisting}
      \end{minipage}

      With the following. 
      \begin{lstlisting}
        #include "square.h"
        #include "wave.h" 
        int main() {
          return 0;
        }
      \end{lstlisting}
      This won't compile since 
      \begin{enumerate}
        \item by including \texttt{square.h}, we have defined \texttt{getSquareSides()} in the global scope of \texttt{main.cpp}. 
        \item by including \texttt{wave.h}, we have included \texttt{square.h} which then substitutes this line with the definition of \texttt{getSquareSides()} again. 
      \end{enumerate}
      This is an ODR 1 violation. 
    \end{example} 

    The simple fix to the above is to just remove the \texttt{\#include "wave.h"}, but what if we needed some other function from \texttt{wave.h}? Resolving this issue is not trivial if say, half of the functions in \texttt{square.h} is needed in \texttt{wave.h} and the other half is needed in \texttt{main.cpp}. We must include both of them in \texttt{main.cpp}, but then we have an inevitable redefinition. Without separating \texttt{square.h} into separate files, solving this is impossible. 

    Even if we didn't have definitions in header files in the first place (which is bad practice in general), repeated declarations, which are still fine, are also not really ideal either. Furthermore, custom types are typically defined in header files, so redefining them leads to an ODR violation. 
    
    \begin{definition}[Header Guards]
      Fortunately, we have \textbf{header guards}, which are conditional compilation directives that tell the compiler to include a header file at most once to the main file. You can do this in two ways. 
      \begin{enumerate}
        \item Just put this to the top of the header file. The compiler will take care of redeclaration/redefinitions for you. This isn't always fail-safe. 
        \begin{lstlisting}
          #pragma once
        \end{lstlisting} 

      \item More manually, we can use a conditional compilation directive. Put this on the top of the header. 
        \begin{lstlisting}
          #ifndef HEADERFILE_H
          #define HEADERFILE_H 
          
          ...Header Contents...

          #endif 
        \end{lstlisting}
        In the beginning, \texttt{HEADERFILE\_H} is not defined, so we include all of this. In a second inclusion though, \texttt{HEADERFILE\_H} is defined, so the preprocessor removes this. 
      \end{enumerate}

      Note that header guards limit the number of times a header can be included in a single given file, but the header may still be repeated across separate project files. This is what we want. 
    \end{definition}

  \subsection{Compile Time vs Run Time} 

    By default, all expressions are evaluated at runtime, but compilers have different levels of optimization. Here are some. 

    \begin{definition}[Constant Folding] 
      The compiler replaces expressions that have literal operands with the result of the operation, e.g. \texttt{3 + 4} automatically gets evaluated to \texttt{7}. 
    \end{definition}

    \begin{definition}[Constant Propagation]
      In the code below, \texttt{x} is initialized to be \texttt{7} and will be stored in the memory allocated for \texttt{x}. On the next line, the program will go out to memory to fetch the same value to print. This is redundant. Therefore, the compiler will realize that \texttt{x} always has the constant value \texttt{7} and will replace all instances of \texttt{x} with \texttt{7}. 
      \begin{lstlisting}
        #include <iostream>

        int main() {
          int x { 7 };
          std::cout << x << '\n';
          return 0;
        } 
      \end{lstlisting}
    \end{definition}

    \begin{definition}[Dead Code Elimination]
      The compiler removes all code that has no noticeable effect on the program's behavior. Note that this is not a preprocessing step. 
      \begin{lstlisting}
        #include <iostream>
        int main() {
          int x { 7 }; // this line is removed. 
          std::cout << 7 << '\n';
          return 0;
        } 
      \end{lstlisting}
    \end{definition}

\section{Types} 

  Some types have the \texttt{\_t} suffix, which just represents type. Some types have this and others don't. In C++, there is no exact size for each fundamental type (except for \texttt{char}, which is always 1 byte). There is however a lower bound, so you should always use the lower bound and for maximum portability, never assume that a type can store more bytes. 
  \begin{enumerate}
    \item \texttt{sizeof(short) = 4}
    \item \texttt{sizeof(int) = 4}
    \item \texttt{sizeof(long) = 4}
    \item \texttt{sizeof(long long) = 8}
    \item \texttt{sizeof(float) = 4}
    \item \texttt{sizeof(double) = 8}
    \item \texttt{sizeof(long double) = 8}
  \end{enumerate} 

  Where does the \texttt{sizeof} operator come from? 

  \subsection{Casting}

    We can also convert some types to different types. If the types are relatively similar, then the C++ implementation may do an \textbf{implicit typecast}. If not, then we do an \textbf{explicit typecast} in the following ways. 
    \begin{enumerate}
      \item \texttt{static\_cast<T>(foo)}
      \item \texttt{(T)foo} 
      \item \texttt{dynamic\_cast<T>(foo)}
    \end{enumerate} 

  \subsection{Constants}

    \textbf{Named constants} are variables must be initialized since they cannot change. They cannot be declared. If a variable can be made constant, it should be. It reduces bugs and gives more opportunity for compiler optimization, effectively reducing runtime and increasing compile time. 

    Function parameters that are \texttt{const} just tells the compiler that it won't be changed during the function execution. But since the variable is thrown away after the body, it doesn't really matter anyways. You can also return const types, but this is again a temporary copy and may impede compiler optimizations so it not recommended.  

    In a way, consts are just like object-like directives with substitution text, but consts follow scoping, so use consts whenever you can rather than macros.  

  \subsection{Compile-Time Programming} 

    \begin{definition}[Constant Expression]
      A \textbf{constant expression} is an expression that must be evaluatable at compile-time.\footnote{along with rules that determine how the compiler should handle these expressions.} If we really want to make fast programs, we must convert it to as much constant expressions as possible. They generally contain the following: 
      \begin{enumerate}
        \item Literals 
        \item Most operators with constant expression operands, e.g. \texttt{3 + 4}, \texttt{2 * sizeof(int)} 
        \item Constexpr variables  
        \item Constexpr function calls with constant expression arguments. 
      \end{enumerate}
      Any expression not a constant expression is called a \textbf{runtime expression}. 
    \end{definition}

    Constants in C++ are often divided into 2 categories. 
    \begin{enumerate}
      \item A \textbf{compile-time constant} is a constant whose value is known at compile-time, e.g. literals and constant objects whose initializers are compile-time constants. 
      \item A \textbf{runtime constant} is a constant whose value is determined at runtime, e.g. constant function parameters and constant objects whose initializers are non-constants or runtime constants.\footnote{This is what we would like to reduce.} 
    \end{enumerate}


\end{document}

\documentclass{article}

% packages
  % basic stuff for rendering math
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath} 
  \usepackage{amssymb}
  % \usepackage{amsthm}

  % extra math symbols and utilities
  \usepackage{mathtools}        % for extra stuff like \coloneqq
  \usepackage{mathrsfs}         % for extra stuff like \mathsrc{}
  \usepackage{centernot}        % for the centernot arrow 
  \usepackage{bm}               % for better boldsymbol/mathbf 
  \usepackage{enumitem}         % better control over enumerate, itemize
  \usepackage{hyperref}         % for hypertext linking
  \usepackage{fancyvrb}          % for better verbatim environments
  \usepackage{newverbs}         % for texttt{}
  \usepackage{xcolor}           % for colored text 
  \usepackage{listings}         % to include code
  \usepackage{lstautogobble}    % helper package for code
  \usepackage{parcolumns}       % for side by side columns for two column code
  

  % page layout
  \usepackage{fancyhdr}         % for headers and footers 
  \usepackage{lastpage}         % to include last page number in footer 
  \usepackage{parskip}          % for no indentation and space between paragraphs    
  \usepackage[T1]{fontenc}      % to include \textbackslash
  \usepackage{footnote}
  \usepackage{etoolbox}

  % for custom environments
  \usepackage{tcolorbox}        % for better colored boxes in custom environments
  \tcbuselibrary{breakable}     % to allow tcolorboxes to break across pages

  % figures
  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{float}            % for [H] figure placement
  \usepackage{tikz}
  \usepackage{tikz-cd}
  \usepackage{circuitikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usepackage{graphicx}
  \usepackage{algorithmic}
  \usepackage{caption} 
  \usepackage{subcaption}
  \captionsetup{font=small}

  % for tabular stuff 
  \usepackage{dcolumn}

  \usepackage[nottoc]{tocbibind}
  \pdfsuppresswarningpagegroup=1
  \hfuzz=5.002pt                % ignore overfull hbox badness warnings below this limit

% New and replaced operators
  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator{\pos}{pos}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\braket}[2]{\langle #1 | #2 \rangle}
  \newcommand{\qed}{\hfill$\blacksquare$}     % I like QED squares to be black

% Custom Environments
  \newtcolorbox[auto counter, number within=section]{question}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Question \thetcbcounter ~(#1)}
  }

  \newtcolorbox[auto counter, number within=section]{exercise}[1][]
  {
    colframe = teal!25,
    colback  = teal!10,
    coltitle = teal!20!black,  
    breakable, 
    title = \textbf{Exercise \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{solution}[1][]
  {
    colframe = violet!25,
    colback  = violet!10,
    coltitle = violet!20!black,  
    breakable, 
    title = \textbf{Solution \thetcbcounter}
  }
  \newtcolorbox[auto counter, number within=section]{lemma}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Lemma \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{theorem}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Theorem \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proposition}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Proposition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{corollary}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Corollary \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proof}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Proof. }
  } 
  \newtcolorbox[auto counter, number within=section]{definition}[1][]
  {
    colframe = yellow!25,
    colback  = yellow!10,
    coltitle = yellow!20!black,  
    breakable, 
    title = \textbf{Definition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{example}[1][]
  {
    colframe = blue!25,
    colback  = blue!10,
    coltitle = blue!20!black,  
    breakable, 
    title = \textbf{Example \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{code}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Code \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{algo}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Algorithm \thetcbcounter ~(#1)}
  } 

  \BeforeBeginEnvironment{example}{\savenotes}
  \AfterEndEnvironment{example}{\spewnotes}
  \BeforeBeginEnvironment{lemma}{\savenotes}
  \AfterEndEnvironment{lemma}{\spewnotes}
  \BeforeBeginEnvironment{theorem}{\savenotes}
  \AfterEndEnvironment{theorem}{\spewnotes}
  \BeforeBeginEnvironment{corollary}{\savenotes}
  \AfterEndEnvironment{corollary}{\spewnotes}
  \BeforeBeginEnvironment{proposition}{\savenotes}
  \AfterEndEnvironment{proposition}{\spewnotes}
  \BeforeBeginEnvironment{definition}{\savenotes}
  \AfterEndEnvironment{definition}{\spewnotes}
  \BeforeBeginEnvironment{exercise}{\savenotes}
  \AfterEndEnvironment{exercise}{\spewnotes}
  \BeforeBeginEnvironment{proof}{\savenotes}
  \AfterEndEnvironment{proof}{\spewnotes}
  \BeforeBeginEnvironment{solution}{\savenotes}
  \AfterEndEnvironment{solution}{\spewnotes}
  \BeforeBeginEnvironment{question}{\savenotes}
  \AfterEndEnvironment{question}{\spewnotes}
  \BeforeBeginEnvironment{code}{\savenotes}
  \AfterEndEnvironment{code}{\spewnotes}
  \BeforeBeginEnvironment{algo}{\savenotes}
  \AfterEndEnvironment{algo}{\spewnotes}

  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \definecolor{darkblue}{rgb}{0,0,139}
  \definecolor{lightgray}{gray}{0.93}
  \renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$\textcolor{blue}{#1}}

  % default options for listings (for code)
  \lstset{
    autogobble,
    frame=ltbr,
    language=C++,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=fullflexible,
    keepspaces=true,
    basicstyle={\small\ttfamily},
    numbers=left,
    firstnumber=1,                        % start line number at 1
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{lightgray}, 
    breaklines=true,                      % break lines
    breakatwhitespace=true,
    tabsize=3, 
    xleftmargin=2em, 
    framexleftmargin=1.5em, 
    stepnumber=1
  }

% Page style
  \pagestyle{fancy}
  \fancyhead[L]{C++}
  \fancyhead[C]{Muchang Bahng}
  \fancyhead[R]{Winter 2024} 
  \fancyfoot[C]{\thepage / \pageref{LastPage}}
  \renewcommand{\footrulewidth}{0.4pt}          % the footer line should be 0.4pt wide
  \renewcommand{\thispagestyle}[1]{}  % needed to include headers in title page

\begin{document}

\title{C++}
\author{Muchang Bahng}
\date{Winter 2024}

\maketitle
\tableofcontents
\pagebreak

\section{Basics} 

    We define a bunch of terms. This may seem unnecessary, but it becomes very useful when getting into the weeds of C++. 

    \begin{definition}[Variables]
      \begin{enumerate}
        \item A \textbf{literal} is a value that is directly inserted into code, e.g. \texttt{5}, \texttt{3.2}, \texttt{'a'}.\footnote{Usually, using literals by themselves such as \texttt{return 4;} should be avoided since the reader can't determine what it represents through the identifier name. We must resort to a comment or external documentation. } 
        \item A \textbf{variable} can be assigned to a literal, e.g. \texttt{x}. 
        \item The \textbf{identifier} is simply the name of the variable, and its \textbf{linkage} determines whether a declaration of that same identifier in a different scope refers to the same object. 
        \item An \textbf{operation} consists of an \textbf{operator} (\texttt{+}) and one or more \textbf{operands} (\texttt{3}, \texttt{4.3}).  
        \item An \textbf{expression} is simply a line of code containing variables, operations, and literals, e.g. \texttt{int x = 3 + 4;} 
        \item The process of executing an expression is called \textbf{evaluation}. 
      \end{enumerate}

      Variables can be \textbf{constructed} in two ways. 
      \begin{enumerate}
        \item We first \textbf{declare} a variable, which tells the compiler about the existence of the variable (\texttt{int x;}). Then, we can \textbf{define} the variable, which assigns it a literal (\texttt{x = 4;}). 
        \item We can \textbf{initialize} a variable, which both declares it and defines it at once (\texttt{int x = 4;}).
      \end{enumerate}
    \end{definition}

    \begin{definition}[Functions]
      \begin{enumerate}
        \item The \textbf{declaration} of a function states the existence of the function. 
          \begin{lstlisting}
            double foo(int x, double y); // one way 
            double foo(int, double); // another way 
          \end{lstlisting}
          This declaration is also called the \textbf{function prototype}, or the \textbf{function identifier}. 

        \item The \textbf{definition} of a function tells us the actual implementation. 
          \begin{lstlisting}
            double foo(int x, double y) {
              ...
            }
          \end{lstlisting}
      \end{enumerate}
    \end{definition}

  \subsection{Scope}

    \begin{definition}[Scope]
      The \textbf{scope} of an identifier refers to where it is accessible by. The \textbf{duration} of an identifier governs how it will be constructed and destroyed, over its \textbf{lifetime}. There are two types of variables, \textbf{local variables} and \textbf{global variables}. 
    \end{definition} 

    \subsubsection{Local Variables}

      \begin{definition}[Local Variables]
        \textbf{Local variables} are variables constructed inside a block scope. 
        \begin{enumerate}
          \item They have \textbf{automatic duration}, which means that their lifetime begins at the start of the block (at \texttt{\{}) and is destroyed at the end of the block \texttt{\}}. 
        \end{enumerate}
      \end{definition}

      \begin{example}[Automatic Duration]
        You can see that every block contains its own scope with its own local variables. When the block ends all variables in this block are destroyed on the stack. 

        \begin{lstlisting}
          int main() {  
            int x = 2; 
            std::cout << x << std::endl; // 2
            {
              int y = 1;
              std::cout << x << std::endl; // 2
              std::cout << y << std::endl; // 1
            }
            return 0; 
          }
          
        \end{lstlisting}
      \end{example}

      \begin{example}[Accessing Parent Block Scope]
        Local variables in a nested block have access to the parent block's scope. Both of these programs are valid. The left accesses the parent block's \texttt{x} while the right one access \texttt{x} newly created in the local scope. 

        \noindent\begin{minipage}{.5\textwidth}
          \begin{lstlisting}[]{Code}
            int main() {  
              int x = 2; 
              for (int i = 0; i < 10; i++) {
                x += 1;
              }
              std::cout << x << std::endl; // 12
              return 0; 
            }
            .
          \end{lstlisting}
          \end{minipage}
          \hfill
          \begin{minipage}{.49\textwidth}
          \begin{lstlisting}[]{Output}
            int main() {  
              int x = 2; 
              for (int i = 0; i < 10; i++) {
                int x = 1;
                x += 1;
              }
              std::cout << x << std::endl; // 2
              return 0; 
            }
          \end{lstlisting}
        \end{minipage}
      \end{example}

      \begin{example}[Variable Shadowing]
        You can see that the \texttt{x} is initialized in the \texttt{main()} block scope, but it gets ``shadowed'' by the \texttt{x} in the nested block. Once the block terminates, then it is ``revealed'' again. 

        \begin{lstlisting}
          int main() {  
            int x = 2; 
            std::cout << x << std::endl; // 1
            {
              int x = 1;
              std::cout << x << std::endl; // 1
            }
            std::cout << x << std::endl; // 2 
            return 0; 
          }
        \end{lstlisting}
        
      \end{example}

    \subsubsection{Global Variables} 

      \begin{definition}[Global Variables]
        Global variables are constructed outside of the main function, in the global namespace. 
        \begin{enumerate}
          \item They have \textbf{static duration}, which means they are created when the program starts (before \texttt{main()}) and destroyed when it ends. 
          \item Usually it is preferred to define global variables in a namespace. If not, many developers prefer the prefix global variable identifiers with \texttt{g} or \texttt{g\_} to indicate that they are global and do not have naming conflicts. 
          \item Unlike local variables, which are uninitialized by default, variables with static duration are 0-intialized by default (e.g. \texttt{int g\_x;} is really \texttt{int g\_x = 0;}). 
        \end{enumerate}
      \end{definition}

      Just like local variables, global variables can be const as well, and like all const variables, must be initialized. 

\section{Translation} 

    \textbf{Translating} C++ code to a binary consists of multiple steps: 
    \begin{enumerate}
      \item Preprocessing the code. 
      \item Compiling each file independently. 
      \item Linking all the files. 
    \end{enumerate}
    Conventionally, all of these are called \textit{compiling}, but it really isn't. 

  \subsection{Preprocessing} 

    When preprocessing, we do some boring stuff like removing comments. However, the main job is to take care of \textbf{preprocessing directives}, which are expressions with the \texttt{\#} symbol. The most obvious is the \texttt{\#include} directives, which \textbf{replaces the include directive with the contents of the included file}. That is, \texttt{\#include} is really just a way to substitute code.  
    \begin{enumerate}
      \item including with angle brackets, e.g. \texttt{\#include <iostream>}, means that the compiler is looking for this file in the standard library files. 
      \item including with double quotes, e.g. \texttt{\#include "tensor.h"}, means that the compiler is looking for this file locally in your project directory. It means you've written it. 
    \end{enumerate}
    
    Other directives is the \texttt{\#define} directive. 
    \begin{enumerate}
      \item You can define it to substitute text. It is conventionally in all upper-case.  
        \begin{lstlisting}
          #define NAME "Muchang"  // all instances of NAME will be replaced with "Muchang"
        \end{lstlisting}
      \item Or you can define it without substitution text, where further occurrences of \texttt{NAME} will be replaced by nothing. 
        \begin{lstlisting}
          #define NAME 
        \end{lstlisting}
    \end{enumerate}

    The second isn't used for substitution, but rather for \textbf{conditional compilation}, which can be useful. You just wrap C++ statements around as such.

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      #ifdef NAME 
      ... 
      #endif
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      #ifndef NAME 
      ... 
      #endif
      
    \end{lstlisting}
    \end{minipage} 

    To see the output after preprocessing, use the \texttt{-E} flag. 
    \begin{lstlisting}
      g++ main.cpp -E
    \end{lstlisting}

  \subsection{Compilation} 

    We only compile files one at a time and independently. When the compiler compiles a file, it goes through each line sequentially. Therefore, we must ensure that all functions/variables/classes are \textit{declared} first before they are called. \textit{Forward declaration} makes this a lot easier. 

    There is a difference between a declaration and a definition. 

    \begin{definition}[ODR]
      Remember the ODR (One Definition Rule): 
      \begin{enumerate}
        \item Within a file, each function, variable, type, or template in a given scope can only have one definition. Definitions occurring in different scopes (e.g. local variables defined inside different functions, or functions defined inside different namespaces) do not violate this rule. 

        \item Within a program, each function or variable in a given scope can only have one definition.\footnote{This rule exists because programs can have more than one file. For example, if you have two definitions of \texttt{int add(int, int)} in two different files, the linker does not know which one to connect the declaration to.}
      \end{enumerate}
      To be honest, ODR 2 really implies ODR 1, since once the directives are preprocessed or the object files are linked, we are really left with one executable file. 
    \end{definition} 

    \begin{example}[ODR 1 Violation] 
      The following shows that in the same file, there are multiple variables defined in the function scope of \texttt{main}, and there are two definitions of \texttt{foo} in the global scope. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          int main() {
            int x; 
            int x;

            return 0;
          } 
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          int foo() { return 5; }
          int foo() { return 5; }

          int main() {
            std::cout << foo();
            return 0;
          } 
        \end{lstlisting}
      \end{minipage}
    \end{example}

    \begin{example}[ODR 2 Violation]
      Say that \texttt{main.cpp} has the \texttt{main()} method that calls on \texttt{int add(int x, int y)}, which is forward declared. However, say that we define add in two places. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // foo.cpp 
          int add(int x, int y) {
            return x + y; 
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // bar.cpp 
          int add(int x, int y) {
            return x + y; 
          }
        \end{lstlisting}
      \end{minipage}
      Then, if we run \texttt{g++ main.cpp foo.cpp bar.cpp}, the linker will complain that there is a function redefinition. 
    \end{example}

  \subsection{Linking} 

    Remember, declaration is not the same thing as definition. When we do the linking, we go through all the source files in our project and match all the declarations with our definitions. The source files must all be written in the compile command. 

    \begin{lstlisting}
      g++ main.cpp add.cpp
      g++ add.cpp main.cpp
    \end{lstlisting}

    This should not be order dependent. The source files can be 

    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        // main.cpp 
        int add(int x, int y); // declaration

        int main() {  
          int z = add(2, 3); 
          return 0; 
        }
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        // add.cpp
        // definition
        int add(int x, int y) { 
          return x + y;
        }
        .
        .
      \end{lstlisting}
    \end{minipage}
  
  \subsection{Header Files} 

    To be honest, we can just include forward declarations everywhere, but this does not scale well to large projects. If we had a set of declarations that we wanted to use over a bunch of files, we can package them nicely using a \textbf{header file}. 
    
    If we have a bunch of functions and classes written in \texttt{foo.cpp}, then it is conventional to write a \texttt{foo.h} that contains all the declarations of these expressions. Then, whenever we need to write a new file \texttt{bar.cpp} that uses functions from \texttt{foo.cpp}, we can just \texttt{\#include "foo.h"}, which replaces this directive (by the preprocessor) with all the forward declarations in \texttt{foo.h}. Boom easy. 

    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        // add.cpp
        int add(int x, int y) { 
          return x + y;
        }
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        // add.h 
        int add(int x, int y); 
        .
        .
      \end{lstlisting}
    \end{minipage}

    Therefore when we call \texttt{add} in \texttt{main.cpp}, we can just \texttt{\#include "add.h"} to put in the declarations, making everything good. Conventionally, it is best practice for a source file to also include its paired header (e.g. \texttt{add.cpp} should also contain \texttt{\#include "add.h"} at the top). This allows the compiler to discover inconsistencies between the two files, and this extra cost is negligible.\footnote{\href{here}{https://www.learncpp.com/cpp-tutorial/cpp-faq/\#pairedheader}} 

    \begin{example}[Definitions inside Header Files]
      You should not add definitions (only declarations) to header files since if they are included in multiple header files, then we would have different definitions of the same function, leading to ODR 2 violation. Take a look at the following. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // square.h
          int getSquareSides() {
              return 4;
          } 
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // wave.h 
          #include "square.h"
        \end{lstlisting}
      \end{minipage}

      With the following. 
      \begin{lstlisting}
        #include "square.h"
        #include "wave.h" 
        int main() {
          return 0;
        }
      \end{lstlisting}
      This won't compile since 
      \begin{enumerate}
        \item by including \texttt{square.h}, we have defined \texttt{getSquareSides()} in the global scope of \texttt{main.cpp}. 
        \item by including \texttt{wave.h}, we have included \texttt{square.h} which then substitutes this line with the definition of \texttt{getSquareSides()} again. 
      \end{enumerate}
      This is an ODR 1 violation. 
    \end{example} 

    The simple fix to the above is to just remove the \texttt{\#include "wave.h"}, but what if we needed some other function from \texttt{wave.h}? Resolving this issue is not trivial if say, half of the functions in \texttt{square.h} is needed in \texttt{wave.h} and the other half is needed in \texttt{main.cpp}. We must include both of them in \texttt{main.cpp}, but then we have an inevitable redefinition. Without separating \texttt{square.h} into separate files, solving this is impossible. 

    Even if we didn't have definitions in header files in the first place (which is bad practice in general), repeated declarations, which are still fine, are also not really ideal either. Furthermore, custom types are typically defined in header files, so redefining them leads to an ODR violation. 
    
    \begin{definition}[Header Guards]
      Fortunately, we have \textbf{header guards}, which are conditional compilation directives that tell the compiler to include a header file at most once to the main file. You can do this in two ways. 
      \begin{enumerate}
        \item Just put this to the top of the header file. The compiler will take care of redeclaration/redefinitions for you. This isn't always fail-safe. 
        \begin{lstlisting}
          #pragma once
        \end{lstlisting} 

      \item More manually, we can use a conditional compilation directive. Put this on the top of the header. 
        \begin{lstlisting}
          #ifndef HEADERFILE_H
          #define HEADERFILE_H 
          
          ...Header Contents...

          #endif 
        \end{lstlisting}
        In the beginning, \texttt{HEADERFILE\_H} is not defined, so we include all of this. In a second inclusion though, \texttt{HEADERFILE\_H} is defined, so the preprocessor removes this. 
      \end{enumerate}

      Note that header guards limit the number of times a header can be included in a single given file, but the header may still be repeated across separate project files. This is what we want. 
    \end{definition}

  \subsection{Namespaces} 

    Perhaps we want to have two functions of the same name, but we get a redefinition error. This is where namespaces come in. 

    \begin{definition}[Namespace]
      We can wrap each function around a \textbf{namespace}, which is written with an upper-case letter. 
      \begin{lstlisting}
        namespace Foo {
          int bar() {}
        }
      \end{lstlisting}
      To access identifiers defined in the namespace, we must use the \textbf{scope resolution operator} \texttt{::}. If no scope resolution is given, or an empty one is given, then we look for the identifier in the global namespace. 
      \begin{lstlisting}
        int x = Foo::bar();   // Foo namespace
        int y = bar();        // global namespace
        int z = ::bar();      // global namespace 
      \end{lstlisting}
    \end{definition} 

    \begin{example}[Namespace]
      Say that we have two files with the same-name function in different namespaces. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          namespace Foo {
            int doSomething(int x, int y) {
              return x + y;
            }
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          namespace Goo {
            int doSomething(int x, int y) {}
              return x - y;
            }
          }
        \end{lstlisting}
      \end{minipage}

      When we put our forward declarations, we must make sure to add the namespace using the scope resolution operator. If the namespace is not included, then the linker will look for the function in the global namespace rather than the user-defined namespace. 

      \begin{lstlisting}
        int doSomething(int x, int y); // this results in an error 
        int Foo::doSomething(int x, int y); // correct
        int Goo::doSomething(int x, int y); // correct

        int main() {
            std::cout << Foo::doSomething(4, 3) << '\n'; 
            std::cout << Goo::doSomething(4, 3) << '\n'; 
            return 0;
        }
      \end{lstlisting}
    \end{example} 

    Let's talk about a few properties of namespaces. 

    \begin{lemma}[Identifiers in Parent Namespaces]
      If an identifier $A$ in a namespace uses another identifier $B$ without a scope resolution, then $A$ will look for $B$ within $A$'s namespace. If no matching identifier for $B$ is found, then the compiler will then check each containing namespace in sequence to see if a match is found, with the global namespace being checked last. 

      \begin{lstlisting}
        #include <iostream>
        void print() // this print() lives in the global namespace
        {
          std::cout << " there\n";
        }

        namespace Foo {
          void print() // this print() lives in the Foo namespace
          {
            std::cout << "Hello";
          }

          void printHelloThere()
          {
            print();   // calls print() in Foo namespace
            ::print(); // calls print() in global namespace
          }
        }

        int main() {
          Foo::printHelloThere(); // prints "Hello there" 
          return 0;
        } 
      \end{lstlisting}
    \end{lemma}

    \begin{lemma}[Nested Namespaces]
      Namespaces can be nested as well, either of 2 ways. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          namespace Foo {
            namespace Goo{
              ... 
            }
          }
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          namespace Foo {

          }

          namespace Foo::Goo {

          }
        \end{lstlisting}
      \end{minipage}
    \end{lemma}

    \begin{lemma}[Namespace aliases]
      You can shorten namespaces using \textbf{namespace aliases}. 
      \begin{lstlisting}
        namespace Active = Foo::Goo; 
        int x = Active::doSomething(); 
      \end{lstlisting}
    \end{lemma}

    \begin{lemma}[Using Namespace]
      The \textbf{using namespace} is a directive that allows access to all members of a namespace. 
    \end{lemma}

\section{Types and Expressions} 

  Some types have the \texttt{\_t} suffix, which just represents type. Some types have this and others don't. In C++, there is no exact size for each fundamental type (except for \texttt{char}, which is always 1 byte). There is however a lower bound, so you should always use the lower bound and for maximum portability, never assume that a type can store more bytes. 
  \begin{enumerate}
    \item \texttt{sizeof(short) = 4}
    \item \texttt{sizeof(int) = 4}
    \item \texttt{sizeof(long) = 4}
    \item \texttt{sizeof(long long) = 8}
    \item \texttt{sizeof(float) = 4}
    \item \texttt{sizeof(double) = 8}
    \item \texttt{sizeof(long double) = 8}
  \end{enumerate} 

  Where does the \texttt{sizeof} operator come from? 

  \subsection{Casting}

    We can also convert some types to different types. If the types are relatively similar, then the C++ implementation may do an \textbf{implicit typecast}. If not, then we do an \textbf{explicit typecast} in the following ways. 
    \begin{enumerate}
      \item \texttt{static\_cast<T>(foo)}
      \item \texttt{(T)foo} 
      \item \texttt{dynamic\_cast<T>(foo)}
    \end{enumerate} 

\section{Constants and Constant Expressions}

  \subsection{Compiler Optimization} 

    By default, all expressions are evaluated at runtime, but compilers have different levels of optimization. Here are some methods in which it optimizes, which follow the \textbf{as-if rule} that states that a compiler can modify a program however it likes in order to produce more optimized code, so long as those modification do not affect a program's observable behavior. 

    \begin{definition}[Constant Folding] 
      The compiler replaces expressions that have literal operands with the result of the operation, e.g. \texttt{3 + 4} automatically gets evaluated to \texttt{7}. 
    \end{definition}

    \begin{definition}[Constant Propagation]
      In the code below, \texttt{x} is initialized to be \texttt{7} and will be stored in the memory allocated for \texttt{x}. On the next line, the program will go out to memory to fetch the same value to print. This is redundant. Therefore, the compiler will realize that \texttt{x} always has the constant value \texttt{7} and will replace all instances of \texttt{x} with \texttt{7}. 
      \begin{lstlisting}
        #include <iostream>

        int main() {
          int x { 7 };
          std::cout << x << '\n';
          return 0;
        } 
      \end{lstlisting}
    \end{definition}

    \begin{definition}[Dead Code Elimination]
      The compiler removes all code that has no noticeable effect on the program's behavior. Note that this is not a preprocessing step. 
      \begin{lstlisting}
        #include <iostream>
        int main() {
          int x { 7 }; // this line is removed. 
          std::cout << 7 << '\n';
          return 0;
        } 
      \end{lstlisting}
    \end{definition} 

    A slightly higher level optimization evaluates certain expressions during compile time. 

    \begin{definition}[Compile-Time Expression]
      A \textbf{compile-time expression} is an expression that must always be capable of being evaluated at compile-time. 
    \end{definition}

    \begin{example}
      Say we have the following code. 
      \begin{lstlisting}
        const double x { 1.2 };
        const double y { 3.4 };
        const double z { x + y }; 
      \end{lstlisting} 
      \texttt{z} may or may not be evaluated to \texttt{4.6} at runtime. By default it is evaluated at runtime, but it depends on the compiler and level of optimization. 
    \end{example}

    Shifting some of the evaluation from runtime to compile time makes your code faster, though it may make it more difficult to debug since the compiler might rearrange the logic of your program (though in an equivalent way). Therefore, at runtime, the compiled code no longer correlates with the original source code. 
  
  \subsection{Constants}

    Now we talk about a seemingly separate, but very related concept. 

    \begin{definition}[Constant Variables]
      \textbf{Named constants} are variables that cannot change. 
      \begin{enumerate}
        \item They cannot be declared and must be initialized since they cannot change. This is called \textbf{constant expression initialization}.
        \item If a variable can be made constant, it should be. It reduces bugs and gives more opportunity for compiler optimization, effectively reducing runtime and increasing compile time. 
        \item Function parameters that are \texttt{const} just tells the compiler that it won't be changed during the function execution. But since the variable is thrown away after the body, it doesn't really matter anyways. You can also return const types, but this is again a temporary copy and may impede compiler optimizations so it not recommended. 
        \item In a way, consts are just like object-like directives with substitution text, but consts follow scoping, so use consts whenever you can rather than macros. 
      \end{enumerate}
    \end{definition}

    \begin{theorem}
      All compiler-time expressions must be consts. However, a const variable does not guarantee that it will be evaluated in compile time. With only consts, only const \textit{integral} variables can be a part of a constant expression. No other const variable is allowed.
    \end{theorem}
    \begin{proof}
      It is not surprising to see that if an expression can be evaluated at compile time, it must be a const variable. Consider the contrapositive: if it wasn't a const variable, then it may be initialized or changed during runtime and therefore the expression cannot be evaluated at compile time. However, the converse is not true. 
    \end{proof}

  \subsection{Compile-Time Programming}  
    
    Notice that when we really want a section of code to be evaluated at compile-time, the best we can do is use const variables and hope that the compiler executes it. In other words, we are dependent on the sophistication of the compiler, which is not ideal. To allow more explicit control over which parts of code we want to execute at compile-time, we can use \textbf{compile-time programming}. In C++11, compile-time programming was introduced with constant expressions, or \textbf{constexpr}s.

    \begin{definition}[Constant Expression]
      A \textbf{constant expression} is an expression that must be entirely evaluatable at compile-time.\footnote{along with rules that determine how the compiler should handle these expressions.} They generally contain the following: 
      \begin{enumerate}
        \item Literals 
        \item Most operators with constant expression operands, e.g. \texttt{3 + 4}, \texttt{2 * sizeof(int)} 
        \item Constexpr variables  
        \item Constexpr function calls with constant expression arguments. 
      \end{enumerate}
      Any expression not a constant expression is called a \textbf{runtime expression}. The following cannot be used in a constant expression. 
      \begin{enumerate}
        \item Non-const variables (e.g. \texttt{int x = 3;}) 
        \item Const non-integral variables, even when they have a constant expression initializer (e.g. \texttt{const double d = 1.2}). To use such variables, we need to define them with \texttt{constexpr}. 
        \item Function parameters. 
      \end{enumerate}
      There is a complex list of literals, operators, and variables that can and cannot be used in constant expressions. 
    \end{definition}

    There are still two problems. First, the limitations of constant expressions not being able to contain const non-integral variables is quite restricting. Second, even if we did have a constant expression, the compiler will by default evaluate it at runtime. Fortunately, constexpr addresses both problems. 

    \begin{definition}[constexpr Keyword]
      The \textbf{constexpr} variable is always a compile-time constant. As a result, a constexpr variable must be initialized with a constant expression, otherwise a compilation error will result. Here are some examples. 
      \begin{lstlisting}
        constexpr double gravity = 9.8; // works for doubles now 
      \end{lstlisting} 
      Since a constexpr variable is really a constant expression, it is implicitly a const variable. 
    \end{definition} 

\end{document}

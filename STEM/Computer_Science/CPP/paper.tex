\documentclass{article}

% packages
  % basic stuff for rendering math
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath} 
  \usepackage{amssymb}
  % \usepackage{amsthm}

  % extra math symbols and utilities
  \usepackage{mathtools}        % for extra stuff like \coloneqq
  \usepackage{mathrsfs}         % for extra stuff like \mathsrc{}
  \usepackage{centernot}        % for the centernot arrow 
  \usepackage{bm}               % for better boldsymbol/mathbf 
  \usepackage{enumitem}         % better control over enumerate, itemize
  \usepackage{hyperref}         % for hypertext linking
  \usepackage{fancyvrb}          % for better verbatim environments
  \usepackage{newverbs}         % for texttt{}
  \usepackage{xcolor}           % for colored text 
  \usepackage{listings}         % to include code
  \usepackage{lstautogobble}    % helper package for code
  \usepackage{parcolumns}       % for side by side columns for two column code
  

  % page layout
  \usepackage{fancyhdr}         % for headers and footers 
  \usepackage{lastpage}         % to include last page number in footer 
  \usepackage{parskip}          % for no indentation and space between paragraphs    
  \usepackage[T1]{fontenc}      % to include \textbackslash
  \usepackage{footnote}
  \usepackage{etoolbox}

  % for custom environments
  \usepackage{tcolorbox}        % for better colored boxes in custom environments
  \tcbuselibrary{breakable}     % to allow tcolorboxes to break across pages

  % figures
  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{float}            % for [H] figure placement
  \usepackage{tikz}
  \usepackage{tikz-cd}
  \usepackage{circuitikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usepackage{graphicx}
  \usepackage{algorithmic}
  \usepackage{caption} 
  \usepackage{subcaption}
  \captionsetup{font=small}

  % for tabular stuff 
  \usepackage{dcolumn}

  \usepackage[nottoc]{tocbibind}
  \pdfsuppresswarningpagegroup=1
  \hfuzz=5.002pt                % ignore overfull hbox badness warnings below this limit

% New and replaced operators
  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator{\pos}{pos}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\braket}[2]{\langle #1 | #2 \rangle}
  \newcommand{\qed}{\hfill$\blacksquare$}     % I like QED squares to be black

% Custom Environments
  \newtcolorbox[auto counter, number within=section]{question}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Question \thetcbcounter ~(#1)}
  }

  \newtcolorbox[auto counter, number within=section]{exercise}[1][]
  {
    colframe = teal!25,
    colback  = teal!10,
    coltitle = teal!20!black,  
    breakable, 
    title = \textbf{Exercise \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{solution}[1][]
  {
    colframe = violet!25,
    colback  = violet!10,
    coltitle = violet!20!black,  
    breakable, 
    title = \textbf{Solution \thetcbcounter}
  }
  \newtcolorbox[auto counter, number within=section]{lemma}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Lemma \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{theorem}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Theorem \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proposition}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Proposition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{corollary}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Corollary \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proof}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Proof. }
  } 
  \newtcolorbox[auto counter, number within=section]{definition}[1][]
  {
    colframe = yellow!25,
    colback  = yellow!10,
    coltitle = yellow!20!black,  
    breakable, 
    title = \textbf{Definition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{example}[1][]
  {
    colframe = blue!25,
    colback  = blue!10,
    coltitle = blue!20!black,  
    breakable, 
    title = \textbf{Example \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{code}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Code \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{algo}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Algorithm \thetcbcounter ~(#1)}
  } 

  \BeforeBeginEnvironment{example}{\savenotes}
  \AfterEndEnvironment{example}{\spewnotes}
  \BeforeBeginEnvironment{lemma}{\savenotes}
  \AfterEndEnvironment{lemma}{\spewnotes}
  \BeforeBeginEnvironment{theorem}{\savenotes}
  \AfterEndEnvironment{theorem}{\spewnotes}
  \BeforeBeginEnvironment{corollary}{\savenotes}
  \AfterEndEnvironment{corollary}{\spewnotes}
  \BeforeBeginEnvironment{proposition}{\savenotes}
  \AfterEndEnvironment{proposition}{\spewnotes}
  \BeforeBeginEnvironment{definition}{\savenotes}
  \AfterEndEnvironment{definition}{\spewnotes}
  \BeforeBeginEnvironment{exercise}{\savenotes}
  \AfterEndEnvironment{exercise}{\spewnotes}
  \BeforeBeginEnvironment{proof}{\savenotes}
  \AfterEndEnvironment{proof}{\spewnotes}
  \BeforeBeginEnvironment{solution}{\savenotes}
  \AfterEndEnvironment{solution}{\spewnotes}
  \BeforeBeginEnvironment{question}{\savenotes}
  \AfterEndEnvironment{question}{\spewnotes}
  \BeforeBeginEnvironment{code}{\savenotes}
  \AfterEndEnvironment{code}{\spewnotes}
  \BeforeBeginEnvironment{algo}{\savenotes}
  \AfterEndEnvironment{algo}{\spewnotes}

  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \definecolor{darkblue}{rgb}{0,0,139}
  \definecolor{lightgray}{gray}{0.93}
  \renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$\textcolor{blue}{#1}}

  % default options for listings (for code)
  \lstset{
    autogobble,
    frame=ltbr,
    language=C++,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=fullflexible,
    keepspaces=true,
    basicstyle={\small\ttfamily},
    numbers=left,
    firstnumber=1,                        % start line number at 1
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{lightgray}, 
    breaklines=true,                      % break lines
    breakatwhitespace=true,
    tabsize=3, 
    xleftmargin=2em, 
    framexleftmargin=1.5em, 
    stepnumber=1
  }

% Page style
  \pagestyle{fancy}
  \fancyhead[L]{C++}
  \fancyhead[C]{Muchang Bahng}
  \fancyhead[R]{Winter 2024} 
  \fancyfoot[C]{\thepage / \pageref{LastPage}}
  \renewcommand{\footrulewidth}{0.4pt}          % the footer line should be 0.4pt wide
  \renewcommand{\thispagestyle}[1]{}  % needed to include headers in title page

\begin{document}

\title{C++}
\author{Muchang Bahng}
\date{Winter 2024}

\maketitle
\tableofcontents
\pagebreak

\section{Objects}

    We define a bunch of terms. This may seem unnecessary, but it becomes very useful when getting into the weeds of C++. 

    \begin{definition}[Statements]
      A \textbf{statement} is an instruction that causes the program to perform some action. Statements are the smallest independent unit of computation in the C++ language, and they are ended with a semicolon. 
      \begin{lstlisting}
        int x; //  declaration statement 
        int y = 2; // initialization statements  
        int z = 2 + 3;
      \end{lstlisting}
    \end{definition}

  \subsection{Types}

    \begin{definition}[Type]
      A \textbf{type} is a protocol that defines the set of possible values and a set of operations that can be performed on those values.\footnote{This is similar to a mathematical set endowed with some operations. This definition is quite abstract, but it suffices.} There are several categorizations for types. 
      \begin{enumerate}
        \item At the very basic level, we have \textbf{primitive types}, which are always built-in types that come with C++ or the standard library (e.g. int, double, boolean). 
        \item \textbf{Compound types} are types that are built in by primitive types. In here, we have 
          \begin{enumerate}
            \item \textbf{Built-in types} which come with C++ or the standard library (e.g. functions) 
            \item \textbf{User-defined types} which the user defines (e.g. enums\footnote{Since they are implemented with integral types.}, classes, structs)
          \end{enumerate}
      \end{enumerate}
      Note that the protocols for each type is dependent on the version of C++, the computer architecture, and the compiler. Therefore we have to be careful to accommodate them. 
    \end{definition}

    Great, now let's see what primitive types are supported in C++.  
    
    \begin{definition}[Integral Types]
      \textbf{Integral types} represent a proper subset of $\mathbb{Z}$. 
      \begin{enumerate}
        \item The signed numbers include \texttt{int}, \texttt{long}, \texttt{long long} and are stored in two's complement representation. 

        \begin{figure}[H]
          \centering 
          \begin{lstlisting}
            * thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over
                frame #0: 0x0000000100003fa0 a.out`main + 28
            a.out`main:
            ->  0x100003fa0 <+28>: add    sp, sp, #0x10
                0x100003fa4 <+32>: ret    
                0x100003fa8:       udf    #0x1
                0x100003fac:       udf    #0x1c
            Target 0: (a.out) stopped.
            (lldb) x/4xb $sp+4
            0x16fdfec44: 0xff 0xff 0xff 0xff
            (lldb) x/4xb $sp+8
            0x16fdfec48: 0x01 0x00 0x00 0x00
          \end{lstlisting}
          \caption{Two's complement representation of $\pm1$ on my machine from inspecting memory in \texttt{lldb}. Note that this is little endian, with the least significant hex coming first.} 
          \label{fig:signed_rep}
        \end{figure} 

        \item The unsigned numbers include \texttt{unsigned int}, \texttt{unsigned long}, \texttt{unsigned long long} and are stored regularly. 

        \begin{figure}[H]
          \centering 
          \begin{lstlisting}
            * thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over
                frame #0: 0x0000000100003fa0 a.out`main + 28
            a.out`main:
            ->  0x100003fa0 <+28>: add    sp, sp, #0x10
                0x100003fa4 <+32>: ret    
                0x100003fa8:       udf    #0x1
                0x100003fac:       udf    #0x1c
            Target 0: (a.out) stopped.
            (lldb) x/4xb $sp+4
            0x16fdfec44: 0x00 0x01 0x00 0x00
            (lldb) x/4xb $sp+8
            0x16fdfec48: 0x01 0x00 0x00 0x00
          \end{lstlisting}
          \caption{Regular representation of unsigned integers \texttt{256 = 0x1000} and \texttt{1 = 0x01}. }
          \label{fig:unsigned_rep}
        \end{figure} 
      \end{enumerate}
    \end{definition} 

    \begin{definition}[Floating Point Types]
      \textbf{Floating point types} represent a proper subset of $\mathbb{R}$. 
    \end{definition}

    \begin{definition}[Char]
      \texttt{Character types} represent the extended ASCII character set and is always 1 Byte. Some nice facts to know. 
      \begin{enumerate}
        \item The numbers 0-9 take characters \texttt{48} to \texttt{57}.
        \item The uppercase letters A-Z take \texttt{65} to \texttt{90}. 
        \item The lowercase letters a-z take \texttt{97} to \texttt{122}. 
      \end{enumerate}
    \end{definition}

    \begin{definition}[Boolean]
      A \textbf{boolean} stores 1 bit of memory, but in practice it takes up 1 Byte since a Byte is the smallest addressable unit of memory in most computer architectures. 
    \end{definition}

    \begin{definition}[Void]
      The \textbf{void} type is the analogous to the null or none type in other languages. It is a type that does not represent a type, stating that an object has no type. 
    \end{definition} 

    \begin{example}[Types with \texttt{\_t} Suffix?]
      Some types have the \texttt{\_t} suffix, which just represents type. Some types have this and others don't. In C++, there is no exact size for each fundamental type (except for \texttt{char}, which is always 1 byte). There is however a lower bound, so you should always use the lower bound and for maximum portability, never assume that a type can store more bytes. 
    \end{example}

    \subsubsection{Casting}

      \begin{definition}[Typecasting]
        The action of converting one type to another type is called \textbf{typecasting}. 
        \begin{enumerate}
          \item The programmer can \textbf{explicitly typecast} by calling an operator to change an objects type. 
          \item If two objects are relatively similar,\footnote{defined very loosely here} then the C++ implementation may do an \textbf{implicit typecast} to convert it automatically. 
        \end{enumerate}
      \end{definition}

      \begin{lemma}[Function Calls]
        Function calls and operators will implicitly typecast between char and signed int. This can both be convenient and a pain to work with. 
        \begin{lstlisting}
          int main() { 
            char x = 'a';         // 97 in ASCII
            std::cout << x + 4;   // 101
            std::cout << x - 200; // -103
            return 0; 
          }
        \end{lstlisting}
      \end{lemma}

      How do we explicitly typecast? C++ defines a few operators (not functions! explained later) that does this. 

      \begin{definition}[C Style Cast]
        Similar to typecasting in C, we can do the following. 
        \begin{lstlisting}
          (T)foo
        \end{lstlisting}
      \end{definition}
      
      \begin{definition}[Static Cast]
        We can conduct a static typecast, which happens during compile time. 
        \begin{lstlisting}
          static_cast<T>(foo)
        \end{lstlisting}
      \end{definition}

      \begin{definition}[Dynamic Cast]
        \begin{lstlisting}
          dynamic\_cast<T>(foo)
        \end{lstlisting}
      \end{definition}

  \subsection{Variables}

      \begin{definition}[Value]
        The definition of a \textbf{value} is quite abstract. It is simply some data with a \textbf{type}. In computers, the value gets \textit{encoded} into some sequence of bits. The \textbf{identity} of a value is purely determined by the abstract concept it represents. 
      \end{definition}

      \begin{definition}[Objects and Variables]
        An \textbf{object} represents a memory of storage (typically RAM or CPU cache) that can hold a value. It has 4 properties. 
        \begin{enumerate}
          \item Like a value, it has a type representing the type of value it holds. 
          \item It has an \textbf{address} representing where the value is stored.  
          \item The identity is determined not just by the value that it stores, but also its address. 
          \item It \textit{may} have a \textbf{name}.\footnote{Typically some alphanumeric string like \texttt{x}.} Objects with a name are called \textbf{variables}, and those without a name are called \textbf{anonymous}. The \textbf{linkage} of the variable determines which address the variable refers to. 
        \end{enumerate}
        Note that in C++, the definition of an object slightly differs than in more general contexts. 
      \end{definition} 

      \begin{definition}[Literal]
        A \textbf{literal} is a value that is directly inserted into code, e.g. \texttt{5}, \texttt{3.2}, \texttt{'a'}. It is not a variable since it does not have an name, and it is not an object either since it doesn't have an address. 
      \end{definition} 

      \begin{theorem}[Types are not Objects!]
        If a type defines the protocol, then wouldn't this be stored in memory? No, this is for the compiler.  
      \end{theorem}

    \subsubsection{Scope and Duration} 

      Now that we've established variables, we can talk about their scope. 
      
      \begin{definition}[Block]
        
      \end{definition}

      You probably know that there are two types of variables: \textbf{local variables} and \textbf{global variables}, along with their general properties. Let's specify them a bit, starting with the two most important ones: scope and duration.  

      \begin{definition}[Duration]
        The \textbf{duration} of an identifier governs how it will be constructed and destroyed, over its \textbf{lifetime}. 
        \begin{enumerate}
          \item \textbf{Automatic duration} means that their lifetime begins at the start of the block (at \texttt{\{}) and is destroyed at the end of the block \texttt{\}}. 
          \item \textbf{Static duration} means they are created when the program starts (before \texttt{main()}) and destroyed when it ends. Variables with static duration, both local and global, are 0-intialized by default. (e.g. \texttt{static int x;} is really \texttt{static int x = 0;}). It is conventional to prefix static local variables with a \texttt{s\_}. 
        \end{enumerate}
      \end{definition} 

      \begin{definition}[Scope]
        The \textbf{scope} of an identifier refers to where it is accessible by. 
        \begin{enumerate}
          \item \textbf{Local variables} are variables constructed inside a \textbf{block scope} and are accessible only within that block. They have automatic duration by default, but can have static duration with the \texttt{static} keyword. 

          \begin{lstlisting}
            int main() {
              int x = 2; // local variable 
              static int x = 3; // static local variable
            }
          \end{lstlisting}
          A variable's linkage determines whether a declaration of that same identifier in a different scope refers to the same object. 

          \item \textbf{Global variables} live within the \textbf{global scope} of the global or a local namespace and therefore can be accessible from anywhere. They are static variables by definition. Usually it is preferred to define global variables in a namespace. It is conventional to prefix global variables with \texttt{g\_}. 
        \end{enumerate}
      \end{definition} 

      It may seem like the scope and duration are related, but you can have any combination of automatic local variables (just called local variables), static local variables, and global variables. The duration talks about \textit{when} a variables is allowed to live while the scope talks about \textit{where} it is accessible from. Just like local variables, global variables can be const as well, and like all const variables, must be initialized. 

      \begin{example}[Automatic Duration]
        You can see that every block contains its own scope with its own local variables. When the block ends all variables in this block are destroyed on the stack. 

        \begin{lstlisting}
          int main() {  
            int x = 2; 
            std::cout << x << std::endl; // 2
            {
              int y = 1;
              std::cout << x << std::endl; // 2
              std::cout << y << std::endl; // 1
            }
            return 0; 
          }
          
        \end{lstlisting}
      \end{example}

      \begin{example}[Accessing Parent Block Scope]
        Local variables in a nested block have access to the parent block's scope. Both of these programs are valid. The left accesses the parent block's \texttt{x} while the right one access \texttt{x} newly created in the local scope. 

        \noindent\begin{minipage}{.5\textwidth}
          \begin{lstlisting}[]{Code}
            int main() {  
              int x = 2; 
              for (int i = 0; i < 10; i++) {
                x += 1;
              }
              std::cout << x << std::endl; // 12
              return 0; 
            }
            .
          \end{lstlisting}
          \end{minipage}
          \hfill
          \begin{minipage}{.49\textwidth}
          \begin{lstlisting}[]{Output}
            int main() {  
              int x = 2; 
              for (int i = 0; i < 10; i++) {
                int x = 1;
                x += 1;
              }
              std::cout << x << std::endl; // 2
              return 0; 
            }
          \end{lstlisting}
        \end{minipage}
      \end{example}

      \begin{example}[Variable Shadowing]
        You can see that the \texttt{x} is initialized in the \texttt{main()} block scope, but it gets ``shadowed'' by the \texttt{x} in the nested block. Once the block terminates, then it is ``revealed'' again. 

        \begin{lstlisting}
          int main() {  
            int x = 2; 
            std::cout << x << std::endl; // 1
            {
              int x = 1;
              std::cout << x << std::endl; // 1
            }
            std::cout << x << std::endl; // 2 
            return 0; 
          }
        \end{lstlisting}
      \end{example} 

      Static local variables are good for id generation, since they are not accessible beyond a block but still have a persistent state that does not get reset. Another good use is to use const static local variables for functions that needs to use a const value, but initializing that object is expensive. Using a local variable would instantiate it every time the function is called, but a static local variable requires us to create it once. 

    \subsubsection{Internal and External Linkage} 

      Talk about static keyword. 

      When \texttt{static} is applied to a global variable, it has a completely unrelated effect than that applied on a local variable. It means that the global variable now has internal linkage, meaning that the variable cannot be exported to other files. 

  \subsection{Operators and Functions} 

    In Python, there is no difference between functions and operators since every operator (e.g. \texttt{+}) gets mapped to a dunder method (e.g. \texttt{\_\_add()\_\_}). In C++, there are differences. Operators and functions are similar in behavior, but we should know that operators are more like \textit{keywords} while function are \textit{compound types}. 
    
    \begin{definition}[Function]
      A \textbf{function} is a set of statements enclosed in a block, which uses a sequence of \textbf{parameters} and a \textbf{return type}. It has the following properties. 
      \begin{enumerate}
        \item It \textit{may} have a name (e.g. \texttt{foo()}). Those without a name are called \textbf{anonymous functions}. 
        \item By default, a call to a function requires us to jump to a separate piece of code. 
      \end{enumerate}
    \end{definition}

    \begin{definition}[Operations]
      An \textbf{operator} is a keyword with a fixed syntax which also does some operation. An \textbf{operation} consists of an operator (\texttt{+}) and one or more \textbf{operands} (\texttt{3}, \texttt{4.3}).  
      \begin{enumerate}
        \item Operators come as a part of C++ (\texttt{sizeof}, \texttt{+}) or the C++ standard library (\texttt{std::cout <<}). 
        \item Unlike a function, an operator does not jump to another sequence in the code and is compiled to a sequence of instructions by the compiler. 
        \item Operators usually have a fixed number of parameters, while functions can use different sets of operands (overloading). 
        \item Operators have built-in precedence rules (e.g. multiplication before addition) 
      \end{enumerate}
    \end{definition}

    \begin{definition}[\texttt{sizeof} Operator]
      The \texttt{sizeof} operator returns the size (in bytes) of its operand. 
      \begin{enumerate}
        \item \texttt{sizeof(short) = 4}
        \item \texttt{sizeof(int) = 4}
        \item \texttt{sizeof(long) = 4}
        \item \texttt{sizeof(long long) = 8}
        \item \texttt{sizeof(float) = 4}
        \item \texttt{sizeof(double) = 8}
        \item \texttt{sizeof(long double) = 8}
      \end{enumerate} 
    \end{definition}

  \subsection{Declaration vs Definition} 

    Variables can be \textbf{constructed} in two ways. 
    \begin{enumerate}
      \item We first \textbf{declare} a variable, which tells the compiler about the existence of the variable (\texttt{int x;}). Then, we can \textbf{define} the variable, which assigns it a literal (\texttt{x = 4;}). 
      \item We can \textbf{initialize} a variable, which both declares it and defines it at once (\texttt{int x = 4;}).
    \end{enumerate}

    \begin{enumerate}
      \item The \textbf{declaration} of a function states the existence of the function. 
        \begin{lstlisting}
          double foo(int x, double y); // one way 
          double foo(int, double); // another way 
        \end{lstlisting}
        This declaration is also called the \textbf{function prototype}, or the \textbf{function identifier}. 

      \item The \textbf{definition} of a function tells us the actual implementation. 
        \begin{lstlisting}
          double foo(int x, double y) {
            ...
          }
        \end{lstlisting}
    \end{enumerate}

  \subsection{Expressions}

    \begin{definition}[Expression]
      An \textbf{expression} is simply a line of code containing variables, operations, literals, and function names/calls. The process of executing an expression is called \textbf{evaluation}. The \textbf{type category} is simply the type of the value, object, or function that results from the evaluated expressions. The \textbf{value category} indicates whether the expression resolves to a value, an object, a function, or nothing (this list is exhaustive). 
    \end{definition}

\section{Translation} 

    Now that we've gotten the basics, we should learn more about the translation process so that we can avoid definition conflicts and know how to work with multi-file programs. 

    \begin{definition}[Translation]
      \textbf{Translating} C++ code to a binary consists of multiple steps: 
      \begin{enumerate}
        \item Preprocessing the code. 
        \item Compiling each file independently. 
        \item Linking all the files. 
      \end{enumerate}
      Conventionally, all of these are called \textit{compiling}, but it really isn't. 
    \end{definition}

  \subsection{Preprocessing} 

    When preprocessing, we do some boring stuff like removing comments. However, the main job is to take care of \textbf{preprocessing directives}, which are expressions with the \texttt{\#} symbol. The most obvious is the \texttt{\#include} directives, which \textbf{replaces the include directive with the contents of the included file}. That is, \texttt{\#include} is really just a way to substitute code.  
    \begin{enumerate}
      \item including with angle brackets, e.g. \texttt{\#include <iostream>}, means that the compiler is looking for this file in the standard library files. 
      \item including with double quotes, e.g. \texttt{\#include "tensor.h"}, means that the compiler is looking for this file locally in your project directory. It means you've written it. 
    \end{enumerate}
    
    Other directives is the \texttt{\#define} directive. 
    \begin{enumerate}
      \item You can define it to substitute text. It is conventionally in all upper-case.  
        \begin{lstlisting}
          #define NAME "Muchang"  // all instances of NAME will be replaced with "Muchang"
        \end{lstlisting}
      \item Or you can define it without substitution text, where further occurrences of \texttt{NAME} will be replaced by nothing. 
        \begin{lstlisting}
          #define NAME 
        \end{lstlisting}
    \end{enumerate}

    The second isn't used for substitution, but rather for \textbf{conditional compilation}, which can be useful. You just wrap C++ statements around as such.

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      #ifdef NAME 
      ... 
      #endif
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      #ifndef NAME 
      ... 
      #endif
      
    \end{lstlisting}
    \end{minipage} 

    To see the output after preprocessing, use the \texttt{-E} flag. 
    \begin{lstlisting}
      g++ main.cpp -E
    \end{lstlisting}

  \subsection{Compilation} 

    We only compile files one at a time and independently. When the compiler compiles a file, it goes through each line sequentially. Therefore, we must ensure that all functions/variables/classes are \textit{declared} first before they are called. \textit{Forward declaration} makes this a lot easier. 

    There is a difference between a declaration and a definition. 

    \begin{definition}[ODR]
      Remember the ODR (One Definition Rule): 
      \begin{enumerate}
        \item Within a file, each function, variable, type, or template in a given scope can only have one definition. Definitions occurring in different scopes (e.g. local variables defined inside different functions, or functions defined inside different namespaces) do not violate this rule. 

        \item Within a program, each function or variable in a given scope can only have one definition.\footnote{This rule exists because programs can have more than one file. For example, if you have two definitions of \texttt{int add(int, int)} in two different files, the linker does not know which one to connect the declaration to.}
      \end{enumerate}
      To be honest, ODR 2 really implies ODR 1, since once the directives are preprocessed or the object files are linked, we are really left with one executable file. 
    \end{definition} 

    \begin{example}[ODR 1 Violation] 
      The following shows that in the same file, there are multiple variables defined in the function scope of \texttt{main}, and there are two definitions of \texttt{foo} in the global scope. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          int main() {
            int x; 
            int x;

            return 0;
          } 
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          int foo() { return 5; }
          int foo() { return 5; }

          int main() {
            std::cout << foo();
            return 0;
          } 
        \end{lstlisting}
      \end{minipage}
    \end{example}

    \begin{example}[ODR 2 Violation]
      Say that \texttt{main.cpp} has the \texttt{main()} method that calls on \texttt{int add(int x, int y)}, which is forward declared. However, say that we define add in two places. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // foo.cpp 
          int add(int x, int y) {
            return x + y; 
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // bar.cpp 
          int add(int x, int y) {
            return x + y; 
          }
        \end{lstlisting}
      \end{minipage}
      Then, if we run \texttt{g++ main.cpp foo.cpp bar.cpp}, the linker will complain that there is a function redefinition. 
    \end{example}

  \subsection{Linking} 

    Remember, declaration is not the same thing as definition. When we do the linking, we go through all the source files in our project and match all the declarations with our definitions. The source files must all be written in the compile command. 

    \begin{lstlisting}
      g++ main.cpp add.cpp
      g++ add.cpp main.cpp
    \end{lstlisting}

    This should not be order dependent. The source files can be 

    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        // main.cpp 
        int add(int x, int y); // declaration

        int main() {  
          int z = add(2, 3); 
          return 0; 
        }
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        // add.cpp
        // definition
        int add(int x, int y) { 
          return x + y;
        }
        .
        .
      \end{lstlisting}
    \end{minipage}

  \subsection{Header Files} 

    To be honest, we can just include forward declarations everywhere, but this does not scale well to large projects. If we had a set of declarations that we wanted to use over a bunch of files, we can package them nicely using a \textbf{header file}. 
    
    If we have a bunch of functions and classes written in \texttt{foo.cpp}, then it is conventional to write a \texttt{foo.h} that contains all the declarations of these expressions. Then, whenever we need to write a new file \texttt{bar.cpp} that uses functions from \texttt{foo.cpp}, we can just \texttt{\#include "foo.h"}, which replaces this directive (by the preprocessor) with all the forward declarations in \texttt{foo.h}. Boom easy. 

    \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        // add.cpp
        int add(int x, int y) { 
          return x + y;
        }
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        // add.h 
        int add(int x, int y); 
        .
        .
      \end{lstlisting}
    \end{minipage}

    Therefore when we call \texttt{add} in \texttt{main.cpp}, we can just \texttt{\#include "add.h"} to put in the declarations, making everything good. Conventionally, it is best practice for a source file to also include its paired header (e.g. \texttt{add.cpp} should also contain \texttt{\#include "add.h"} at the top). This allows the compiler to discover inconsistencies between the two files, and this extra cost is negligible.\footnote{\href{here}{https://www.learncpp.com/cpp-tutorial/cpp-faq/\#pairedheader}} 

    \begin{example}[Definitions inside Header Files]
      You should not add definitions (only declarations) to header files since if they are included in multiple header files, then we would have different definitions of the same function, leading to ODR 2 violation. Take a look at the following. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // square.h
          int getSquareSides() {
              return 4;
          } 
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // wave.h 
          #include "square.h"
        \end{lstlisting}
      \end{minipage}

      With the following. 
      \begin{lstlisting}
        #include "square.h"
        #include "wave.h" 
        int main() {
          return 0;
        }
      \end{lstlisting}
      This won't compile since 
      \begin{enumerate}
        \item by including \texttt{square.h}, we have defined \texttt{getSquareSides()} in the global scope of \texttt{main.cpp}. 
        \item by including \texttt{wave.h}, we have included \texttt{square.h} which then substitutes this line with the definition of \texttt{getSquareSides()} again. 
      \end{enumerate}
      This is an ODR 1 violation. 
    \end{example} 

    The simple fix to the above is to just remove the \texttt{\#include "wave.h"}, but what if we needed some other function from \texttt{wave.h}? Resolving this issue is not trivial if say, half of the functions in \texttt{square.h} is needed in \texttt{wave.h} and the other half is needed in \texttt{main.cpp}. We must include both of them in \texttt{main.cpp}, but then we have an inevitable redefinition. Without separating \texttt{square.h} into separate files, solving this is impossible. 

    Even if we didn't have definitions in header files in the first place (which is bad practice in general), repeated declarations, which are still fine, are also not really ideal either. Furthermore, custom types are typically defined in header files, so redefining them leads to an ODR violation. 
    
    \begin{definition}[Header Guards]
      Fortunately, we have \textbf{header guards}, which are conditional compilation directives that tell the compiler to include a header file at most once to the main file. You can do this in two ways. 
      \begin{enumerate}
        \item Just put this to the top of the header file. The compiler will take care of redeclaration/redefinitions for you. This isn't always fail-safe. 
        \begin{lstlisting}
          #pragma once
        \end{lstlisting} 

      \item More manually, we can use a conditional compilation directive. Put this on the top of the header. 
        \begin{lstlisting}
          #ifndef HEADERFILE_H
          #define HEADERFILE_H 
          
          ...Header Contents...

          #endif 
        \end{lstlisting}
        In the beginning, \texttt{HEADERFILE\_H} is not defined, so we include all of this. In a second inclusion though, \texttt{HEADERFILE\_H} is defined, so the preprocessor removes this. 
      \end{enumerate}

      Note that header guards limit the number of times a header can be included in a single given file, but the header may still be repeated across separate project files. This is what we want. 
    \end{definition}

  \subsection{Namespaces} 

    Perhaps we want to have two functions of the same name, but we get a redefinition error. This is where namespaces come in. 

    \begin{definition}[Namespace]
      We can wrap each function around a \textbf{namespace}, which is written with an upper-case letter. 
      \begin{lstlisting}
        namespace Foo {
          int bar() {}
        }
      \end{lstlisting}
      To access identifiers defined in the namespace, we must use the \textbf{scope resolution operator} \texttt{::}. If no scope resolution is given, or an empty one is given, then we look for the identifier in the global namespace. 
      \begin{lstlisting}
        int x = Foo::bar();   // Foo namespace
        int y = bar();        // global namespace
        int z = ::bar();      // global namespace 
      \end{lstlisting}
    \end{definition} 

    \begin{example}[Namespace]
      Say that we have two files with the same-name function in different namespaces. 
      
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          namespace Foo {
            int doSomething(int x, int y) {
              return x + y;
            }
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          namespace Goo {
            int doSomething(int x, int y) {}
              return x - y;
            }
          }
        \end{lstlisting}
      \end{minipage}

      When we put our forward declarations, we must make sure to add the namespace using the scope resolution operator. If the namespace is not included, then the linker will look for the function in the global namespace rather than the user-defined namespace. 

      \begin{lstlisting}
        int doSomething(int x, int y); // this results in an error 
        int Foo::doSomething(int x, int y); // correct
        int Goo::doSomething(int x, int y); // correct

        int main() {
            std::cout << Foo::doSomething(4, 3) << '\n'; 
            std::cout << Goo::doSomething(4, 3) << '\n'; 
            return 0;
        }
      \end{lstlisting}
    \end{example} 

    Let's talk about a few properties of namespaces. 

    \begin{lemma}[Identifiers in Parent Namespaces]
      If an identifier $A$ in a namespace uses another identifier $B$ without a scope resolution, then $A$ will look for $B$ within $A$'s namespace. If no matching identifier for $B$ is found, then the compiler will then check each containing namespace in sequence to see if a match is found, with the global namespace being checked last. 

      \begin{lstlisting}
        #include <iostream>
        void print() // this print() lives in the global namespace
        {
          std::cout << " there\n";
        }

        namespace Foo {
          void print() // this print() lives in the Foo namespace
          {
            std::cout << "Hello";
          }

          void printHelloThere()
          {
            print();   // calls print() in Foo namespace
            ::print(); // calls print() in global namespace
          }
        }

        int main() {
          Foo::printHelloThere(); // prints "Hello there" 
          return 0;
        } 
      \end{lstlisting}
    \end{lemma}

    \begin{lemma}[Nested Namespaces]
      Namespaces can be nested as well, either of 2 ways. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          namespace Foo {
            namespace Goo{
              ... 
            }
          }
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          namespace Foo {

          }

          namespace Foo::Goo {

          }
        \end{lstlisting}
      \end{minipage}
    \end{lemma}

    \begin{lemma}[Namespace aliases]
      You can shorten namespaces using \textbf{namespace aliases}. 
      \begin{lstlisting}
        namespace Active = Foo::Goo; 
        int x = Active::doSomething(); 
      \end{lstlisting}
    \end{lemma}

    \begin{lemma}[Using Namespace]
      The \textbf{using namespace} is a directive that allows access to all members of a namespace. 
    \end{lemma}

\section{Constants and Constant Expressions}

    One of the greatest advantages of C++ is that it is compiled, which allows us to reduce the runtime by offloading computations into compile time. This is particularly important for speed-sensitive programs such as algorithmic trading. Therefore, we should be familiar with consts and constexprs. 

  \subsection{Compiler Optimization} 

    By default, all expressions are evaluated at runtime, but compilers have different levels of optimization. Here are some methods in which it optimizes, which follow the \textbf{as-if rule} that states that a compiler can modify a program however it likes in order to produce more optimized code, so long as those modification do not affect a program's observable behavior. 

    \begin{definition}[Constant Folding] 
      The compiler replaces expressions that have literal operands with the result of the operation, e.g. \texttt{3 + 4} automatically gets evaluated to \texttt{7}. 
    \end{definition}

    \begin{definition}[Constant Propagation]
      In the code below, \texttt{x} is initialized to be \texttt{7} and will be stored in the memory allocated for \texttt{x}. On the next line, the program will go out to memory to fetch the same value to print. This is redundant. Therefore, the compiler will realize that \texttt{x} always has the constant value \texttt{7} and will replace all instances of \texttt{x} with \texttt{7}. 
      \begin{lstlisting}
        #include <iostream>

        int main() {
          int x { 7 };
          std::cout << x << '\n';
          return 0;
        } 
      \end{lstlisting}
    \end{definition}

    \begin{definition}[Dead Code Elimination]
      The compiler removes all code that has no noticeable effect on the program's behavior. Note that this is not a preprocessing step. 
      \begin{lstlisting}
        #include <iostream>
        int main() {
          int x { 7 }; // this line is removed. 
          std::cout << 7 << '\n';
          return 0;
        } 
      \end{lstlisting}
    \end{definition} 

    A slightly higher level optimization evaluates certain expressions during compile time. 

    \begin{definition}[Compile-Time Expression]
      A \textbf{compile-time expression} is an expression that must always be capable of being evaluated at compile-time. 
    \end{definition}

    \begin{example}
      Say we have the following code. 
      \begin{lstlisting}
        const double x { 1.2 };
        const double y { 3.4 };
        const double z { x + y }; 
      \end{lstlisting} 
      \texttt{z} may or may not be evaluated to \texttt{4.6} at runtime. By default it is evaluated at runtime, but it depends on the compiler and level of optimization. 
    \end{example}

    Shifting some of the evaluation from runtime to compile time makes your code faster, though it may make it more difficult to debug since the compiler might rearrange the logic of your program (though in an equivalent way). Therefore, at runtime, the compiled code no longer correlates with the original source code. 
  
  \subsection{Constants}

    Now we talk about a seemingly separate, but very related concept. 

    \begin{definition}[Constant Variables]
      \textbf{Named constants} are variables that cannot change. 
      \begin{enumerate}
        \item They cannot be declared and must be initialized since they cannot change. This is called \textbf{constant expression initialization}.
        \item If a variable can be made constant, it should be. It reduces bugs and gives more opportunity for compiler optimization, effectively reducing runtime and increasing compile time. 
        \item Function parameters that are \texttt{const} just tells the compiler that it won't be changed during the function execution. But since the variable is thrown away after the body, it doesn't really matter anyways. You can also return const types, but this is again a temporary copy and may impede compiler optimizations so it not recommended. 
        \item In a way, consts are just like object-like directives with substitution text, but consts follow scoping, so use consts whenever you can rather than macros. 
      \end{enumerate}
    \end{definition}

    \begin{theorem}
      All compiler-time expressions must be consts. However, a const variable does not guarantee that it will be evaluated in compile time. With only consts, only const \textit{integral} variables can be a part of a constant expression. No other const variable is allowed.
    \end{theorem}
    \begin{proof}
      It is not surprising to see that if an expression can be evaluated at compile time, it must be a const variable. Consider the contrapositive: if it wasn't a const variable, then it may be initialized or changed during runtime and therefore the expression cannot be evaluated at compile time. However, the converse is not true. 
    \end{proof}

  \subsection{Compile-Time Programming}  
    
    Notice that when we really want a section of code to be evaluated at compile-time, the best we can do is use const variables and hope that the compiler executes it. In other words, we are dependent on the sophistication of the compiler, which is not ideal. To allow more explicit control over which parts of code we want to execute at compile-time, we can use \textbf{compile-time programming}. In C++11, compile-time programming was introduced with constant expressions, or \textbf{constexpr}s.

    \begin{definition}[Constant Expression]
      A \textbf{constant expression} is an expression that must be entirely evaluatable at compile-time.\footnote{along with rules that determine how the compiler should handle these expressions.} They generally contain the following: 
      \begin{enumerate}
        \item Literals 
        \item Most operators with constant expression operands, e.g. \texttt{3 + 4}, \texttt{2 * sizeof(int)} 
        \item Constexpr variables  
        \item Constexpr function calls with constant expression arguments. 
      \end{enumerate}
      Any expression not a constant expression is called a \textbf{runtime expression}. The following cannot be used in a constant expression. 
      \begin{enumerate}
        \item Non-const variables (e.g. \texttt{int x = 3;}) 
        \item Const non-integral variables, even when they have a constant expression initializer (e.g. \texttt{const double d = 1.2}). To use such variables, we need to define them with \texttt{constexpr}. 
        \item Function parameters. 
      \end{enumerate}
      There is a complex list of literals, operators, and variables that can and cannot be used in constant expressions. 
    \end{definition}

    There are still two problems. First, the limitations of constant expressions not being able to contain const non-integral variables is quite restricting. Second, even if we did have a constant expression, the compiler will by default evaluate it at runtime. Fortunately, constexpr addresses both problems. 

    \begin{definition}[constexpr Keyword]
      The \textbf{constexpr} variable is always a compile-time constant. As a result, a constexpr variable must be initialized with a constant expression, otherwise a compilation error will result. Here are some examples. 
      \begin{lstlisting}
        constexpr double gravity = 9.8; // works for doubles now 
      \end{lstlisting} 
      Since a constexpr variable is really a constant expression, it is implicitly a const variable. 
    \end{definition} 

\section{Lvalue and Rvalues} 

  \subsection{Lvalues and Rvalues}
  
    There are two types of a value expressions prior to C++11. 
    \begin{enumerate}
      \item An \textbf{lvalue} expression evaluates to a named object (variable) or function. A \textbf{modifiable lvalue} can be modified, while a \textbf{non-modifiable lvalue} cannot be modified (because it is const or constexpr). 
      \item An \textbf{rvalue} expression evaluates to everything else, such as unnamed objects (values), literals, or unnamed functions (anonymous functions). They are not identifiable (meaning they have to be used immediately) and only exist within the scope of the expression in which they are used. 
    \end{enumerate}

    \begin{example}[Assignment Statement]
      An \textbf{assignment statement} requires the use of the \textbf{assignment operator} and two subexpressions, which are the operands. Note that the whole statement is also an expression. 
      \begin{lstlisting}
        int x = 2; 
      \end{lstlisting}
      \begin{enumerate}
        \item It requires the left operand to be a modifiable lvalue expression, and
        \item the right operand to be an rvalue expression. 
      \end{enumerate}
    \end{example} 

    \begin{lemma}[Implicit Conversion of lvalue to rvalue]
      It turns out that in assignment statements, lvalues can also be on the right side since they are implicitly converted to rvalues. 
    \end{lemma}

    This gets very important when learning about references later on.

\section{Control Flow and Error Handling}  

    We are probably familiar with for loops and if statements, but C++ gives us a much wider suite of keywords and operators to choose from. In here, we revisit three things: 
    \begin{enumerate}
      \item \textit{Conditional statements}. We visit them by comparing if and switch statements, along with seeing how they may be evaluated at compile time when using constexprs. 
      \item \textit{Loops}. We can approach them more formally now that we know about scope and duration. 
      \item \textit{Assert and exit statements}. 
    \end{enumerate}

  \subsection{If Statements} 

    Constexpr if statements can be evaluated at compile time, so we end up compiling only the block under the condition that evaluates to true.   

  \subsection{Switch Statements}

  \subsection{Assert and Static Assert} 

    Assert statements can be turned off with the \texttt{\#NDEBUG} directive. \texttt{static\_assert} checks at compile time, so the condition must be a constant expression. 

  \subsection{Halt Statements}

\section{Named Functions} 

    Now we revisit named functions (as opposed to anonymous functions, which we need to know about structs for), and explore it a bit more. This is our first compound type that we will delve into. 

    \begin{definition}[Named Functions]
      Note that when a function is called, it creates a new stack and \textit{copies} the arguments into the new stack frame. It does the evaluation and returns whatever expression by again \textit{copying}, and all the variables in the stack are destroyed. It is a \textit{compound type} of form 
      \begin{lstlisting}
        T funcName(T arg1, T arg2, ...)
      \end{lstlisting}
    \end{definition}

    This picture of a function is especially important when dealing with its nuances. 
  
  \subsection{Inline Functions} 

    When we make a call to a function, we add another frame to our call stack, store the address of our stack pointer, and then execute the function body in the new stack frame. This is known as the \textbf{function overhead}. 

    \begin{definition}[Inline Functions]
      We can avoid this by using the \texttt{inline} keyword to define \textbf{inline functions}. 
      \begin{lstlisting}
        inline int add(int x, int y) {
          return x + y; 
        }
      \end{lstlisting}
      As the name suggests, the compiler essentially replaces the function call with the function body, treating as it if it were all on the same stack frame. 
    \end{definition}

    We get the benefits of no function overhead while still maintaining modularity of our code. However, abusing this increases the size of our compiled executable, which may make our program slower. Most of the time, the compiler is better at optimizing this.  

  \subsection{Overloading} 

    Functions can be overloaded based on their parameters, and the compiler will try to match the function call to the appropriate overload based on the arguments, called \textbf{overload resolution}. The number of parameters and types of parameters are used in differentiating, but not the return type. 

  \subsection{Deleting}

    Sometimes, functions may use implicit type conversion to call. For example, look at the code. 

    \begin{lstlisting}
      #include <iostream>

      void printInt(int x) {
        std::cout << x << '\n';
      }

      int main() {
        printInt(5);    // okay: prints 5
        printInt('a');  // prints 97 -- does this make sense?
        printInt(true); // print 1 -- does this make sense?
        return 0;
      }
    \end{lstlisting}

    \begin{definition}[Function Deleting]
      If we want to enforce that a function cannot take other parameters, we can define that function as deleted using the \texttt{= delete} specifier. A call to a deleted function will halt compilation. 
      \begin{lstlisting}
        #include <iostream>

        void printInt(int x) {
            std::cout << x << '\n';
        }

        void printInt(char) = delete; // calls to this function will halt compilation
        void printInt(bool) = delete; // calls to this function will halt compilation

        int main() {
          printInt(97);   // okay

          printInt('a');  // compile error: function deleted
          printInt(true); // compile error: function deleted

          printInt(5.0);  // compile error: ambiguous match

          return 0;
        } 
      \end{lstlisting}
    \end{definition}

  \subsection{Default Arguments} 

    Explicit arguments must all come before any default argument. 

    Default arguments can not be redeclared, and must be declared before use. Therefore, for forward declarations, the default argument can be declared in either the forward declaration or the function definition, but not both.   

    However, note that default arguments can lead to ambiguous matches. 

  \subsection{Template Functions}

    \begin{definition}[Template Functions]
      Let's talk about the syntax. We start with the keyword \texttt{template}, which tells the compiler that we're creating a template. Next we specify all the template parameters that our template will use inside the brackets. For each type template parameter, we use the keyword \texttt{template} or \texttt{class}, followed by the name of the type template parameter (e.g. \texttt{T}). 
      \begin{lstlisting}
        template <typename T> 
        T add(T x, T y) {
          return x + y; 
        } 
      \end{lstlisting}
      Function templates are not actually functions. Their code isn't compiled or executed directly. Instead, function templates have one job: to generate functions (that are compiled and executed), called \textbf{function instantiation}. The instantiated functions are called \textbf{function instances}, and they are \textit{implicitly inline}. When we call a function with a new template argument, it gets instantiated during translation. Therefore, if we called \texttt{add} with arguments \texttt{int} and \texttt{double}, the result of our compilation would look as if we had explicitly defined the following functions. 
      \begin{lstlisting}
        template<>
        int max<int>(int x, int y) // the generated function max<int>(int, int)
        {
            return (x < y) ? y : x;
        }

        template<>
        double max<double>(double x, double y) // the generated function max<double>(double, double)
        {
            return (x < y) ? y : x;
        }
      \end{lstlisting}
    \end{definition}

    Here are some properties. 

    \begin{lemma}[Normal Function Call Priority]
      Template functions can be called in several ways. However, a normal function call syntax will prefer a non-template function over an equally viable function instantiated from a template. 

      \begin{lstlisting}
        template <typename T>
        T max(T x, T y)
        {
            std::cout << "called max<int>(int, int)\n";
            return (x < y) ? y : x;
        }

        int max(int x, int y)
        {
            std::cout << "called max(int, int)\n";
            return (x < y) ? y : x;
        }

        int main()
        {
            std::cout << max<int>(1, 2) << '\n'; // calls max<int>(int, int)
            std::cout << max<>(1, 2) << '\n';    // deduces max<int>(int, int) (non-template functions not considered)
            std::cout << max(1, 2) << '\n';      // calls max(int, int)

            return 0;
        } 
      \end{lstlisting}
    \end{lemma} 

    \begin{lemma}[Static Local Variables]
      If a static local variable is defined in a template function, every function instance will have its own copy of the static local variable. 
      \begin{lstlisting}
        #include <iostream>

        template <typename T>
        void printIDAndValue(T value) {
          static int id{ 0 };
          std::cout << ++id << ") " << value << '\n';
        }

        int main() {
          printIDAndValue(12);    // 1) 12
          printIDAndValue(13);    // 2) 13 
          printIDAndValue(14.5);  // 1) 14.5
          return 0;
        } 
      \end{lstlisting}
    \end{lemma} 

    \begin{lemma}[No Implicit Type Conversions]
      Unlike explicit functions, function instances are strict in that they will not do any implicit type conversions. In the left, the call to \texttt{max} is okay since the int will be converted to a double. On the right, however, will generate an error. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          double max(double x, double y) {
            return (x < y) ? y : x;
          }

          int main() {
            std::cout << max(2, 3.5) << '\n'; // okay
            return 0;
          }
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          template <typename T>
          T max(T x, T y) {
            return (x < y) ? y : x;
          }

          int main() {
            std::cout << max<double>(2, 3.5) << '\n'; // error
            return 0;
          }
        \end{lstlisting}
      \end{minipage}
    \end{lemma} 

    \begin{definition}[Multiple Template Type Parameters]
      
    \end{definition}

    \begin{definition}[Overloading Function Templates]
      
    \end{definition}

    \begin{lemma}[Function Templates in Multiple Files]
      When we forward declare a function template, we cannot just define the template function in another file. 

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code} 
          // main.cpp
          template <typename T>
          T addOne(T x); // template forward declaration

          int main() {
              std::cout << addOne(1) << '\n';
              std::cout << addOne(2.3) << '\n';
              return 0;
          }
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // add.cpp
          template <typename T>
          T addOne(T x) {
            return x + 1;
          }
          .
          .
          .
          .
          .
        \end{lstlisting}
      \end{minipage}

      This would get a linker error since the linker cannot see the definitions of all the \textit{function instances}. There are two solutions to this. 
      \begin{enumerate}
        \item We can use a header file that contains the function template definition and add that along with a header guard. This is recommended. 

        \noindent\begin{minipage}{.45\textwidth}
          \begin{lstlisting}[]{Code}
            // main.cpp
            template <typename T> 
            T add(T x, T y); 

            int main() { 
              std::cout << add(1, 2) << "\n";
              std::cout << add('1', 'a') << "\n";
              return 0; 
            }
          \end{lstlisting}
          \end{minipage}
          \hfill
          \begin{minipage}{.44\textwidth}
          \begin{lstlisting}[]{Output}
            // add.cpp
            template <typename T>
            T add(T x, T y) {
              return x + y;
            }
            template int add<int>(int x, int y);
            template char add<char>(char x, char y);
            .
          \end{lstlisting}
        \end{minipage}

        \item We can explicitly define all the necessary function instances.\footnote{Before C++20, only integral, enumeration type, or constexpr can be a template parameter.} This might be okay if we are using enum types. 

        \noindent\begin{minipage}{.45\textwidth}
          \begin{lstlisting}[]{Code}
            // main.cpp
            #include "add.h"

            int main() {
              std::cout << add(1, 2) << "\n";
              std::cout << add('a', 'b') << "\n";
              return 0;
            }
          \end{lstlisting}
          \end{minipage}
          \hfill
          \begin{minipage}{.44\textwidth}
          \begin{lstlisting}[]{Output}
            // add.cpp
            #pragma once

            template <typename T>
            T add(T x, T y) {
              return x + y;
            }
            .
          \end{lstlisting}
        \end{minipage}
      \end{enumerate}
    \end{lemma}

  \subsection{Non-Type Template Parameters} 

    As of C++20, function parameters cannot be constexpr. Therefore, we cannot enforce that these parameters should be fixed at compile time. There may be times where we would like to build a constexpr from the function parameters (say, to do a \texttt{static\_assert} check on some value), but function parameters cannot be constexpr and therefore this is impossible. 

    \begin{definition}[Non-Type Template Parameters]
      It turns out that non-type template parameters can indeed be constexpr, so they can indeed be used to build constexpr and therefore evaluate at compile time. Again, function instantiations are inline. 
    \end{definition}

    \begin{example}[Motivation]
      Say that we have this code. 

      \begin{lstlisting}
        double getSqrt(double d) {
          assert(d >= 0.0 && "getSqrt(): d must be non-negative");
          return std::sqrt(d);
        }

        int main() {
            std::cout << getSqrt(5.0) << '\n';
            std::cout << getSqrt(-5.0) << '\n';
            return 0;
        } 
      \end{lstlisting}

      When we run \texttt{getSqrt(-5.0)}, we will runtime assert out. While this is better than nothing, because \texttt{-5.0} is a literal (and implicitly constexpr), it would be better if we could \texttt{static\_assert} so that errors such as this one would be caught at compile-time. However, \texttt{static\_assert} requires a constant expression, and function parameters can’t be constexpr... However, if we change the function parameter to a non-type template parameter instead, then we can do exactly as we want. The following will fail to compile. 
      \begin{lstlisting}
        template <double D> 
        double getSqrt() {
          static_assert(D >= 0.0, "getSqrt(): D must be non-negative");
          return std::sqrt(D);
        }

        int main() {
            std::cout << getSqrt<5.0>() << '\n';
            std::cout << getSqrt<-5.0>() << '\n';
            return 0;
        } 
      \end{lstlisting}
    \end{example}

    Template parameters can't always be used over regular parameters since the parameter itself may not be a constant expression, so regular parameters are still necessary for runtime evaluation. Here are some other properties. 

    \begin{lemma} 
      Non-type template parameters can be implicitly type-casted. 
    \end{lemma}

    \begin{lemma} 
      We can use type-deduction for non-type template parameters using \texttt{auto}. 
      \begin{lstlisting}
        template <auto N> // deduce non-type template parameter from template argument
        void print() {
          std::cout << N << '\n';
        }

        int main() {
          print<5>();   // N deduced as int `5`
          print<'c'>(); // N deduced as char `c`
          return 0;
        } 
      \end{lstlisting}
    \end{lemma} 

\section{References} 

    References and pointers are the next compound types that we will look at. While the language we have explained so far is pretty good, there is a problem. We've said that a variable is simply an object with a name. Since it's an object, it has an address where it stores some value at that address. Say that we want to create two separate variables that has the same address, so that we can have two paths to modify the value. We cannot do this since the new initialized variable stores a copy of the value at a different address. 
    \begin{lstlisting}
      int x = 2; // stores 2 at address A
      int y = y; // stores 2 at address B
    \end{lstlisting}
    Therefore modifying \texttt{y} will not modify \texttt{x}. This problem of not being able to create two names that bind to the same object is problematic, and this is a generalization of two more specific problems. 

    \begin{example}[Copying During Functions Calls May Be Expensive]
      We have explained that when calling a function, it copies all of the arguments in the stack to the new stack frame. This may be good for isolation, but this is a double-edged sword. If we have a large object to copy to do some read operations on, this may be inefficient. 
    \end{example}

    \begin{example}[In-Place Modification]
      If we want a function to modify the value of one of its arguments, this is impossible since it just copies the argument in a new variable, modifies this, and then gets deleted. We could have it return the modified object to override the old one in the parent frame, but this copying of the return value is again slow.   
    \end{example}

    This is where references and pointers come into the rescue. They are similar in that they mainly serve the same purpose, but their behaviors can differ. Generally, references are considered safe while pointers are considered dangerous. There are things that pointers can do that references cannot, and vice versa. 

  \subsection{Lvalue References}
  
    \begin{definition}[Lvalue Reference]
      A \textbf{reference} is an \textit{alias} for an existing variable (we say it is \textbf{bound} to the variable), not a variable (and therefore not an object) itself.\footnote{If possible, the reference may be replaced with the variable name by the compiler. This isn't always possible, so perhaps references may require storage.} However, whatever we do to the reference will persist in the original variable. There are two types of references. 
      \begin{enumerate}
        \item \texttt{lvalue references} are references that refer to an lvalue. 99\% of the time we work with lvalue references. 
        \begin{lstlisting}
          int x = 2; 
          int& y = x; 
        \end{lstlisting}

        \item \texttt{rvalue references} are references that refer to an rvalue. 
      \end{enumerate} 
      A reference evaluates to the variable when used in an expression. 
    \end{definition}

    Here we list a few important properties. 

    \begin{lemma}[Typechecking]
      Lvalue references will (usually) only bind to an object matching its referenced type. 
    \end{lemma}

    \begin{lemma}[Initialization]
      Lvalue references must be initialized. They cannot be declared. 
    \end{lemma}

    \begin{lemma}[No Reseating]
      Lvalue references can't be reseated (changed to refer to another object). 
    \end{lemma}

    \begin{lemma}[Scope and Duration]
      Lvalue references follow the same scoping and duration rules that normal variables do. 
    \end{lemma} 

    \begin{lemma}[References of References]
      You cannot have references of references, since the right-expression in the assignment statement will evaluate to the variable. 
      \begin{lstlisting}
        int x = 5; 
        int &y = x; 
        int &z = y;   // y evaluates to x, so z is still a reference to int
      \end{lstlisting}
    \end{lemma}

    \begin{lemma} 
      Lvalue references and referents have independent lifetimes. An lvalue reference should always be initialized after the referent. However, one can by destroyed before the other. 
      \begin{enumerate}
        \item If the reference is destroyed before the referent, this is fine. 
        \item If the referent is destroyed before the reference, this results in a \textbf{dangling reference}. 
      \end{enumerate}
    \end{lemma}

  \subsection{Rvalue References}

    Rvalue references are useful in that they can extend the lifespan of the object they are initialized with to the lifespan of the rvalue reference. 

    \begin{definition}[Rvalue Reference]
      
    \end{definition}

  \subsection{Pass and Return by Reference}

    \begin{theorem}[Object must outlive Function]
      The programmer must be sure that the object being referenced outlives the function returning the reference. Otherwise, the reference will be let dangling. 
    \end{theorem}

\section{Pointers} 

    \begin{definition}[Pointer]
      A \textbf{pointer} is an object that holds a memory address as its value. Given an address, we can \textbf{dereference} them with \texttt{*} and get their address using \texttt{\&}. 
      \begin{lstlisting}
        int x = 4; 
        int* y = &x; 
        std::cout << y << '\n'; 
        std::cout << *x << '\n'; 
      \end{lstlisting} 
      We can modify what the value that the pointer points to by dereferencing the pointer. If we have a const variable, then we must use a const pointer, which must be initialized. 
      \begin{lstlisting}
        const int x = 4;  
        const int *p = &x;  // good
        int *p = &x;        // compilation error
      \end{lstlisting}
    \end{definition} 

    Immediately this seems extremely similar to lvalue references. Here we list a few properties which help differentiate them. 

    \begin{lemma}[Typechecking]
      Pointers will (usually) only bind to an object matching its pointed type. 
    \end{lemma}

    \begin{lemma}[Declaration is Okay]
      Pointers can be declared rather than initialized. If it is, then it is known as a \textbf{wild pointer}. Rather, we should initialize it to null to make it a \textbf{null pointer}. We can use the \texttt{nullptr} literal. 
      \begin{lstlisting}
        int* p; 
        int* q = nullptr // null pointer since it's not holding address
      \end{lstlisting}
      Dereferencing both a wild and null pointer leads to undefined behavior. Null pointers are falsy, so we can use them to evaluate whether we have a null pointer. 
    \end{lemma}

    \begin{lemma}[Reseating Allowed]
      Pointers can be reseated, meaning that we can change the address that the pointer is pointing to. 
      \begin{lstlisting}
        int x = 3; 
        int y = 4; 
        int *p = &x; 
        *p = &y;      // points now to &y from &x
      \end{lstlisting}
    \end{lemma} 

    We can see that through both references and pointers, we can indirectly access an object. References may be more convenient since the dereferencing happens implicitly while for pointers, we must explicitly use the \texttt{*} operator. 

    It's worth noting that the address of operator doesn't return a literal, but rather a pointer variable that stores the address. 
    \begin{lstlisting}
      int x = 5; 
      std::cout << &x // returns pointer, not address literal
    \end{lstlisting}

    Again, if you destroy the object that the pointer is pointing to, then we get a \textbf{dangling pointer}, which leads to undefined behavior. It is easy to test whether a pointer is null or not, but if it isn't, there is no easy way to determine if it's dangling. 

  \subsection{Pass and Return by Address} 

    In addition to pass by value and reference, we can pass in the address of an object as an argument into a function. 

    \begin{definition}[Pass by Address]
      Given a function that takes in a pointer $p$, we can interpret it as 
      \begin{enumerate}
        \item a pass by address of the object type $p$ is pointing to. 
        \item a pass by value of the pointer $p$
      \end{enumerate}
      Therefore, the address will be copied, but the actual object will not be. 

      \begin{lstlisting}
        int doSomething(int* p);  
      \end{lstlisting}
    \end{definition}  

  \subsection{Smart, Shared, and Unique Pointers} 

  \subsection{Function Pointers}

\section{Enumerations} 

  If we wanted to define a new type that takes values in some discrete space, then we can use an enum. 

  \begin{definition}[Unscoped Enumerations]
    An \textbf{enumeration} is a compound data type whose values are restricted to a set of symbolic constants, called \textbf{enumerators}. These enumerators will implicitly convert to integral values as such. 
    \begin{lstlisting}
      enum Color {
        red,    // 0
        green,  // 1 
        blue    // 2
      };

      int main() {
        Color shirt = red; 
        std::cout << shirt; // prints 0
      }
    \end{lstlisting}
    They must be fully defined before we can use it. A forward declaration is not sufficient. Enumerations are implicitly constexpr. Unscoped enumerations have the same scope as where they are defined in. If they are defined in the global namespaces, then they have global scope. 
  \end{definition}

  \begin{theorem}[Integral Labels can be Explicitly Assigned]
    We can actually explicitly label. 
    \begin{lstlisting}
      enum Animal {
        cat = -3,    // values can be negative
        dog,         // -2
        pig,         // -1
        horse = 5,
        giraffe = 5, // shares same value as horse
        chicken,     // 6
      };
    \end{lstlisting}
  \end{theorem} 

\section{Structs} 

  \begin{definition}[Structs]
    \textbf{Structs} are compound types that allow you to store multiple values of different types. 
    \begin{lstlisting}
      struct Employee {
          int id {};
          int age {};
          double wage {};
      };

      int main() {
          Employee frank = { 1, 32, 60000.0 }; // copy-list initialization using braced list
          Employee joe { 2, 28, 45000.0 };     // list initialization using braced list
          Employee bob {2, 28}                 // bob.wage value-initialized to 0.0
          return 0;
      } 
    \end{lstlisting}
  \end{definition}

\section{Classes} 

  \subsection{Basics} 

    \begin{definition}[Class]
      A \textbf{class} is a keyword that is used to make a user-defined compound type. 
    \end{definition}

  \subsection{Functors} 

      \begin{definition}[Functors]
        Functors are callable objects. 
      \end{definition}

      This is similar to Python's \texttt{\_\_call\_\_()} dunder method. 

    \subsubsection{Anonymous Functions and Captures} 

      It's a bit weird that we talk about anonymous functions in the class, but this is exactly because lambda functions are implemented as classes under the hood. j

      \begin{definition}[Anonymous Functions]
        
      \end{definition} 

  \subsection{Inheritance}

\section{Virtual Functions} 

  

\section{Standard Library} 

    Now that we've built up the basics, we can go into the implementation of the data structures and algorithms in the standard library. 

  \subsection{String}

  \subsection{Array}

  \subsection{Vector}

\section{Dynamic Memory Allocation} 

  So far, we've worked only in the stack, where our variables were limited to its scope and were destroyed after the block ends. If we want to keep objects in a more persistent memory location, we use the heap.  

\section{Operator Overloading} 

\end{document}

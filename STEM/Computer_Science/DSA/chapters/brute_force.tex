\section{Brute Force Algorithms} 

\subsection{Basic Arithmetic}

  In here, we use basic deductions from elementary algebra to give us a starting point at which we analyze fundamental arithmetic algorithms. 

  \begin{theorem}[Complexity of Addition]
    The complexity of addition of two $O(N)$ values with $n$ bits is
    \begin{enumerate}
      \item $O(n)$ bit complexity. 
      \item $O(\log N)$ complexity. 
      \item $O(1)$ memory complexity. 
    \end{enumerate}
    By the same logic, the complexity of subtraction is 
    \begin{enumerate}
      \item $O(n)$ bit complexity. 
      \item $O(\log N)$ complexity. 
      \item $O(1)$ memory complexity. 
    \end{enumerate}
  \end{theorem}
  \begin{proof}
    To see bit complexity, we are really taking each bit of each number and adding them together, plus a potential carry operation. Therefore, we are doing a bounded number of computations per bit, which is $O(1)$, but we must at least read through all of the bits, making this $O(\max\{n, m\})$. 
  \end{proof}

  \begin{theorem}[Complexity of Multiplication]
    The complexity of multiplication of two values $N, M$ with bits $n, m$ is 
    \begin{enumerate}
      \item $O(n^2)$ bit complexity.\footnote{It turns out we can do better, which we will learn later.} 
      \item $O((\log n)^2)$ complexity. 
      \item 
    \end{enumerate}
  \end{theorem}

  \begin{theorem}[Complexity of Division]
    The complexity of multiplication of two values $N, M$ with bits $n, m$ is 
    \begin{enumerate}
      \item $O(n^2)$ bit complexity. 
      \item 
    \end{enumerate}
  \end{theorem}

  \begin{theorem}[Complexity of Modulus]
    The complexity of multiplication of two values $N, M$ with bits $n, m$ is 
    \begin{enumerate}
      \item $O(n^2)$ bit complexity. 
      \item 
    \end{enumerate}
  \end{theorem}

  \begin{theorem}[Complexity of Exponentiation]
    The complexity of multiplication of two values $N, M$ with bits $n, m$ is 
    \begin{enumerate}
      \item $O(n^2)$ bit complexity. 
      \item 
    \end{enumerate}
  \end{theorem}

  \begin{theorem}[Complexity of Square Root]
    The complexity of multiplication of two values $N, M$ with bits $n, m$ is 
    \begin{enumerate}
      \item $O(n^2)$ bit complexity. 
      \item 
    \end{enumerate}
  \end{theorem}

  \begin{definition}[Factorial]
    
  \end{definition}

\subsection{Lists} 

  \begin{definition}[Max and Min of List]
    
  \end{definition}

  \begin{definition}[Bubble Sort]

  \end{definition}

  \begin{definition}[Binary Search]
    
  \end{definition}

\subsection{Stack, Queues, Heaps}

  A heap is sort of in between a sorted array and an unsorted array. 

\subsection{Cryptography} 

  \begin{example}[GCD of Two Numbers]
    Take a look at the following algorithm. 
    \begin{lstlisting}
      def gcd(a, b): 
        if a == b: 
          return a
        elif a > b: 
          return gcd(a - b, b) 
        else: 
          return gcd(a, b - a)

      print(gcd(63, 210))
    \end{lstlisting}
  \end{example}

  \begin{definition}[Primality Testing]
    
  \end{definition}

  \begin{definition}[Integer Factorization]
    
  \end{definition}

\subsection{Matrix Operations}

  \begin{definition}[Matrix Multiplication]
    
  \end{definition}

  \begin{definition}[Singular Value Decomposition]
    
  \end{definition}

  \begin{definition}[QR Decomposition]
    
  \end{definition}

  \begin{definition}[LU Decomposition]
    
  \end{definition}

  \begin{definition}[Matrix Inversion]
    
  \end{definition}


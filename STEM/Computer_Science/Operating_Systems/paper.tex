\documentclass{article}

  % packages
    % basic stuff for rendering math
    \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
    \usepackage[utf8]{inputenc}
    \usepackage[english]{babel}
    \usepackage{amsmath} 
    \usepackage{amssymb}

    % extra math symbols and utilities
    \usepackage{mathtools}        % for extra stuff like \coloneqq
    \usepackage{mathrsfs}         % for extra stuff like \mathsrc{}
    \usepackage{centernot}        % for the centernot arrow 
    \usepackage{bm}               % for better boldsymbol/mathbf 
    \usepackage{enumitem}         % better control over enumerate, itemize
    \usepackage{hyperref}         % for hypertext linking
    \usepackage{fancyvrb}          % for better verbatim environments
    \usepackage{newverbs}         % for texttt{}
    \usepackage{xcolor}           % for colored text 
    \usepackage{listings}         % to include code
    \usepackage{lstautogobble}    % helper package for code
    \usepackage{parcolumns}       % for side by side columns for two column code
    

    % page layout
    \usepackage{fancyhdr}         % for headers and footers 
    \usepackage{lastpage}         % to include last page number in footer 
    \usepackage{parskip}          % for no indentation and space between paragraphs    
    \usepackage[T1]{fontenc}      % to include \textbackslash
    \usepackage{footnote}
    \usepackage{etoolbox}

    % for custom environments
    \usepackage{tcolorbox}        % for better colored boxes in custom environments
    \tcbuselibrary{breakable}     % to allow tcolorboxes to break across pages

    % figures
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepackage{float}            % for [H] figure placement
    \usepackage{tikz}
    \usepackage{tikz-cd}
    \usepackage{circuitikz}
    \usetikzlibrary{arrows}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
    \usepackage{graphicx}
    \usepackage{algorithmic}
    \usepackage{caption} 
    \usepackage{subcaption}
    \captionsetup{font=small}

    % for tabular stuff 
    \usepackage{dcolumn}

    \usepackage[nottoc]{tocbibind}
    \pdfsuppresswarningpagegroup=1
    \hfuzz=5.002pt                % ignore overfull hbox badness warnings below this limit

  % New and replaced operators
    \DeclareMathOperator{\Tr}{Tr}
    \DeclareMathOperator{\Sym}{Sym}
    \DeclareMathOperator{\Span}{span}
    \DeclareMathOperator{\std}{std}
    \DeclareMathOperator{\Cov}{Cov}
    \DeclareMathOperator{\Var}{Var}
    \DeclareMathOperator{\Corr}{Corr}
    \DeclareMathOperator{\pos}{pos}
    \DeclareMathOperator*{\argmin}{\arg\!\min}
    \DeclareMathOperator*{\argmax}{\arg\!\max}
    \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
    \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
    \newcommand{\braket}[2]{\langle #1 | #2 \rangle}
    \newcommand{\qed}{\hfill$\blacksquare$}     % I like QED squares to be black

  % Custom Environments
    \newtcolorbox[auto counter, number within=section]{question}[1][]
    {
      colframe = orange!25,
      colback  = orange!10,
      coltitle = orange!20!black,  
      breakable, 
      title = \textbf{Question \thetcbcounter ~(#1)}
    }

    \newtcolorbox[auto counter, number within=section]{exercise}[1][]
    {
      colframe = teal!25,
      colback  = teal!10,
      coltitle = teal!20!black,  
      breakable, 
      title = \textbf{Exercise \thetcbcounter ~(#1)}
    }
    \newtcolorbox[auto counter, number within=section]{solution}[1][]
    {
      colframe = violet!25,
      colback  = violet!10,
      coltitle = violet!20!black,  
      breakable, 
      title = \textbf{Solution \thetcbcounter}
    }
    \newtcolorbox[auto counter, number within=section]{lemma}[1][]
    {
      colframe = red!25,
      colback  = red!10,
      coltitle = red!20!black,  
      breakable, 
      title = \textbf{Lemma \thetcbcounter ~(#1)}
    }
    \newtcolorbox[auto counter, number within=section]{theorem}[1][]
    {
      colframe = red!25,
      colback  = red!10,
      coltitle = red!20!black,  
      breakable, 
      title = \textbf{Theorem \thetcbcounter ~(#1)}
    } 
    \newtcolorbox[auto counter, number within=section]{proposition}[1][]
    {
      colframe = red!25,
      colback  = red!10,
      coltitle = red!20!black,  
      breakable, 
      title = \textbf{Proposition \thetcbcounter ~(#1)}
    } 
    \newtcolorbox[auto counter, number within=section]{corollary}[1][]
    {
      colframe = red!25,
      colback  = red!10,
      coltitle = red!20!black,  
      breakable, 
      title = \textbf{Corollary \thetcbcounter ~(#1)}
    } 
    \newtcolorbox[auto counter, number within=section]{proof}[1][]
    {
      colframe = orange!25,
      colback  = orange!10,
      coltitle = orange!20!black,  
      breakable, 
      title = \textbf{Proof. }
    } 
    \newtcolorbox[auto counter, number within=section]{definition}[1][]
    {
      colframe = yellow!25,
      colback  = yellow!10,
      coltitle = yellow!20!black,  
      breakable, 
      title = \textbf{Definition \thetcbcounter ~(#1)}
    } 
    \newtcolorbox[auto counter, number within=section]{example}[1][]
    {
      colframe = blue!25,
      colback  = blue!10,
      coltitle = blue!20!black,  
      breakable, 
      title = \textbf{Example \thetcbcounter ~(#1)}
    } 
    \newtcolorbox[auto counter, number within=section]{code}[1][]
    {
      colframe = green!25,
      colback  = green!10,
      coltitle = green!20!black,  
      breakable, 
      title = \textbf{Code \thetcbcounter ~(#1)}
    } 
    \newtcolorbox[auto counter, number within=section]{algo}[1][]
    {
      colframe = green!25,
      colback  = green!10,
      coltitle = green!20!black,  
      breakable, 
      title = \textbf{Algorithm \thetcbcounter ~(#1)}
    } 

    \BeforeBeginEnvironment{example}{\savenotes}
    \AfterEndEnvironment{example}{\spewnotes}
    \BeforeBeginEnvironment{lemma}{\savenotes}
    \AfterEndEnvironment{lemma}{\spewnotes}
    \BeforeBeginEnvironment{theorem}{\savenotes}
    \AfterEndEnvironment{theorem}{\spewnotes}
    \BeforeBeginEnvironment{corollary}{\savenotes}
    \AfterEndEnvironment{corollary}{\spewnotes}
    \BeforeBeginEnvironment{proposition}{\savenotes}
    \AfterEndEnvironment{proposition}{\spewnotes}
    \BeforeBeginEnvironment{definition}{\savenotes}
    \AfterEndEnvironment{definition}{\spewnotes}
    \BeforeBeginEnvironment{exercise}{\savenotes}
    \AfterEndEnvironment{exercise}{\spewnotes}
    \BeforeBeginEnvironment{proof}{\savenotes}
    \AfterEndEnvironment{proof}{\spewnotes}
    \BeforeBeginEnvironment{solution}{\savenotes}
    \AfterEndEnvironment{solution}{\spewnotes}
    \BeforeBeginEnvironment{question}{\savenotes}
    \AfterEndEnvironment{question}{\spewnotes}
    \BeforeBeginEnvironment{code}{\savenotes}
    \AfterEndEnvironment{code}{\spewnotes}
    \BeforeBeginEnvironment{algo}{\savenotes}
    \AfterEndEnvironment{algo}{\spewnotes}

    \definecolor{dkgreen}{rgb}{0,0.6,0}
    \definecolor{gray}{rgb}{0.5,0.5,0.5}
    \definecolor{mauve}{rgb}{0.58,0,0.82}
    \definecolor{darkblue}{rgb}{0,0,139}
    \definecolor{lightgray}{gray}{0.93}
    \renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$\textcolor{blue}{#1}}

    % default options for listings (for code)
    \lstset{
      autogobble,
      frame=ltbr,
      language=Python,
      aboveskip=3mm,
      belowskip=3mm,
      showstringspaces=false,
      columns=fullflexible,
      keepspaces=true,
      basicstyle={\small\ttfamily},
      numbers=left,
      firstnumber=1,                        % start line number at 1
      numberstyle=\tiny\color{gray},
      keywordstyle=\color{blue},
      commentstyle=\color{dkgreen},
      stringstyle=\color{mauve},
      backgroundcolor=\color{lightgray}, 
      breaklines=true,                      % break lines
      breakatwhitespace=true,
      tabsize=3, 
      xleftmargin=2em, 
      framexleftmargin=1.5em, 
      stepnumber=1
    }

  % Page style
    \pagestyle{fancy}
    \fancyhead[L]{Linux}
    \fancyhead[C]{Muchang Bahng}
    \fancyhead[R]{January 2024} 
    \fancyfoot[C]{\thepage / \pageref{LastPage}}
    \renewcommand{\footrulewidth}{0.4pt}          % the footer line should be 0.4pt wide
    \renewcommand{\thispagestyle}[1]{}  % needed to include headers in title page

\begin{document}

\title{Linux}
\author{Muchang Bahng}
\date{January 2024}

\maketitle
\tableofcontents
\pagebreak

  The following set of notes describes the everyday use of a Linux operating system. I refer to it for mainly my personal desktop, but it is also useful for working in computing clusters. Some of the commands are specific to the Arch Linux distribution (since that is what I work with), but I occasionally include those from Ubuntu and Red Hat, since I run into these distributions often in servers. 

  I try to organize this in a way so that one who wishes to get started in Linux can go through these notes chronologically. For now, we will assume that you have a Linux distribution installed. There are many resources beyond this book that helps you do that. 

  You can always try out Ubuntu (or any other distribution) through a \textbf{virtual machine}, which is a software emulation of a physical computer system. It allows you to run multiple operating systems or instances of an operating system on a single physical machine. Each virtual machine operates independently and has its own virtual hardware, including virtual CPU, memory, storage, and network interfaces. Virtual machines are created and managed by virtualization software called \textbf{hypervisors}. The hypervisor abstracts the underlying physical hardware and allows multiple virtual machines to share the same resources while isolating them from one another. This enables efficient utilization of hardware resources and provides flexibility in deploying and managing various operating systems and software applications. VMs generally have the advantage of being completely isolated from the main computer, so if anything wrong happens in the VM, it's fine. They can be used in research environments that are beta-testing unstable packages or for white-hacking practices. One example of a hypervisor is Oracle's \textbf{VirtualBox}, which is free to download. It should look like this when you open it for the first time. 
  \begin{center}
      \includegraphics[scale=0.2]{img/VirtualBox.png}
  \end{center}
  Now in order to create a VM with its own OS, you need to have the appropriate \textbf{ISO file}, which is an exact copy of an entire optical disk such as a CD, DVD, or Blu-ray archived into a single file. The essentially stores the entire software needed to operate the OS. Therefore, you should download the proper ISO file from the internet (usually a couple GBs). 
  \begin{enumerate}
      \item \href{https://ubuntu.com/download/desktop}{Ubunutu ISO files}
      \item \href{https://www.microsoft.com/en-us/software-download/windows10}{Windows 10 ISO files}
      \item Apple does not allow distribution of its ISO files, so you will need to download from unofficial sources, which may be unsafe. 
  \end{enumerate}
  Once you have this ISO file, you can reuse it to create as many VMs as you want of that OS. Now follow these instructions: Click the new button and select where the virtual machine data will be stored, along with its OS. You can set the RAM, but don't make it more than half of your host computer since it will hog up too much RAM. Choose ``Create a virtual hard disk now". Choose ``VDI (VirtualBox Disk Image)". Dynamically allocated just means that the virtual disk size will adaptively grow as your storage gets full. Set the disk size to be at least 20GB. 

  After you created this, go to the VM settings (this is where you can edit your CPU cores, RAM cap, etc.). To add the ISO file, click on the ``Empty" tab right under the ``Controller:IDE", then the CD icon to the right, and ``choose a disk file". You should now choose the ISO file. Then go tweak other settings, and set the display:video memory to the max (128MB). Now you should be able to go through the installation wizard when you turn the VM on. 
  \begin{figure}[hbt!]
      \centering 
      \begin{subfigure}[b]{0.45\textwidth}
      \centering
          \includegraphics[width=\textwidth]{img/VM_Windows1.png}
          \caption{Windows 10 Set Up}
          \label{fig:VM_Windows1}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.45\textwidth}
      \centering
          \includegraphics[width=\textwidth]{img/VM_Ubuntu1.png}
          \caption{Ubuntu 22.04 Set Up}
          \label{fig:VM_Ubuntu1}
      \end{subfigure}
      \caption{What you should get once you open up the VM after adding ISO files. }
  \end{figure}
  Refer to the instructions for each OS. 
  \begin{enumerate}
      \item For Windows: Say I don't have a product key. Click Windows 10 Home. Accept terms. Select the custom installation. Click the drive and click new, making the parititon at least 10534MB, and click apply. Next. Wait for the system to load. 
      \item For Ubuntu, you should get a GRUB view. Select ``Try or install Ubunutu". 
  \end{enumerate}
  You should now see one of these two screens. 
  \begin{figure}[hbt!]
      \centering 
      \begin{subfigure}[b]{0.45\textwidth}
      \centering
          \includegraphics[width=\textwidth]{img/VM_Windows2.png}
          \caption{Windows 10 Set Up}
          \label{fig:VM_Windows2}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.45\textwidth}
      \centering
          \includegraphics[width=\textwidth]{img/VM_Ubuntu2.png}
          \caption{Ubuntu 22.04 Set Up}
          \label{fig:VM_Ubuntu2}
      \end{subfigure}
      \caption{What you should get once you open up the VM after initial configuration and log in. }
  \end{figure}
  \begin{enumerate}
      \item For Windows, select your region. Select the keyboard layout. Sign in or create a Microsoft account. Choose privacy terms. Skip whatever. 
      \item For Ubuntu: Select Install Ubuntu with English. Set the keyboard layout. The normal installation may take a while, so I would select minimal depending on what you need. If you are short on time, you can uncheck the download updates while installing since you can always do that after you install. Click Erase disk and install Ubunutu. Choose region and add information. 
  \end{enumerate}
  Finally, you should see your desktop. 
  \begin{figure}[hbt!]
      \centering 
      \begin{subfigure}[b]{0.45\textwidth}
      \centering
          \includegraphics[width=\textwidth]{img/VM_Windows3.png}
          \caption{Windows 10 Set Up}
          \label{fig:VM_Windows3}
      \end{subfigure}
      \hfill 
      \begin{subfigure}[b]{0.45\textwidth}
      \centering
          \includegraphics[width=\textwidth]{img/VM_Ubuntu3.png}
          \caption{Ubuntu 22.04 Set Up}
          \label{fig:VM_Ubuntu3}
      \end{subfigure}
      \caption{What you should see once everything is set up. }
  \end{figure}

  For my personal use, the packages below are ones that I end up installing every time I create a new VM to work in during research. 

  \begin{lstlisting}
    sudo apt update
    sudo apt install snapd
    sudo snap install --classic code
    sudo snap install slack
    sudo apt install git 
    sudo snap install spotify 
    sudo apt install htop
    wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
    sudo dpkg -i google-chrome-stable_current_amd64.deb
    sudo apt install virtualbox 
  \end{lstlisting}

  Once you are ready to use Linux consistently, it is optimal to \textbf{dual boot} it, which means that you have one computer that is divided into two: one for each operating system. Then you need to partition your drive and allocate it to your secondary OS. There are plenty of guides and tutorials online on how to do this. 

  There may be a point where you may need to resize your drive partitions as you need more or less space in one of your OS. This is when we need to do \textbf{partition resizing}. To do this, we need an empty thumb drive with at least 8GB of space in it (everything in here will be deleted). Then in your Ubuntu, install balenaEtcher and an Ubuntu (any version) ISO file. Mount the ISO file into your USB drive using balenaEtcher, following the steps in \href{https://www.youtube.com/watch?v=Kyz9x71gEPI&t=504s}{this video} to eventually get into Gparted. Another popular \href{https://www.youtube.com/watch?v=vlVXPtJ20hA&t=467s}{guide} uses Rufus in the Windows system, but I have found that this does not work for me. 
 
\section{Hardware} 

  \subsection{Von Neumann Architecture}

    It is essential to have an initial model of a computer. For this, we will first use the \textbf{von Neumann architecture}, which is the basis for most computers today. It consists of a \textbf{central processing unit} (CPU), \textbf{memory}, and an \textbf{input/output} (I/O) system.

    \begin{definition}[Memory]
      The memory is where the computer stores data and instructions, which can be though of as a giant array of memory addresses, with each containing a byte. This data consists of graphical things or even instructions to manipulate other data.
    \end{definition}

    \begin{definition}[Central Processing Unit]
      The CPU is responsible for taking instructions (data) from memory and executing them. 
      \begin{enumerate} 
        \item The CPU is composed of \textbf{registers} (different from the cache), which are small, fast storage locations. These registers can either be \textbf{general purpose} (can be used with most instructions) or \textbf{special purpose} (can be accessed through special instructions, or have special meanings/uses, or are simply faster when used in a specific way).
        \item The CPU also has an \textbf{arithmetic unit} and \textbf{logic unit}, which is responsible for performing arithmetic and logical operations. 
        \item The CPU also has a \textbf{control unit}, which is responsible for fetching instructions from memory through the \textbf{databus}, which is literally a wire connecting the CPU and RAM, and executing them. 
      \end{enumerate}
      It executes instructions from memory one at a time and executes them, known as the \textbf{fetch-execute cycle}. It consists of 4 main operations. 
      \begin{enumerate} 
        \item \textbf{Fetch}: The \textbf{program counter}, which holds the memory address of the next instruction to be executed, tells the control unit to fetch the instruction from memory through the databus. 
        \item \textbf{Decode}: The fetched data is passed to the \textbf{instruction decoder}, which figures out what the instruction is and what it does and stores them in the registers.
        \item \textbf{Execute}: The arithmetic and logic unit then carries out these operations. 
        \item \textbf{Store}: Then it puts the results back on the databus, and stores them back into memory.
      \end{enumerate} 
      The CPU's \textbf{clock cycle} is the time it takes for the CPU to execute one instruction. More specifically, the clock cycle refers to a single oscillation of the clock signal that synchronizes the operations of the processor and the memory (e.g. fetch, decode, execute, store), and decent computers have clock cycles of at least $2.60$GHz (2.6 billion clock cycles per second). 
    \end{definition}

    To clarify, let us compare registers and memory. Memory is addressed by an unsigned integer while registers have names like \texttt{\%rsi}. Memory is much bigger at several GB, while the total register space is much smaller at around 128 bytes (may differ depending on the architecture). The memory is much slower than registers, which is usually on a sub-nanosecond timescale. The memory is dynamic and can grow as needed while the registers are static and cannot grow.


    \begin{definition}[Input/Output Device]
      The input device can read/load/write/store data from the outside world. The output device, which has \textbf{direct memory address}, can display data to the outside world. 
    \end{definition}

    Putting this all together, we have Figure \ref{fig:von_neumann_arch}. 

    \begin{figure}[hbt!]
      \centering 
      \includegraphics[scale=0.4]{img/von_neumann_arch.png}
      \caption{von Neumann Architecture} 
      \label{fig:von_neumann_arch}
    \end{figure}

  \subsection{Instruction Set Architectures} 

    \begin{definition}[Instruction Set Architecture]
      The \textbf{ISA} or just \textbf{architecture} of a CPU is a high level description of what it can do. Some differences are listed here: 
      \begin{enumerate} 
        \item What instructions it can execute. 
        \item The instruction length and decoding, along with its complexity. 
        \item The performance vs power efficiency. 
      \end{enumerate}
    \end{definition}

    
    \begin{definition}
      ISAs can be classified into two types. 
      \begin{enumerate} 
        \item The \textbf{complex instruction set computer} (CISC) is characterized by a large set of complex instructions, which can execute a variety of low-level operations. This approach aims to reduce the number of instructions per program, attempting to achieve higher efficiency by performing more operations with fewer instructions.
        \item The \textbf{reduced instruction set computer} (RISC) emphasizes simplicity and efficiency with a smaller number of instructions that are generally simpler and more uniform in size and format. This approach facilitates faster instruction execution and easier pipelining, with the philosophy that simpler instructions can provide greater performance when optimized.
      \end{enumerate}
    \end{definition}

    \begin{example}[x86 Architecture]
      The x86 architecture is a CISC architecture, which is the most common architecture for personal computers. Here are important properties: 
      \begin{enumerate} 
        \item It is a complex instruction set computer (CISC) architecture, which means that it has a large set of complex instructions\footnote{https://en.wikipedia.org/wiki/X86\_instruction\_listings}. 
        \item Byte-addressing is enabled and words are stored in little-endian format.
        \item In the x86\_64 architecture, registers are 8 bytes long (and 4 bytes in x86\_32) and there are 16 total general purpose registers, for a total of only 128 bytes (very small compared to many GB of memory). Other special purpose registers are also documented in the wikipedia page, but it is not fully documented. The registers are listed below\footnote{Older x86\_32 architecture has 8 general purpose registers with the \texttt{r} replaced by a \texttt{e}, e.g. \texttt{eax} instead of \texttt{rax}.}: 
        \begin{lstlisting} 
          %rax        # return value 
          %rbx        # callee saved 
          %rcx        # 4th argument 
          %rdx        # 3rd argument 
          %rsi        # 2nd argument
          %rdi        # 1st argument 
          %rbp        # callee saved  
          %rsp        # stack pointer 
          %r8         # 5th argument 
          %r9         # 6th argument 
          %r10        # scratch register  
          %r11        # scratch register 
          %r12        # callee saved  
          %r13        # callee saved 
          %r14        # callee saved
          %r15        # callee saved
        \end{lstlisting}
        

      \end{enumerate}

    \end{example}

    \begin{example}[ARM Archiecture]
      Mainly in phones, tablets, laptops. 
    \end{example}

    \begin{example}[MIPS Architecture]
      MIPS is a RISC architecture, which is used in embedded systems such as digital home and networking equipment. 
    \end{example}

    This is a large overview of the different architectures, but Arch Linux states on their website that they have \textit{official packages optimized for the x86-64 architecture}.\footnote{https://archlinux.org/} 

    Furthermore, by running \textbf{cat /proc/cpuinfo}, you can see the specs of each CPU core you have. This includes the \textbf{model name} (clock cycle), \textbf{cache size}, \textbf{flags}, and \textbf{microcode}. The flags are the most important, since they tell you what features your CPU has.\footnote{The entire list of flags and what they can do is mentioned in the Arch kernel source code, which is a good reference: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/include/asm/cpufeatures.h} 
    \begin{enumerate} 
      \item \textbf{lm}: 64 bit architecture. 
      \item \textbf{vmx} (Intel) or \textbf{svm} (AMD): Hardware virtualization . 
      \item \textbf{aes}: Accelerate AES encryption. 
      \item \textbf{fpu}: Floating Point Unit, which is used for floating point operations. 
      \item \textbf{vme}: Virtual 8086 mode enhancements, which is used for virtualization. 
      \item \textbf{de}: Debugging extensions, which is used for debugging. 
      \item \textbf{pse}: Page Size Extensions, which is used for larger page sizes. 
      \item \textbf{tsc}: Time Stamp Counter, which is used for timing. 
      \item \textbf{msr}: Model Specific Registers, which is used for model specific operations. 
      \item \textbf{mce}: Machine Check Exception, which is used for error checking. 
      \item \textbf{pae}: Physical Address Extensions, which is used for larger memory. 
      \item \textbf{mce}: Machine Check Exception, which is used for error checking. 

    \end{enumerate}

  \subsection{Assembly in x86\_64} 

    \begin{definition}[Instruction]
      An instruction is a single line of assembly code. It consists of some instruction followed by its (one or more) operands. The instruction is a mnemonic for a machine language operation (e.g. \texttt{mov}, \texttt{add}, \texttt{sub}, \texttt{jmp}, etc.). The \textbf{size specifier} can be appended to this instruction mnemonic to specify the size of the operands. 
      \begin{enumerate} 
        \item \textbf{b} (byte) for 1 byte 
        \item \textbf{w} (word) for 2 bytes
        \item \textbf{l} (long) for 4 bytes 
        \item \textbf{q} (quad word) for 8 bytes
      \end{enumerate}
      Note that due to backwards compatibility, word means 2 bytes in instruction names. Furthermore, the maximum size is 8 bytes since that is the size of each register in x86\_64. An operand can be of 3 types, determined by their \textbf{mode of access}:
      \begin{enumerate} 
        \item \textbf{Immediate addressing} is denoted with a \texttt{\$} sign, e.g. a constant integer data \texttt{\$1}. 
        \item \textbf{Register addressing} is denoted with a \texttt{\%} sign with the following register name, e.g. \texttt{\%rax}.
        \item \textbf{Memory addressing} is denoted with the hexadecimal address in memory, e.g. \texttt{0x034AB}.
      \end{enumerate}
    \end{definition}

    Like higher level programming languages, we can perform operations, do comparisons, and jump to different parts of the code. Instructions can be generally categorized into three types: 
    \begin{enumerate} 
      \item \textbf{Data Movement}: These instructions move data between memory and registers or between the registery and registery. Memory to memory transfer cannot be done with a single instruction. 
        \begin{lstlisting} 
          %reg = Mem[address]     # load data from memory into register
          Mem[address] = %reg     # store register data into memory
        \end{lstlisting}
      \item \textbf{Arithmetic Operation}: Perform arithmetic operation on register or memory data. 
        \begin{lstlisting} 
          %reg = %reg + Mem[address]     # add memory data to register
          %reg = %reg - Mem[address]     # subtract memory data from register
          %reg = %reg * Mem[address]     # multiply memory data to register
          %reg = %reg / Mem[address]     # divide memory data from register
        \end{lstlisting}
      \item \textbf{Control Flow}: What instruction to execute next. 
        \begin{lstlisting} 
          jmp label     # jump to label
          je label      # jump to label if equal
          jne label     # jump to label if not equal
          jg label      # jump to label if greater
          jl label      # jump to label if less
          call label    # call a function
          ret           # return from a function
        \end{lstlisting}
    \end{enumerate}

    Now unlike compiled languages, which are translated into machine code by a compiler, assembly code is translated into machine code through a two-step process. First, we \textbf{assemble} the assembly code into an \textbf{object file} by an \textbf{assembler}, and then we \textbf{link} the object file into an executable by a \textbf{linker}. Some common assemblers are \textbf{NASM} (Netwide Assembler) and \textbf{GAS/AS} (GNU Assembler), and common linkers are \textbf{ld} (GNU Linker) and \textbf{lld} (LLVM Linker), both installable with \textbf{sudo pacman -S nasm ld}. 

    \begin{definition}[mov]
      Let's talk about the \texttt{mov} instruction. A good diagram to see is the following: 
      \begin{center}  
        % \includegraphics[scale=0.5]{img/movq.png}
      \end{center} 
      Parantheses indicate that we are using a pointer dereference. 
    \end{definition}

    \begin{definition}[int]
      The \texttt{int} instruction is used to generate a software interrupt. It is often used to invoke a system call.
    \end{definition}

    \begin{definition}[ret]
      The \texttt{ret} instruction is used to return from a function. It returns the value in the \texttt{\%rax} register. 
    \end{definition}

    \begin{example}[Swap Function]
      In \textbf{gdb}, we may have a function that swaps two integers. 
      \begin{lstlisting} 
        swap:
          movq (%rdi), %rax
          movq (%rsi), %rdx
          movq %rdx, (%rdi)
          movq %rax, (%rsi)
          ret
      \end{lstlisting}
    which is the assembly code for the following C code.
      \begin{lstlisting} 
        void swap(long *xp, long *yp) {
          long t0 = *xp;
          long t1 = *yp;
          *xp = t1;
          *yp = t0;
        }
      \end{lstlisting}
    \end{example}

  \subsection{Graphics Drivers}
    
    Note that one type of data we must store on memory is the individual pixels in a computer screen. Say that in a $1920 \times 1080$ resolution computer, there are about $1920 \times 1080 \times 3 \approx 2$ million bytes of data that we have to store. This isn't that much data (only 2MB), but we must update it quite fast since our screens are always updating. This is why all computer which have a GUI comes with a built-in graphics driver. To see the GPU hardware specifications, install \textbf{lshw}. 

    \begin{definition}[Graphics Processing Unit]
      The \textbf{GPU} is a specialized processing unit that is designed to handle the rendering of images and videos. It is designed to handle the rendering of images and videos, and is optimized for parallel processing. Like the CPU, it has some common metrics: 
      \begin{enumerate} 
        \item \textbf{Clock Speed}: The speed at which the GPU can execute instructions. This is usually measured in MHz or GHz. 
        \item \textbf{Memory}: The amount of memory that the GPU has. This is usually measured in GB. 
        \item \textbf{Memory Bandwidth}: The speed at which the GPU can read and write to its memory. This is usually measured in GB/s. 
        \item \textbf{Cores}: The number of cores that the GPU has. This is usually measured in thousands, which allows for parallel processing. 
      \end{enumerate}
      You can check which GPUs you have by running \texttt{lspci | grep VGA} or \texttt{neofetch}. There are generally two types of GPUs: 
      \begin{enumerate} 
        \item \textbf{Integrated GPU}: This type of GPU is built into the same chip as the CPU (Central Processing Unit). It shares resources with the CPU, including memory, which can lead to reduced performance for graphics-intensive tasks. However, its integrated nature makes it more power-efficient and cost-effective. 
        \item \textbf{Discrete GPU}: This is a separate component from the CPU and comes with its own RAM (usually called VRAM or Video RAM). It is typically installed in a dedicated slot on the motherboard. Because it operates independently of the CPU, a discrete GPU can offer significantly better performance for graphics processing, gaming, or deep learning. 
      \end{enumerate}
    \end{definition}

    \begin{definition}[Monitor]
      Furthermore, your computer monitor, which actually displays these pixels to you, must also have metrics that match the GPU. Some properties: 
      \begin{enumerate} 
        \item The \textbf{resolution} is the number of pixels that the monitor can display, and is usually measured in pixels. 
        \item The \textbf{refresh rate} is the number of times the monitor can refresh the image on the screen per second, and is usually measured in Hz. 
      \end{enumerate}
      To see these metrics for all monitors connected to your computer, run \textbf{xrandr}, which lists all the resolutions and possible refresh rates for each resolution. 
    \end{definition}

    \begin{definition}[Graphics Driver]
      In order for your operating system to communicate with your GPU, you need a \textbf{graphics driver}. This is a piece of software that allows the operating system to communicate with the GPU. There are two main types of graphics drivers:
      \begin{enumerate} 
        \item \textbf{Open Source Drivers}: These are drivers that are developed and maintained by the open source community. They are usually included with the Linux kernel, and are generally stable and reliable. 
        \item \textbf{Proprietary Drivers}: These are drivers that are developed and maintained by the GPU manufacturer. They are usually not included with the Linux kernel, and are generally more feature-rich and performant than open source drivers. 
      \end{enumerate}
    Intel drivers are open source, but Nvidia drivers are proprietary (which is why Linus Torvalds has beef with Nvidia).\footnote{A video of Linus Torvalds saying ``fuck you'' to Nvidia: https://www.youtube.com/watch?v=iYWzMvlj2RQ}
    \end{definition}

    Some popular graphics drivers include \textbf{mesa} for Intel and \textbf{nvidia} drivers for NVIDIA. 

    \subsubsection{Multiple GPUs} 

      Everything is pretty straightforward when you have one graphics card, but when you have multiple graphics cards, you have to specify which one you want to use. If you want to only use one GPU, you can just disable the other one in the BIOS. However, if you have an Intel/Nvidia dual driver and want to use both, install \textbf{Nvidia Optimius} (for Ubuntu, it is supported through \textbf{nvidia-prime}).\footnote{This wiki article (https://github.com/Askannz/optimus-manager/wiki) provides a good overview of this matter. },\footnote{Installation instructions here: https://github.com/Askannz/optimus-manager?tab=readme-ov-file} 

      Now make sure that the systemd daemon is running, and you can call \texttt{optimus-manager --switch hybrid} to enable hybrid graphics. This will log you out. 

    \subsection{Peripheral Devices} 
      
      Peripheral devices refer to other devices outside of the motherboard, including mice, keyboards for input, monitors, printers, network managers, and usb ports. Even the GPU is considered a peripheral device. These must be connected to the motherboard in some way to be managed by the operating system, and similar to the databus connecting the CPU and memory, there are buses that connect the motherboard and these peripheral devices. 

      \begin{definition}[PCI Bus]
        The \textbf{PCI (Peripheral Component Interconnect)} bus is a high-speed bus that connects the motherboard to peripheral devices. It is used to connect devices like network cards, sound cards, and graphics cards to the motherboard. PCI buses operated based on the PCI standard, which is a set of specifications that define the physical and electrical characteristics of the bus. 
      \end{definition}

      The command to use to enumerate all PCI devices is \texttt{sudo lspci} (with \texttt{-v} for verbose). 
      
      \begin{figure}[hbt!]
        \centering 
        \begin{lstlisting} 
          00:00.0 Host bridge: Intel Corporation 10th Gen Core Processor 
          00:01.0 PCI bridge: Intel Corporation 6th-10th Gen Core Processor 
          00:02.0 VGA compatible controller: Intel Corporation CometLake-H 
          00:04.0 Signal processing controller: Intel Corporation Xeon 
          00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5/v6 
          00:12.0 Signal processing controller: Intel Corporation Comet 
          00:13.0 Serial controller: Intel Corporation Device 06fc
          00:14.0 USB controller: Intel Corporation Comet Lake USB 3.1 
          00:14.2 RAM memory: Intel Corporation Comet Lake PCH Shared 
          00:14.3 Network controller: Intel Corporation Comet Lake PCH
          00:15.0 Serial bus controller: Intel Corporation Comet Lake 
          00:15.1 Serial bus controller: Intel Corporation Comet Lake 
          00:16.0 Communication controller: Intel Corporation Comet 
          00:1c.0 PCI bridge: Intel Corporation Device 06b8 (rev f0)
          00:1c.6 PCI bridge: Intel Corporation Device 06be (rev f0)
          00:1d.0 PCI bridge: Intel Corporation Comet Lake PCI Express
          00:1e.0 Communication controller: Intel Corporation Comet Lake 
          00:1f.0 ISA bridge: Intel Corporation Device 068e
          00:1f.3 Audio device: Intel Corporation Comet Lake PCH cAVS
          00:1f.4 SMBus: Intel Corporation Comet Lake PCH SMBus Controller
          00:1f.5 Serial bus controller: Intel Corporation Comet Lake 
          01:00.0 3D controller: NVIDIA Corporation TU117M [GeForce GTX 1650 
          02:00.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
          03:00.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
          03:01.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
          03:02.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
          03:04.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
          04:00.0 System peripheral: Intel Corporation JHL7540 Thunderbolt 
          38:00.0 USB controller: Intel Corporation JHL7540 Thunderbolt 3 
          6c:00.0 Unassigned class [ff00]: Realtek Semiconductor Co., Ltd. 
          6d:00.0 Non-Volatile memory controller: Samsung Electronics Co 
        \end{lstlisting}
        \caption{This is the following output of lspci on my personal computer. } 
        \label{fig:pci_device}
      \end{figure}

  \subsection{System Hardware}

    \subsubsection{Non-Volatile Drive Storage}

      A \textbf{drive} is basically a computer component used to store data. It may be a static storage device (e.g. a HDD or SSD) or may use removable media (e.g. thumb, disk, CD). All drives store nonvolatile data (also called nonvolatile memory, NVM), meaning that the data is not erased when the power is turned off.
      \begin{enumerate}
        \item A \textbf{floppy disk drive} is a portable circular floppy plastic/metal disk coated with iron oxide or other magnetic material. They come in many sizes ranging from 3~8 inches in diameter, with the standard capacity being 1.44MB. When inserting the floppy disk into a computer, there is a read/write head that uses a magnet to polarize the iron particles in one of two directions, each represting a 0 or 1 in binary data. The head can also read these polarities in order to retrieve data stored on the disk in the form of polarized particles. Note that the head would read the disk "circularly" as the disk rotates. Each disk would be divided into typically 40 tracks with around 8 equal sectors.

        \item A \textbf{hard disk drive (HDD)} is an electro-mechanical data storage device that stores and retrieves digital data using magnetic storage and one or more rigid (hence, the name hard) rapidly rotating platters coated with magnetic material. Data is accessed in arandom-access manner, meaning that individual blocks of data can be stored and retrieved in any order. They usually come inside a metal case enclosing the entire drive (3.5-inch for computers and 2.5-inch for laptop HDDs). Since the data on the HDD is determined by the polarities of the magnetic material on the disks, it is sensitive to external magnetic fields that may corrupt the data. Furthermore, because the drive heads must align over an area of the disk in order to read or write data, and the disk is constantly spinning, there’s a delay before data can be accessed. The drive may need to read from multiple locations in order to launch a program or load a file, which means it may haveto wait for the platters to spin into the proper position multiple times before it can complete the command. If a drive is asleep or in a low-power state, it can take several seconds more for the disk to spin up to full power and begin operating. Their speeds are measured in RPM, with the normal range of desktop HDDs having 5400-7200 RPM. It is useful to know that 5400 RPM drives offer an average of 100MB/s read and 7200 RPM drives offer 120MB/s.

        \item A \textbf{Solid State Drive (SSD)} is an extra step up from the HDD. From the very beginning, it was clear that hard drives couldn’t possibly match the speeds at which CPUs could operate. Latency in HDDs is measured in milliseconds, compared with nanoseconds for your typical CPU. One millisecond is 1,000,000 nanoseconds, and it typically takes a hard drive 10-15 milliseconds to find data on the drive and begin reading it. The hard drive industry introduced smaller platters, on-disk memory caches, and faster spindle speeds to counteract this trend, but there’s only so fast drives can spin. Western Digital’s 10,000 RPM VelociRaptor family is the fastest set of drives ever built for the consumer market, while some enterprise drives spun as quickly as 15,000 RPM. The problem is, even the fastest spinning drive with the largest caches and smallest platters are still achingly slow as far as your CPU is concerned. Unlike HDDs, soid state drives do not need moving parts or spinning disks (hence their name). Instead, it uses NAND flash memory, which is a type of non-volatile storage that erases data in units called blocks and rewrites data at the Byte level. It also retains data for decades, regardless of whether the device is powered on or off. It is used in not only SSD, but also USB flash drives, SD cards, mobile phones, digital cameras, tablets, and others. The most fundamental unit of storage is the flash memory cell, which uses electron thresholds to hold certain bits of information, usually three bits (called TLC - triple level cell) or four bits (called QLC - quad level cell). If is no electron charge in the cell, the cell represents a 111 (for TLC) and 1111 (for QLC). Since each cell can store multiple bits of information, they are arranged in a large array (consisting of millions of cells stacked on top of each other) into a block, leading to a typical storage between 256KB and 4MB.
      \end{enumerate}
      On Windows, each type of drive on a computer are assigned a device/drive letter, a single alphabetic character A through Z. Computers containing a hard drive always have that default hard drive assigned to a C: drive letter, and external drives may be assigned different letters, such as Google Drive being assigned a G: drive letter. You may also notice that when opening the command prompt on windows, the leftmost letter represents which drive you are currently on. Note that the "wmic" is an abbreviation of Windows Management Interface Command. Some commands may require you to use an \textbf{elevated command prompt}, which can be used by opening the cmd file as an administrator. 

      \begin{lstlisting}
      C:\Users\bahng>
      \end{lstlisting}

      \begin{lstlisting}
        # Lists all drives on your computer
        # DeviceID = drive letter
        # DriveType: 2=Removable, 3=Fixed local, 4=Network
        # FreeSpace and Size in bytes
        wmic LOGICALDISK LIST BRIEF # Windows cmd

        # Outputs drive model and status
        # Status OK = good health
        # Status 'Pred Fail' = potential crash warning
        wmic diskdrive get status, model # Windows cmd

        # Checks file system and provides drive issues summary
        # Non-zero bad sectors require technical help
        chkdsk c: # Windows cmd

        # Opens window showing all drive types
        dfrgui # Windows cmd

        # Changes working drive (e.g. d:)
        <letter>: # Windows cmd
      \end{lstlisting}
  
      We demonstrate some of the commands here.
      \begin{lstlisting}
      C:\Users\bahng>wmic LOGICALDISK LIST BRIEF
        DeviceID  DriveType  FreeSpace     ProviderName  Size           VolumeName
        C:        3          838628864000                1003327844352  OS
        G:        3          71506178048                 107374182400   Google Drive

      C:\Users\bahng>wmic diskdrive get status, model
        Model                      Status
        PM9A1 NVMe Samsung 1024GB  OK
      \end{lstlisting}

    \subsubsection{Volatile, Short-Term Storage}

      Information travels from drives and other stores to the CPU, but the physical distance that the bits must travel across the motherboard also puts an upper limit on the retrieval speed (i.e. the speed of electromagnetic waves), especially if the distance must be covered thousands or millions of times back and forth. This limit is known as \textbf{latency}. This is why computers have a hierarchy of stores reserved for information that is accessed more frequently, some closer to the CPU and others even within the CPU itself!

      \begin{enumerate}
        \item \textbf{Random Access Memory}, or \textbf{RAM}, is short-term memory that acts as a cache for the CPU that is 50-200 times faster than a regular SSD. It is volatile, meaning that all its memory is erased when the computer shuts down. The most recent type of RAM is DDR4, then DDR3, followed by DDR2, DDR, and SDRAM. In addition the speeds of RAM is 
        \begin{enumerate}
          \item DDR4: 2133mhz, 2400mhz, 2666mhz, 3200mhz
          \item DDR3: 1066mhz, 1300mhz, 1600mhz, 1866mhz
        \end{enumerate}
        where the mhz value represents how many times per second the RAM can access its memory. However, know that some motherboards have technical limitations to what kind of RAM speed it can handle, so in these cases, the system will throttle your faster RAM stick to meet this need. In terms of capacity, the following gives us nice benchmarks.
        \begin{enumerate}
          \item 4-8 GB: Laptops for web browsing and light gaming (e.g. my Macbook Air 2019)
          \item 16-32 GB: Laptops for gaming (possibly heavy) and programming
          \item 64-128 GB: Crazy stuff.
          \item 256 GB: This basically means you have a RAM that is pretty much the size of a typical SSD. This is usually for specialized research computers or clusters. 
        \end{enumerate}
        Finally, there are broad categories of RAM. 
        \begin{enumerate}
          \item \textbf{Static RAM (SRAM)} requires a constant power flow in order to function and therefore doesn't need to be refreshed to keep the data intact (hence the name static). Note that this does not mean that SRAM is nonvolatile. Therefore, the SRAM is typically used in CPU caches or video cards. 
          \item \textbf{Dynamic RAM (DRAM)} requires a periodic refresh of power in order to function. The capacitors that store data in DRAM gradually discharge energy (no energy means the data becomes lost). DRAM is found in systems memory and video graphics memory. 
          \item \textbf{Synchronous Dynamic RAM (SDRAM)} is a DRAM that operates in sync with the CPU clock, which means that it waits for the clock signal before responding to data input. This is advantageous since the CPU can process overlapping instructions in parallel, known as pipelining (the ability to reveive an instruction before the previous instruction has been fully resolved). This allows more instructions to be completed simultaneously. By contrast, DRAM is asynchronous, which means it responsd immediately to user input.
        \end{enumerate}
        
        \item \textbf{CPU caches} have a hierarchy that is divided into (from fastest to slowest) L1, L2, L3, and sometimes even L4. The CPU will check the L1 cache first to see if there is a hit (if there is, then data is retrieved extremely fast), then the L2, and so on. 
        \begin{enumerate}
            \item L1: 8-64 KB storage typically (but there are exceptions, i.e. the Apple M1 chip has a 192 KB L1 cache)
            \item L2: 256KB-8MB storage
            \item L3: 10-64MB storage (and sometimes up to 256MB for server chips)
        \end{enumerate}
      \end{enumerate}

      \begin{lstlisting}
        # Outputs relevant information about the RAM. 
        wmic MEMORYCHIP (get BankLabel, DeviceLocator, MemoryType, TypeDetail, Capacity, Speed) # Windows cmd 

        # Outputs a list of all specifications of each memory stick.
        wmic memoryship list full # Windows cmd

        # Outputs the total RAM memory of your computer.
        systeminfo | findstr /C:"Total Physical Memory" # Windows cmd

        # Outputs the available RAM memory of your computer.
        systeminfo |find "Available Physical Memory" # Windows cmd
      \end{lstlisting}

      For my computer, the outputs are as such. It shows two memory sticks each with 8GB of memory, a memory type of 0 which is a DDR4 (type 24 means DDR3), speeds of 3200 mhz, and TypeDetail of 128 which means the RAM is synchronous (SDRAM).
      \begin{lstlisting}
        C:\Users\bahng>wmic MEMORYCHIP get BankLabel, DeviceLocator, MemoryType, TypeDetail, Capacity, Speed
        BankLabel  Capacity    DeviceLocator  MemoryType  Speed  TypeDetail
                    8589934592  DIMM A         0           3200   128
                    8589934592  DIMM B         0           3200   128
      \end{lstlisting}

      The status of your CPU can be checked with the following commands
      \begin{lstlisting}
        # Outputs a list of all specifications of the CPU.
        wmic cpu list full # Windows cmd

        # Outputs relevant information about the CPU.
        wmic cpu (get caption, deviceid, name, numberofcores, maxclockspeed, status) # Windows cmd
      \end{lstlisting}

  \subsection{Program Lifecycle Phases}

      First, we review some definitions. More on program lifecycle phases \href{https://en.wikipedia.org/wiki/Program_lifecycle_phase}{here}. Programming languages are broadly classified into two types. \textbf{High-level languages} are the familiar programming languages that we work with today (that allow much more abstraction), while \textbf{low-level languages} are very close to the hardware, such as machine language and assembly language. Programmers write programs in \textbf{source code} (usually high-level languages), which are then inputted into \textbf{language processors} that translate them into \textbf{object code} (usually \textbf{machine code} consisting of binary). The duration in which the source code of the program is being edited is called the \textbf{edit time}, while the \textbf{compile time} is when the source code is translated into machine code by a language processor. There are three types of language processors.
      \begin{enumerate}
        \item A \textbf{compiler} is a language processor that reads the complete source program written in high-level language as a whole in one go and translates it into an equivalent program in machine language. The source code is translated to object code successfully if it is free of errors. The compiler specifies the errors at the end of the compilation with line numbers when there are any errors in the source code. The errors must be removed before the compiler can successfully recompile the source code again. (e.g. C, C++, C\#, Java)
        
        \item An \textbf{assmebler} is used to translate the program written in Assembly language (basically a low-level language with very strong correspondence between the instructions in the language and the machine code instructions) into machine code. The assembler is basically the 1st interface that is able to communicate humans with the machine. We need an assembler to fill the gap between human and machine so that they can communicate with each other. Code written in assembly language is some sort of mnemonics (instructions) like ADD, MUL, MUX, SUB, DIV, MOV and so on, and the assembler is basically able to convert these mnemonics into binary code.

        \item An \textbf{interpreter} translates a single statement of the source program into machine code and executes immediately before moving on to the next line. If there is an error in the statement, the interpreter terminates its translating at that statement and displays an error message. The interpreter moves on to the next line for execution only after the removal of the error. An interpreter directly executes instructions written source code without previously converting them to an object code or machine code. (e.g. Python, Pearl, JavaScript, Ruby)
      \end{enumerate}
      A quick compare and contrast.
      \begin{table}
      \centering
      \begin{tabular}{|p{7cm}|p{7cm}|}
      \hline
      \textbf{Compiler} & \textbf{Interpreter} \\
      \hline
      Takes more time to analyze source code but execution time is faster. & Takes less time to analyze source code but execution time is slower. \\
      \hline
      Debugging is harder since the compiler generates an error message after the entire scan. & Debugging is easier since the interpreter continues translating the program until an error is met. \\
      \hline
      Requires a lot of memory for generating object codes. & Requires less memory because no object code is generated. \\
      \hline
      Generates intermediate object code. & No intermediate object code is generated. \\
      \hline
      \end{tabular}
      \end{table}

      The result of a successful compilation is an executable, which is a program in the form of a file containing millions of lines of very simple machine code instructions (e.g. add 2 numbers or compare 2 numbers), also called \textbf{processor instructions}. This executable can be stored somewhere in the computer drive for future use or it may be copied immediately in a faster memory state, such as the RAM. The \textbf{load time} is when the OS takes the program's executable from storage and puts it into an active memory (e.g. RAM) in order to begin execution. 

      The CPU understands only a low level machine code language (aka native code), which is contained within the executable. The language of the machine code is hardwired into the design of the CPU hardware; it is not something that can be changed at will. Each family of compatible CPUs (e.g. the popular Intel x86 family) has its own, idiosyncratic machine code which is not compatible with the machine code of other CPU families. More information \href{https://web.stanford.edu/class/cs101/software-1.html}{here}. Once the instruction bytes are copied from storage to RAM, the CPU can run through the steps/lines at the rate of about 2 billion lines/steps per second. This execution phase, when the CPU executes the instructions until normal termination or a crash, is called the \textbf{runtime}.

    \subsubsection{More on Executables}

      More specifically, an \textbf{executable} is a file that contains a list of instructions and data to cause a computer's CPU to perform indicated tasks, as opposed to the data files, which are fundamentally strings of data that must be interpreted (parsed) by a program to be meaningful. Executables usually have extension names $\texttt{.exe}$ or $\texttt{.bat}$, and they can generally be run (invoked) in two ways: 
      \begin{enumerate}
          \item The executable file can be run by simply double clicking on the file name, opening it, and having the user type commands in an interactive session of an interpter (like inputting commands in terminal window or a python shell).
          \item Alternatively, we can start writing a program, complete writing it, and then have this program compiled into an executable to be invoked.
      \end{enumerate}
      Some common examples of executables are:
      \begin{enumerate}
          \item python.exe - used to run python scripts that have the .py extension, located at 
          \[\texttt{C: \textbackslash Users\textbackslash bahng\textbackslash AppData\textbackslash Local\textbackslash Programs\textbackslash Python\textbackslash Python39}\]
          \item pythonw.exe - used to run .pyw files for GUI programs
          \item terminal.exe (on MacOS)
          \item cmd.exe (on Windows OS)
          \item py.exe - an executable used to run the python.exe executable like a shortcut, located at 
          \[\texttt{C:\textbackslash windows\textbackslash py.exe}\]
      \end{enumerate}

    \subsubsection{Static vs Dynamic Languages}

      \textbf{Type-checking} is the process of checking and verifying the type of a construct (constant, variable, array, list, object) and its usage context. It helps in minimizing the possibility of type errors in the program, and type checking may occur either at compile-time (static checking) or at run-time (dynamic checking). 
      \begin{enumerate}
        \item \textbf{Statically-Typed Languages}: Since we type check during compilation, every detail about the variables and all the data types must be known before we do the compiling process. Once a variable is assigned a type, it can't be assigned to some other variable of a different type, and so the data type of a declared variable is fixed. This makes sense since in Java, C, C++, etc., the programmer must specify what the data type of each variable is by writing something like $\texttt{int myNum = 15}$.

        \item \textbf{Dynamically-Typed Languages}: Since we type-check during runtime, there is no need to specify the data type of each variable while writing code, which improves writing speed. These languages have the capability to identify the type of each variable during run-time, so we do not need to declare the data types of variables. In these languages, variables are bound to objects at run-time using assignment statements, and most modern languages (e.g. JavaScript, Python, PHP, etc.) are dynamically typed.
      \end{enumerate}

\section{Filesystems}

  Before we get into anything, even the loading of the firmware or the operating system kernel, we must talk about the hardware and how a computer stores data. Data, whether it is in memory or some disk, is just a bunch of sequences of bits. A \textbf{drive} is a physical device that can store data. A \textbf{partition} is a logical division of a drive, and a \textbf{filesystem} is a way to organize data on a drive. For example, if I have a 1TB SSD, I can run it as a single partition, or I can divide it into two partitions, one for a Windows operating system and another for a Linux operating system. A filesystem is a bit more confusing, so here are some examples. 

  \begin{example}[Linux Filesystems]
    Listed. 
    \begin{enumerate}
      \item \textbf{ext4}: The most common filesystem for Linux. 
      \item \textbf{XFS}: Designed for high performance and scalability, often used in enterprise environments for large-scale storage.
      \item \textbf{btrfs}: A modern filesystem that offers advanced features like snapshots, dynamic inode allocation, and integrated device management for better data reliability and performance. 
      \item \textbf{zfs}: Originally developed by Sun Microsystems for Solaris, ZFS is known for its data integrity, support for enormous storage capacities, and features like snapshots, copy-on-write, and built-in data compression.
    \end{enumerate}
  \end{example}

  \begin{example}[Windows Filesystems]
    Listed. 
    \begin{enumerate} 
      \item \textbf{NTFS (New Technology File System)}: The standard filesystem for Windows operating systems, supporting file permissions, encryption, and large file sizes.
      \item \textbf{FAT32 (File Allocation Table 32)}: An older filesystem with wide compatibility across different operating systems, including Windows, macOS, and various Linux distributions, though it has limitations on file and partition sizes.
      \item \textbf{exFAT (Extended File Allocation Table)}: Designed to be a lightweight filesystem similar to FAT32 but without its limitations, exFAT is used for flash drives and external hard drives due to its support for larger files and compatibility.
    \end{enumerate}
  \end{example}

  \begin{example}[MacOS Filesystems]
    Listed. 
    \begin{enumerate}
      \item \textbf{APFS (Apple File System)}: The default filesystem for macOS, iOS, and other Apple operating systems since 2017, designed for SSDs and featuring strong encryption, space sharing, and fast directory sizing.
      \item \textbf{HFS+ (Hierarchical File System Plus)}: Also known as Mac OS Extended, it was the primary filesystem for Mac computers before APFS, supporting journaling for data integrity.
    \end{enumerate}
  \end{example}

  When your computer boots up, it needs to know where to find the operating system kernel. This is done by mounting the filesystems. The \textbf{mount point} is the directory where the filesystem is attached to the system. The \textbf{root filesystem} is the filesystem that contains the operating system kernel.

  Depending on your hardware specs, you may have multiple drives. To list all drives and their partitions, run \textbf{lsblk}. The type determines whether it is a disk or a partitions, and the mountpoints determine where the partitions are mounted. Furthermore, the \texttt{RO} indicates whether this is a HDD (1) or SSD (0). 

  \begin{figure}[hbt!]
    \centering 
    \begin{lstlisting} 
      NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
      zram0       254:0    0     4G  0 disk [SWAP]
      nvme0n1     259:0    0 953.9G  0 disk 
        nvme0n1p1 259:1    0   240M  0 part 
        nvme0n1p2 259:2    0   128M  0 part 
        nvme0n1p3 259:3    0 309.4G  0 part 
        nvme0n1p4 259:4    0   990M  0 part 
        nvme0n1p5 259:5    0  16.7G  0 part 
        nvme0n1p6 259:6    0   1.4G  0 part 
        nvme0n1p7 259:7    0   500M  0 part /boot
        nvme0n1p8 259:8    0   4.7G  0 part [SWAP]
        nvme0n1p9 259:9    0 619.9G  0 part /
    \end{lstlisting}
    \caption{This is the following output on my personal computer. } 
    \label{fig:lsblk}
  \end{figure}
    
  The \textbf{swap} partition is a special type of partition that is used as a temporary storage area for the operating system. It is used when the system runs out of RAM. 

  For a more detailed view on what the partitions consist of, you can run \textbf{fdisk -l}.
  \begin{lstlisting} 
    Disk /dev/nvme0n1: 953.87 GiB, 1024209543168 bytes, 2000409264 sectors
    Disk model: PM9A1 NVMe Samsung 1024GB               
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    Disklabel type: gpt
    Disk identifier: 26D88CE9-B388-4CF1-856C-14D5EEB0C143

    Device              Start        End    Sectors   Size Type
    /dev/nvme0n1p1       2048     493567     491520   240M EFI System
    /dev/nvme0n1p2     493568     755711     262144   128M Microsoft reserved
    /dev/nvme0n1p3     755712  649658367  648902656 309.4G Microsoft basic data
    /dev/nvme0n1p4 1960380416 1962407935    2027520   990M Windows recovery environment
    /dev/nvme0n1p5 1962407936 1997441023   35033088  16.7G Windows recovery environment
    /dev/nvme0n1p6 1997443072 2000377855    2934784   1.4G Windows recovery environment
    /dev/nvme0n1p7  649658368  650682367    1024000   500M EFI System
    /dev/nvme0n1p8  650682368  660447231    9764864   4.7G Linux swap
    /dev/nvme0n1p9  660447232 1960380415 1299933184 619.9G Linux filesystem
  \end{lstlisting}

  As you can see here, my single disk has 9 partitions. 
  \begin{enumerate} 
    \item The first EFI system (1) or the Microsoft reserved (2) partition contains the Windows operating system kernel. 
    \item The Microsoft basic data (3) partition contains the Windows files.
    \item  The Windows recovery environment (4, 5, 6) is a partition that contains the Windows recovery environment, which are partitions set aside by the manufacturer to hold an image of your system before it was shipped from the factory. 
    \item The EFI system (7) partition contains the Linux operating system kernel, which is required to load the operating system. 
    \item The Linux swap (8) partition is a partition that contains the Linux swap. 
    \item The Linux filesystem (9) is a partition that contains the actual Linux operating system itself, along with all your files.
  \end{enumerate}


  \subsection{Mounting} 

    You can further go into the \texttt{/dev} directory to see the devices that are mounted, e.g. the \texttt{/dev/nvme0n1p9} is the device that is mounted on the root directory, and most of these files are either device files (which are special files that provide an interface to hardware devices, allowing software and users to interact with them as if they were normal files) or symlinks.

    The \textbf{mount} command is used to attach a filesystem to the system's directory tree. The \textbf{umount} command is used to detach a filesystem from the system's directory tree. 

    \begin{enumerate}
      \item \textbf{Mounting a filesystem}: The general syntax is \texttt{mount -t type device dir}. For example, to mount the \texttt{/dev/nvme0n1p9} to the root directory, you can run \texttt{mount -t ext4 /dev/nvme0n1p9 /mnt}. 
      \item \textbf{Unmounting a filesystem}: The general syntax is \texttt{umount dir}. For example, to unmount the root directory, you can run \texttt{umount /mnt}. 
    \end{enumerate}

    When the computer boots up, it must automatically mount the specific filesystems. This is configured in the \textbf{fstab} file. 

    \begin{definition}[fstab]
      The \textbf{fstab} file is a system configuration file that contains information about filesystems. It is located at \texttt{/etc/fstab}. It is used to define how disk partitions, various other block devices, or remote filesystems should be mounted into the filesystem. 
      Each line in the file contains six fields, separated by whitespace. The fields include: 
      \begin{enumerate} 
        \item \textbf{Filesystem}: The block device or remote filesystem to be mounted. This can be the UUID (Universally Unique Identifier), the label, or the traditional device name (like /dev/sda1) that specifies which device or partition is being referred to.
        \item \textbf{Mount Point}: The directory where the filesystem should be mounted. 
        \item \textbf{Type}: The type of the filesystem, e.g. ext4, vfat, swap, etc.
        \item \textbf{Options}: Mount options for the filesystem, e.g. \texttt{rw} for read-write, \texttt{ro} for read-only, \texttt{noexec} to prevent execution of binaries, etc.
        \item \textbf{Dump}: A number used by the \textbf{dump} command to determine whether the filesystem should be backed up. It is often set to $0$ to disable backups. 
        \item \textbf{Pass}: A number used by the \textbf{fsck} command to determine the order in which filesystems should be checked. Root filesystems should have this set to 1, and other filesystems should either be 2 (to check after the root) or 0 (to disable checking). 
      \end{enumerate}
    \end{definition}
    \begin{figure}[hbt!]
      \centering 
      \begin{lstlisting} 
        # Static information about the filesystems.
        # See fstab(5) for details.

        # <file system> <dir> <type> <options> <dump> <pass>
        # /dev/nvme0n1p9
        UUID=abcfef03-bfae-4d1f-b463-fd6538f18a41	/ ext4 rw,relatime 0 1
        # /dev/nvme0n1p7
        UUID=150D-7A67 /boot vfat rw,relatime,fmask=0077,dmask=0077,codepage=437,
            iocharset=ascii,shortname=mixed,utf8,errors=remount-ro	0 2
        # /dev/nvme0n1p8
        UUID=5c191f65-b016-475d-b04a-5b7c89bda31d	none swap defaults 0 0
      \end{lstlisting}
      \caption{My personal fstab file.} 
      \label{fig:fstab}
    \end{figure}

    \subsubsection{Mounting a Remote Disk} 

      It is actually possible to mount a folder on a server into your local machine. To do this, you use \textbf{sshfs} to mount a remote directory over SSH. The general syntax is \texttt{sshfs user@host:/remote/dir /local/dir} to mount and \texttt{fusermount -u /local/dir} to unmount. 

  \subsection{Maintence} 

    \subsubsection{SSD}

      As soon as your write or delete bits from the SSD (e.g. when you're deleting a file), it degrades the speed of the read/write. To alleviate the effects, you can use TRIM, which is a command that allows the operating system to inform the SSD which blocks of data are no longer considered in use and can be wiped internally. It can be downloaded as a part of the \texttt{util-linux} package, which provides the systemd services \textbf{fstrim.timer} and \textbf{fstrim.service}. It is recommended to use weekly trims rather than continuous trims. 

    \subsubsection{Filesystem} 

      Occasionally, you may have a corrupt partitions, whether it is your boot or root directory. In this case, you should use the \textbf{fsck} command to check and repair a filesystem. The general steps are: 
      \begin{enumerate} 
        \item unmount the specific partition you want (identified with \textbf{lsblk}) using \texttt{sudo umount /dev/partition}. 
        \item run \texttt{sudo fsck -t type device} (or for specific filesystem types like vfat you can be a bit more specific by running \texttt{sudo fsck.vfat /dev/partition}) to check the filesystem and fix any changes. 
        \item mount the specific partition back using \texttt{sudo mount /dev/partition}. 
      \end{enumerate}

  \subsection{Modifying Partitions} 
    
    Modifying partitions require specialized software. Partitioning can be done using two main partitioning schemes \textbf{GPT} (the modern one) and \textbf{MBR} (legacy). The \textbf{parted} utility gives detailed info on your partitions. To see which scheme you have, just run \texttt{sudo parted -l}, where the output can be shown in Figure \ref{fig:parted}. 

    \begin{figure}[hbt!]
      \centering 
      \begin{lstlisting} 
        Model: PM9A1 NVMe Samsung 1024GB (nvme)
        Disk /dev/nvme0n1: 1024GB
        Sector size (logical/physical): 512B/512B
        Partition Table: gpt
        Disk Flags: 

        Number  Start   End     Size    File system     Name                          Flags
         1      1049kB  253MB   252MB   fat32           EFI system partition          boot, esp
         2      253MB   387MB   134MB                   Microsoft reserved partition  msftres
         3      387MB   333GB   332GB   ntfs            Basic data partition          msftdata
         7      333GB   333GB   524MB   fat32                                         boot, esp
         8      333GB   338GB   5000MB  linux-swap(v1)                                swap
         9      338GB   1004GB  666GB   ext4
         4      1004GB  1005GB  1038MB  ntfs                                          hidden, diag
         5      1005GB  1023GB  17.9GB  ntfs                                          hidden, diag
         6      1023GB  1024GB  1503MB  ntfs                                          hidden, diag


        Model: Unknown (unknown)
        Disk /dev/zram0: 4295MB
        Sector size (logical/physical): 4096B/4096B
        Partition Table: loop
        Disk Flags: 

        Number  Start  End     Size    File system     Flags
         1      0.00B  4295MB  4295MB  linux-swap(v1) 
      \end{lstlisting}
      \caption{Output of \texttt{sudo parted -l} on my own machine. } 
      \label{fig:parted}
    \end{figure}

    It is important to know which partition scheme you should use. 
    \begin{enumerate} 
      \item To dual-boot with Windows (both 32-bit and 64-bit) using Legacy BIOS, the MBR scheme is required.
      \item To dual-boot Windows 64-bit using UEFI mode instead of BIOS, the GPT scheme is required.
      \item If you are installing on older hardware, especially on old laptops, consider choosing MBR because its BIOS might not support GPT.
      \item If you are partitioning a disk that is larger than 2TB, you need to use GPT.
      \item It is recommended to always use GPT for UEFI boot, as some UEFI implementations do not support booting to the MBR while in UEFI mode.
    \end{enumerate}

\section{Firmware} 

    Let us go through the steps of a booting (bootstrapping) process. Administrators have little direct, interactive control over most of the steps required to boot a system, but they can modify bootstrap configurations by editing config files or system startup scripts. 

    \begin{enumerate}
      \item \textbf{Power On}: You power on the machine. 
      \item \textbf{Load firmware from NVRAM}: You want to be able to identify the specific piece of hardware to load your operating system in. The firmware is a permanent piece of software that does this. 
      \item \textbf{Probe for hardware}: We look for hardware that is on the computer. 
      \item \textbf{Select boot device (disk, network, etc.)}: We select the storage device that we want to load the operating system on. 
      \item \textbf{Identify EFI system partition}: 
      \item \textbf{Load boot loader (e.g. GRUB)}: A software that allows you to identify and load the proper OS kernel is provided. 
      \item \textbf{Determine which kernel to boot}: You choose which kernel you want to load.  
      \item \textbf{Load kernel}: The OS kernel is identified and loaded into the boot device. 
      \item \textbf{Instantiate kernel data structure}: 
      \item \textbf{Start init/systemd as PID 1}: 
      \item \textbf{Exectute startup scripts}:
      \item \textbf{Running system}: You now have a running system! 
    \end{enumerate}

    Right above the hardware, the \textbf{system firmware}, is a piece of software that is executed whenever the computer boots up. 
    \begin{enumerate} 
      \item \textbf{Power Supply Activation}: Once the computer is turned on, the power supply begins to provide electricity to the system's components. One of the first signals generated is the "Power Good" signal, indicating that the power supply is stable and at the correct voltages. 
      \item \textbf{CPU Reset}: Upon receiving the "Power Good" signal, the CPU resets and starts its operations. The CPU is designed to start executing instructions from a predefined memory address, which is hardwired into the CPU. This address, stored in ROM, contains the starting point of the firmware.\textbf{Read Only Memory} is simply another type of computer memory that stores permanent data and instructions for the device to start up. 
      \item \textbf{Predefined Memory Address}: For BIOS systems, the CPU begins executing code at the firmware entry point located in the system's ROM (Read-Only Memory). In UEFI systems, the process is similar, but the UEFI firmware provides more functionalities and a more flexible pre-boot environment.
      \item \textbf{POST (Power on Self Test)}: The firmware conducts a series of diagnostic tests to ensure that essential hardware components like RAM, storage devices, and input/output systems are functioning correctly. This stage is critical for verifying system integrity before loading the operating system.
    \end{enumerate}

    To be honest, there is not a lot that the user can control here with just software. The firmware is a permanent piece of software that is executed whenever the computer boots up, which makes it relatively safe from tampering. If your computer fails to boot up, the most fundamental reason may be a firmware problem. However, we're not screwed yet. 

    Most firmware offers a user interface which can be accessed by pressing the F2, F11, F12, or some combination of magic keys at the instant the system first powers on. Depending on what computer model you have, you may have some control of basic functionalities. 
    
    \begin{figure}[hbt!]
      \centering 
      \includegraphics[scale=0.3]{img/xps_firmware.jpg}
      \caption{Firmware of Dell XPS 13 9320} 
      \label{fig:xps_firmware}
    \end{figure}

    Some important functionalities you can do with the firmware are: 
    \begin{enumerate} 
      \item Determine the boot order of the devices, usually by prioritizing a list of available options (e.g. try to boot from a DVD drive, then a USB, then the hard disk). 
      \item 
    \end{enumerate}

    The \textbf{BIOS}, which stands for \textbf{Basic Input/Output System}, has been used traditionally. It is mainly responsible for loading the bootloader. When the computer starts, it runs a \textbf{Power on Self Test (POST)} to make sure that core hardware such as the memory and hard disk is working properly. Afterward, the BIOS will check the primary hard drives' \textbf{Master Boot Record (MBR)}, which is a section on your hard drive where the bootloader is located. 

    A more formalized and modern standard called \textbf{EFI} (\textbf{Extensible Firmware Interface}) has replaced it, and it has been revised to the \textbf{UEFI} (\textbf{Unified Extensible Firmware Interface}) standard, but we can treat EFI and UEFI as equivalent in most cases. Fortunately, most UEFI systems can fall back to a legacy BIOS impelmentation if the operating system they're booting doesn't support UEFI. Since we're likely to encounter boot firmware systems, it's worthwhile to go into both of them. 

  \subsection{Updating Firmware}

    The first thing you should do when you're having trouble with firmware is use \textbf{fwupd}, which is a daemon that handles firmware updates. It is a simple daemon to allow session software to update device firmware on your local machine. Upon installation, it creates a systemd agent on \texttt{/lib/systemd/system/fwupd.service}. It does not start automatically. I have used this to update my firmware, which saved a lot of booting errors, with instructions accessed in this \href{https://wiki.archlinux.org/title/fwupd}{link}. 

  \subsection{Modifying UEFI Variables}

    You can directly examine and modify UEFI variables on a running system with the \texttt{efibootmgr} command. You get a following summary of the configuration: 
    \begin{lstlisting}
      BootCurrent: 0005
      Timeout: 0 seconds
      BootOrder: 0005,0001,0002,0000,0003,0004
      Boot0000* UEFI PM9A1 NVMe Samsung 1024GB S65VNE0R318841 1	...
      Boot0001* ubuntu	HD(1,GPT,ede98b7e-75ad-452e-ab47-3411dd6026c1,0x800,0x780...
      Boot0002* Windows Boot Manager	HD(1,GPT,ede98b7e-75ad-452e-ab47-3411dd60...
      Boot0003* Linux Firmware Updater	HD(1,GPT,ede98b7e-75ad-452e-ab47-...
      Boot0004* UEFI PM9A1 NVMe Samsung 1024GB S65VNE0R318841 1 2	PciRoot(0x0)/...
      Boot0005* Linux Boot Manager	HD(7,GPT,2d28b70f-725b-4ca3-98d4-25f5c83fc00e...
    \end{lstlisting}

    It shows you which disk you are currently booted into, the boot order that is currently configured, and information about each of the disks. You can use a GUI to do this as well. You can press a certain key when booting (F2 on my Dell XPS15 9500) to enter the \textbf{BIOS setup}. 

    \begin{figure}[H]
      \centering 
      \includegraphics[scale=0.45]{img/firmware.jpeg}
      \caption{The BIOS setup can look very different depending on the computer but looks like this for me.} 
      \label{fig:bios_setup}
    \end{figure}

    From here, we can edit different settings like boot options (priority of booting OS), certain video settings, etc. 

  \subsection{Recovery Mode}

    Occasionally, you may run into problems with booting up the system. You can go into \textbf{recovery mode} by looking at the advanced options in the GRUB menu and selecting the option that literally says recovery mode. 

    \begin{center}
      \includegraphics[scale=0.3]{img/recovery1.png}
    \end{center}

    This gives us a list of options that we can take to fix the system. Every setting except root is automatically done. The root command gives us root privileges (no sudo is needed). This also means we have full access to all files, and we may cause irreversible damage to our system if we made a mistake. If we had not enabled read/write access with "Enable networking" the filesystem will be mounted read only, and we are unable to edit files. In case we don't have access to a network, or this was not desired, we can remount our filesystem(s) giving write access with the following command:  
    \begin{lstlisting}
      mount -o rw,remount /
    \end{lstlisting}
    With editing privileges, we can hopefully better diagnose or undo our problems. Finally, from the root shell type $\texttt{exit}$ to go back to the menu. 

\section{Bootloaders} 

  Once the firmware is loaded, which probes the system to find the hardware, it must load the operating system kernel. This is the job of the boot loader.

  \begin{definition}[Boot Loader, Boot Manager]
    The \textbf{bootloader} is another critical piece of software that allows you to identify and load the proper operating system kernel. If it also provides an interactive menu with multiple boot choices, then it is often called a \textbf{boot manager}. 
  \end{definition}

  In modern systems which support UEFI (not the legacy BIOS), you must configure your partitions so that there exists an EFI partition (at \texttt{/boot}) that contains this bootloader. 

  EFI bootloaders usually have a \texttt{.efi} extension, and it is crucial that you know where the bootloaders are in your system in case they go missing or are corrupt. To see the configuration, you can run \textbf{efibootmgr} (with verbose), which gives you information on several things: 
  \begin{enumerate} 
    \item It scans the entire system for EFI bootloaders and lists them. 
    \item It lists the locations of the EFI bootloaders. It starts off which what partition they are in, and then lists the directory where the bootloader is located. \texttt{BootX64.efi} is the Windows bootloader and \texttt{grubx64.efi} is the GRUB bootloader. For example, you may have a bootloader at \texttt{(partition 7)/boot/efi/EFI/Boot/bootx64.efi}. 
    \item It lists the boot order, which is the order in which the bootloaders are loaded. In case a boot loader fails to load, the next one is loaded. Therefore, if you have an arch linux bootloader that is corrupt, and the next in line is the Windows bootloader, you will automatically boot into Windows. You can also set the boot order in the BIOS. 
  \end{enumerate}

  In case you can't boot in, you can always get an Arch ISO burned in on a thumb drive, boot into it, mount the relevant partitions containing the Arch bootloader and the root directory, and then chroot into the root directory to modify files. 

  \subsection{GRUB}

    The way that these kernels can be loaded can be configured through the bootloader, and the most popular boot manager is \textbf{GRUB}, the \textbf{Grand Unified Bootloader}. GRUB, developed by the GNU project, is the default loader on most Linux distributions. There is an old version called GRUB legacy and the more modern GRUB 2. Most people refer to GRUB 2 and simply GRUB. FreeBSD, which is another complete (non-Linux) OS, have their own boot loader, but GRUB is compatible with it. Therefore, for dual-boot or triple-boot systems that have multiple kernels, GRUB is the go-to bootloader for loading any of them. 

    \begin{figure}[H]
      \centering 
      \includegraphics[scale=0.4]{img/grub2-in-ubuntu.png}
      \caption{GRUB menu on my screen. Ubuntu does not display the GRUB menu by default. To see GRUB during boot you need to press the right-hand SHIFT key during boot. } 
      \label{fig:grub}
    \end{figure}


    As a critical piece of software, we would expect its configuration files to be in the NVRAM, but GRUB understands most of the filesystems in common use and can find its way into the root filesystem on its own. Therefore, we can read its configuration from a regular text file, kept in \texttt{/boot/grub/grub.cfg}. Changing the boot configuration is as simple as updating the \texttt{grub.cfg} file, but it is not advised to edit it directly. Rather, we can edit the $\texttt{/etc/default/grub}$ file and run $\texttt{sudo update-grub}$ to that the changes are written to $\texttt{grub.cfg}$ automatically.  

\section{Systemd} 

  A \textbf{process} is really any program that is running on your computer. A \textbf{daemon} is a background process that runs continuously, performing specific tasks even when no user is logged in. 

  Once the kernel has been loaded and completed its initialization process, it creates a collection of \textit{spontaneous} (as in the kernel starts them automatically) processes in user space. They're really part of the kernel implementation and don't necessarily correspond to programs in the filesystem. They're not configurable and they don't require administrative attention. These processes can be monitored with the commands \texttt{ps}, \texttt{top}, or \texttt{htop}.

  The most important process is the init process, with a system PID of 1 and with special privileges. It is used to get the system running and for starting other processes. 

  \begin{enumerate}
    \item Setting the name of the computer 
    \item Setting the time sone 
    \item Checking disks with \texttt{fsck} 
    \item Mounting filesystems 
    \item Removing old files from the \texttt{/tmp} directory 
    \item Configuring network interfaces
    \item Configuring packet filter 
    \item Starting up other daemons and network services, along with killing zombie processes or parenting orphaned processes. 
  \end{enumerate}

  There are three flavors of system management processes in widespread use: 
  \begin{enumerate}
    \item Historically, SysVinit was a series of plaintext files that ran as scripts to start processes, but due to some problems, Linux now uses systemd.
    \item An init variant that derives from the BSD UNIX, used on most BSD-based systems. 
    \item A more recent contender called \textbf{systemd} which aims to cover the init processes and much more. This significant increase in control causes some controversy. 
    \item Other flavors include Apple MacOS's \textbf{launchd} before it adopted systemd. Ubuntu also used \textbf{Upstart} before migrating to systemd. 
  \end{enumerate}

  Systemd is essentially a collection of smaller programs, services, and libraries such as systemctl, journalctl, init, process management, network management, login management, logs, etc. Some processes may depend on other processes, and with hundreds of them, it's very hard to do manually, which is why systemd does it all for you. A post on the systemd blog notes that a full build of the project generates 69 different binaries (subject to change). 

  \begin{definition}
    A \textbf{unit} is anything that is managed by systemd. It can be ``a service, a socket, a device, a mount point, an automount point, a swap file or partition, a startup carget, a watched filesystem path, a time controlled and supervised by systemd, a resource management slice, or a group of externally created processes." Within systemd, the behavior of each unit is defined and configured by a \textbf{unit file}. Within systemd, the behavior of each unit is defined and configured by a \textbf{unit file}. 

    The files are all over the place: 
      \begin{enumerate}
        \item \texttt{/lib/systemd/system} contains standard systemd unit files 
        \item \texttt{/usr/lib/systemd/system} are from locally installed packages, e.g. if I installed a pacman package that contained unit files, then those would go here. 
        \item \texttt{/etc/systemd/system} is where you put your custom files. etc also has the highest priority, so it overwrites the other files.  
        \item \texttt{/run/systemd/system} is a scratch area for transient units. 
      \end{enumerate}

    By convention, unit files are named with a suffix that varies according to the type of unit being configured. For example, service units have a \texttt{.service} suffix and timers user \texttt{.timer}. Within the unit file, some sections e.g. (\texttt{[Unit]}) apply generically to all kinds of units, but others (e.g. \texttt{[Service]}) can appear only in the context of a particular unit type. 

  \end{definition}

  \begin{example}[Service Unit File]
    If we go into one of these unit files, which have the prefix \texttt{.service}, they are usually formatted as such: 

    \begin{lstlisting}
      # comments are just the same as in bash Scripts
      # the headers are important! 

      [Unit]        #  
      Description=Description of the unit file 
      Documentation=man:something 
      After=network.target

      [Service]
      Type=forking  # tells that the process may exit and is not permanent
      PIDFile=      # 
      ExecStartPre= # scripts to run before you start 
      ExecStart=    # scripts to run when starting 
      ExecReload=   # script to run when you try to reload the process
      ExecStop=     # script to run to stop the process 

      [Install]   # Tells at what point should this be running
      WantedBy=multi-user.target 

    \end{lstlisting} 
  \end{example}
  
  \subsection{systemctl: Managing systemd} 

    \textbf{systemctl} is an all-purpose command for investigating the status of systemd and making changes to its configuration. Running \texttt{systemctl} without any arguments invokes the default \texttt{list-units} subcommand, which shows all loaded and activive services, sockets, targets, mounts, and devices. To show only services, use \texttt{--type=service}. 

    The two main commands that you will use to interact with systemd is \texttt{systemctl} and \texttt{journalctl}. 
    
    \begin{enumerate}
      \item \texttt{systemctl status unit} checks the status, ouputting the description, whether it's enabled/disabled, and whether it's active/inactive. 
      \item \texttt{systemctl enable unit} enables it, which means that it will start when booting the computer. It does this by creating a symlink to the unit file. This is different from start. 
      \item \texttt{systemctl disable unit} disables it. 
      \item \texttt{systemctl start unit} starts it now and runs it immediately. 
      \item \texttt{systemctl stop unit} makes it inactive. 
      \item \texttt{systemctl reload} will run whatever is in the \texttt{ExecReload} in the unit file. 
      \item \texttt{systemctl restart} runs ExecStop and then ExecStart. 
      \item \texttt{systemctl kill unit} kills the process. 
    \end{enumerate}

    Some of the statuses that you may see are inactive (deactivated, exited), active (activating, running), failed, static (not started, frozen by systemd), bad (broken, probably due to bad unit files), masked (ignored by systemd), indirect (disabled, but another unit file references it so it could be activated). 

    To troubleshoot, you should run \texttt{systemctl --failed} to see if there are any failed processes, which can be a problem, and then you can use \texttt{journalctl --since=today} to view your systemd logs. This log is important for diagnosing fundamental problems with your system. To view only entries logged at the error level or above, you can set the priorities with \texttt{-p err -b}. 

  \subsection{Targets}

    
  \subsection{Systemd Logging}

    The \textbf{journald} daemon allows you to capture log messages produced by the kernel and services. These system messages are stored in the \texttt{/run} directory, but we can access them directly with the \texttt{journalctl}  command. 

    \begin{example}
      
    \end{example}

    You can configure \textbf{journald} to retain messages from prior boots. To do this, edit the following file and configure the \texttt{Storage} attribute: 
    \begin{lstlisting}
    #/etc/systemd/journald.conf
      [Journal]
      Storage=persistent
    \end{lstlisting}

    Then, you can obtain a list of prior boots with \texttt{journalctl --list-boots} and you can access messages from a prior boot by referring to its index or by naming its long-form ID: \texttt{journalctl --b -1}. 

\section{Directory Structure} 

    It should be clear that the $\texttt{~}$ stands for your user home directory, while $\texttt{/}$ stands for the root directory. 
    \begin{lstlisting}
    (base) mbahng@xps15:~\$ pwd
    /home/mbahng
    (base) mbahng@xps15:~\$ cd /
    (base) mbahng@xps15:/\$ pwd
    /
    \end{lstlisting}

    Let us now take a look at the contents of the root directory: 
    \begin{lstlisting}
    (base) mbahng@xps15:~\$ ls /
    bin    dev   lib    libx32      mnt   root  snap  timeshift  var
    boot   etc   lib32  lost+found  opt   run   srv   tmp
    cdrom  home  lib64  media       proc  sbin  sys   usr
    \end{lstlisting}
    You can see that the root home directory is in here, as opposed to user home directories in the $\texttt{/home}$ folder. 
    \begin{enumerate}
        \item $\texttt{root}$: This contains all the files for when you need to boot. You shouldn't mess with this. 
        \item $\texttt{etc}$: This is where you system wide configuration for applications is stored (unlike local configuration files for one user, which is stored in your home directory). It is often a target for backups. 
        \item $\texttt{media}$, $\texttt{mnt}$: Used for mounting external storage systems and even internal storage systems. 
        \item $\texttt{opt}$: A place where you can install whatever you want. Quite flexible. 
    \end{enumerate}

  \subsection{Users and Permission}

    \subsubsection{Managing Users}

      You should first check which users are on your system. Most people just check their home directory using 
      \begin{lstlisting}
      (base) mbahng@xps15:~\$ ls -l /home
      total 8
      drwxr-xr-x  3 root   root   4096 Jan 17 23:57 linuxbrew
      drwxr-xr-x 44 mbahng mbahng 4096 Jul  2 13:27 mbahng
      \end{lstlisting}
      But this is not accurate. Rather, we should check the contents of the $\texttt{/etc/passwd}$ file, which has a list of users in our computer (1 per line). The purpose is to contain a listing of and the options that are associated with your user accounts on your server. 
      \begin{lstlisting}
      (base) mbahng@xps15:~\$ cat /etc/passwd
      root:x:0:0:root:/root:/bin/bash
      daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
      bin:x:2:2:bin:/bin:/usr/sbin/nologin
      sys:x:3:3:sys:/dev:/usr/sbin/nologin
      sync:x:4:65534:sync:/bin:/bin/sync
      games:x:5:60:games:/usr/games:/usr/sbin/nologin
      man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
      lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
      mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
      news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
      uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
      proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
      www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
      backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
      list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
      irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
      gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
      nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
      ...
      \end{lstlisting}
      Let us just examine my user. 
      \begin{lstlisting}
      (base) mbahng@xps15:~\$ cat /etc/passwd | grep mbahng
      mbahng:x:1000:1000:mbahng,,,:/home/mbahng:/bin/bash
      \end{lstlisting}
      Going from left to right, mbahng is my user, the x stands for a hashed password that cannot be shown, the 1000 is the user id (UID), the 1000 is the group id (GID), mbahng is the user information field (optional), next $\texttt{/home/mbahng}$ is the user's home directory, and finally $\texttt{/bin/bash}$ is the shell designated for the user. When you create a user id when first installing Ubuntu, this will almost always have uid of 1000. On most linux distributions, the user accounts that will be used by humans are given uids of 1000 and above. Note that in Ubunutu 22.04, a home directory is not created automatically (this differs based on distribution) when we create a new user. So note the following commands. To add a user called batman, we have 
      \begin{lstlisting}
      (base) mbahng@xps15:~\$ sudo useradd batman         # just add user 
      (base) mbahng@xps15:~\$ sudo useradd -m batman      # add user with home dir 
      (base) mbahng@xps15:~\$ cat /etc/passwd | grep batman
      batman:x:1001:1001::/home/batman:/bin/sh
      \end{lstlisting}
      and it gives a new uid that is the next available one from 1000, i.e. 1001. To delete the user, just do 
      \begin{lstlisting}
      (base) mbahng@xps15:~\$ sudo userdel batman         # delete user
      (base) mbahng@xps15:~\$ sudo userdel -r batman      # delete user w/ home dir
      \end{lstlisting}
      Now let's talk about changing passwords. If you want to change your own password, you can just type $\texttt{passwd}$ and go through the steps. To set another user's password, you need to be in root mode and type 
      \begin{lstlisting}
      (base) mbahng@xps15:~\$ sudo passwd batman          # set password for batman
      \end{lstlisting}

      Note that we have a hashed version of the user's password in the $\texttt{/etc/passwd}$ file. We can actually see the full hashed versions by going into $\texttt{/etc/shadow}$. 

    \subsubsection{Changing Permission}

      Running $\texttt{ls -l}$ command lists all files and directories in your current working directory, along with their permissions. 
      \begin{lstlisting}
        -rw-rw-r--  1 mbahng mbahng 4336730777 Sep 29  2022  cuda_11.8.0_520.61.05_linux.run
        drwxr-xr-x  9 mbahng mbahng       4096 Jul  1 23:33  Desktop
        drwxr-xr-x  8 mbahng mbahng       4096 Jul  1 15:08  Documents
        drwxr-xr-x  6 mbahng mbahng      12288 Jul  1 22:36  Downloads
        drwxr-xr-x  4 mbahng mbahng       4096 Jun 29 19:43  Games
        drwxr-xr-x  6 mbahng mbahng       4096 Feb 22 17:27  Jts
        drwxrwxr-x  5 mbahng mbahng       4096 Jun 28 19:39  KakaoTalk
        drwxr-xr-x 16 mbahng mbahng       4096 Jun  2 21:13  miniconda3
        drwxrwxr-x  4 mbahng mbahng       4096 Jun 22 13:12  nltk_data
      \end{lstlisting}
      The first columm is a string of 10 characters representing the permissions. They are divided into 4 sections: 
      \begin{lstlisting}
      d   rwx   r-x   r-x 
      \end{lstlisting}
      The first letter can be a d, l, or -, meaning directory, link, or file, respectively. The next three groups, representing the permissions of the user (third columm), group (fourth), and everyone else, have the same format. It is rwx, which stands for read, write, execute. 
      \begin{enumerate}
          \item Read: Means to read a file or read a directory. 
          \item Write: Means to edit a file or modify the contents of a directory. 
          \item Execute: Means to run the file as an executable or go $\texttt{cd}$ into the directory. 
      \end{enumerate}
      A dash in place of any one of them means that whatever entity does not have the permissions. However, we can set the permissions using the $\texttt{chmod}$ command. If we have a file named $\texttt{testfile.txt}$ in our current directory, we can add or revoke permissions with 
      \begin{lstlisting}
      chmod +r testfile.txt   // assign read permissions to all users
      chmod +w testfile.txt   // assign write permissions to all users
      chmod +x testfile.txt   // assign execute permissions to all users

      chmod g+rw testfile.txt   // assign read and write to group 
      chmod u-r testfile.txt   // revoke read to user
      chmod o+x testfile.txt   // assign execute to other users 
      \end{lstlisting} 
      Writing all these can be tedious, so what we can do is take advantage of the numerical encodings of the permissions. Note that $r=4, w=2, x=1$, and so any number between $0$ and $7$ can encode the three bits (through the coefficients of the binary expansion). Therefore, if we wanted every permission for all users, we can write 
      \begin{lstlisting}
      chmod 770 testfile.txt
      \end{lstlisting}
      where the first 7 stands for $\texttt{rwx}$, the next 7 stands for $\texttt{rwx}$, and the final $0$ stands for $\texttt{---}$. To change the permissions for everything inside a directory (e.g. say you want to make all downloads only readable and writable by you), then you can type 
      \begin{lstlisting}
      chmod 600 ~/Downloads/*
      \end{lstlisting}

    \subsubsection{Changing Ownership}

      If you have multiple users in your computer (type $\texttt{ls /home}$), then you may want to give ownership of a directory or folder to another user. 
      \begin{lstlisting}
        (base) mbahng@xps15: ls /home
        batman mbahng
      \end{lstlisting}
      To change permissions of a file/directory to another user and group, we can use the $\texttt{chown}$ command (with sudo) 
      \begin{lstlisting}
        sudo chown -R batman:batman Downloads/
      \end{lstlisting}

\section{Display Servers}

  When you boot up your computer, you are greeted with a graphical user interface (GUI) that allows you to interact with your computer. This is the job of the display server, which is a program that provides graphical display capabilities for the operating system. 

  \begin{definition}[Display Server]
    A \textbf{display server} is a program that manages the communication between your computer's hardware and graphical software applications. It acts as a bridge for input and output devices; for example, it processes the input from your keyboard and mouse and outputs graphics to the monitor. The display server is responsible for the fundamental task of drawing windows and handling the low-level aspects of input and output, but it doesn't dictate how these windows look or are arranged. For almost every purpose, there are two types of display servers: 
    \begin{enumerate} 
      \item \textbf{X}: The X Window System, which is the older and more established display server. 
      \item \textbf{Wayland}: The newer and more modern display server.
    \end{enumerate}
  \end{definition}

  \begin{definition}[X Window System]
    The \textbf{X Window System} is a windowing protocol for Unix/Linux OSes, similar to the way that Microsoft Windows or Apple Mac OS X can run different apps in separate windows. \textbf{X} defines the protocol for a display server what can render windows on a \textit{display client} (your computer), inside which are running apps.\footnote{Explanation here: https://www.reddit.com/r/linuxquestions/comments/3uh9n9/what\_exactly\_is\_xxorgx11/} 
    \begin{enumerate} 
      \item \textbf{X11} refers to version 11 of the X protocol, while 
      \item \textbf{Xorg} is an open-source implementation of X. 
    \end{enumerate}
  \end{definition}

  \begin{definition}[Wayland]
    X, made in 1984, has developed a lot of cruft over the years, and Wayland is a modern replacement for X. It is a protocol for a compositor to talk to its clients, as well as a C library implementation of that protocol. The compositor can be a standalone display server running on Linux kernel modesetting and evdev input devices, an X application, or a wayland client itself. 
  \end{definition}

\section{Package Management}
  
  Linux comes in many flavors of distributions. Most beginners look at screenshots of these distributions on the internet and judge them based on their aesthetics (e.g. I like how Kali Linux looks so I'll go with that one). A common feature of all Linux distributions is that they provide the user the power to customize their system however they want, so you can essentially make every linux distribution look like any other. So what are some things you should consider when choosing a distribution? 

  \begin{enumerate}
    \item First is the popularity and how well it is supported. This includes the number of people who use the distribution (e.g. the Ubuntu StackExchange is a very large community) and how good the documentation is overall (e.g. the ArchLinux wiki is very well documented). 
    \item Each linux distribution essentially consists of a kernel and package manager. The architecture, design, and the update scheme of the kernel may be an interest to many linux users.  
    \item Every distribution has its own native package manager, and the availability of certain necessary packages, the ease of installation, and the updating schemes is also something to consider.  
    \item The ideals of the respective communities. The community behind each distribution has a certain set of ideals that they lean more towards. For example, the Ubuntu community likes having programs that are right out of the box, with good GUI support and is more beginner-friendly while Arch has more of a minimal and extremely customizable nature to it with its software being much more CLI dependent. 
  \end{enumerate}

  Let's begin with the package managers. Every application on your system (Firefox, Spotify, pdf readers, VSCode, etc.) is a package, and manually downloading and managing each one is impossible to do. Therefore, each distribution has its own native package manager that automatically takes care of downloading, installing, removing, checking dependency requirements of each package. In order to download a package, a package manager should also know where it is downloading \textit{from}. Essentially, a package manager itself can be downloaded with other package managers, so package managers are packages as well. 
  
  \begin{enumerate}
    \item \textbf{apt} : The advanced packaging tool is the native manager for Ubuntu distributions. 
    \item \textbf{pacman} : Native package manager for Arch Linux. 
    \item \textbf{yay} : The package manager for software in the \textbf{Arch User Repository}. 
    \item \textbf{snap} : 
    \item \textbf{flatpak} : 
    \item \textbf{dpkg} : Package manager for Debian based distributions. 
  \end{enumerate}

  Chances are if you are using one distribution, you would only have to work with a small subset of these package managers. Each package manager has one or more files in the computer that specify a list of \textbf{repositories}. 

  \subsection{Wget}

    wget is a command-line utility used to download files from the internet. It stands for "web get." 

  \subsection{Pacman}

    For example, the configuration file for pacman is located at \texttt{/etc/pacman.conf}. In the options section, I can configure stuff like text color, enabling/disabling parallel downloads, choosing specific packages to ignore upgrading, etc. Then, we can specify the servers that we should download from. In the text below, the server variable defines which server we should look at first, and then the Include variable stores the location of the file \texttt{mirrorlist} that defines a list of other servers that we should download from. 
    
    \begin{figure}
      \begin{lstlisting} 
        # The following paths are commented out with their default values listed.
        # If you wish to use different paths, uncomment and update the paths.
        #RootDir     = /
        #DBPath      = /var/lib/pacman/
        #CacheDir    = /var/cache/pacman/pkg/
        #LogFile     = /var/log/pacman.log
        #GPGDir      = /etc/pacman.d/gnupg/
        #HookDir     = /etc/pacman.d/hooks/
        HoldPkg     = pacman glibc
        #XferCommand = /usr/bin/curl -L -C - -f -o %o %u
        #XferCommand = /usr/bin/wget --passive-ftp -c -O %o %u
        #CleanMethod = KeepInstalled
        Architecture = auto

        # Pacman won't upgrade packages listed in IgnorePkg and members of IgnoreGroup
        #IgnorePkg   =
        #IgnoreGroup =

        #NoUpgrade   =
        #NoExtract   =

        # Misc options
        #UseSyslog
        #Color
        #NoProgressBar
        CheckSpace
        #VerbosePkgLists
        ParallelDownloads = 5
        ILoveCandy

      \end{lstlisting}
      \caption{Subset of contents of the \texttt{/etc/pacman.conf} file} \label{fig:pacman.conf}
    \end{figure}
    
    The mirrorlist file stores a list of URLs. Each URL is a \textbf{mirror}, which is a server that contains a physical replica of all the packages that are available to you via \texttt{pacman} (hence the name mirror). You can literally type in the links provided in Figure \ref{fig:mirrorlist} (replacing \texttt{\$repo} with \texttt{core} and \texttt{\$arch} with \texttt{x86\_64}). It contains a tarball of each package ready to be downloaded. Some repos might contain more packages than others, some might have packages that only they supply that others don’t, but if you can install the piece of software via your package manager then one of your configured repos is declaring they have it available and therefore should have the file on hand to give to you if asked for it. A list of all available mirrors are available \href{https://archlinux.org/mirrorlist/all/https/}{here} (this only uses HTTPS, but HTTP mirrors are also available).  

    \begin{figure}
      \begin{lstlisting}
        Server = https://archlinux.mailtunnel.eu/$repo/os/$arch
        Server = https://mirror.cyberbits.eu/archlinux/$repo/os/$arch
        Server = https://mirror.theo546.fr/archlinux/$repo/os/$arch
        Server = https://mirror.sunred.org/archlinux/$repo/os/$arch
        Server = https://mirror.f4st.host/archlinux/$repo/os/$arch
        Server = https://md.mirrors.hacktegic.com/archlinux/$repo/os/$arch
        Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch
        Server = https://mirror.moson.org/arch/$repo/os/$arch
        Server = https://archlinux.thaller.ws/$repo/os/$arch
      \end{lstlisting}
      \caption{Contents of the \texttt{/etc/pacman.d/mirrorlist} file}\label{fig:mirrorlist}
    \end{figure}
    
    The mirrors that you download from should be trustworthy and fast. The speed is mainly related to how close you are to that mirror geographically, so if you are moving to another country you should probably update this mirrorlist for faster download speeds. There is a default mirrorlist file that is generated, but you can download and use the \textbf{reflector} package to update it.  

    Here are some common commands: 
    \begin{enumerate}
      \item Install a package: \texttt{sudo pacman -S pkg1} (\texttt{-s} stands for synchronize)

      \item Remove a package: \texttt{sudo pacman -R pkg}
      \begin{itemize}
        \item remove dependencies also: \texttt{-s} (recursive)
        \item also remove configuration files: \texttt{-n} (no save)
        \item also removes children packages: \texttt{-c} (cascade)
      \end{itemize}

      \item Update all packages: \texttt{sudo pacman -Syu}
      \begin{itemize}
        \item synchronize: \texttt{-S}
        \item refresh package databases: \texttt{-y} (completely refresh: \texttt{-yy})
        \item system upgrade: \texttt{-u}
      \end{itemize}

      \item List installed packages: \texttt{pacman -Q}
      \begin{itemize}
        \item List detailed info about a package: \texttt{pacman -Qi pkg}
        \item List all files provided by a package: \texttt{pacman -Ql pkg}
        \item List all orphaned packages: \texttt{pacman -Qdt}
        \item List all packages that have updates available: \texttt{pacman -Qu}
        \item List all explicitly installed packages: \texttt{pacman -Qet}
        \item Display the dependency tree of a package: \texttt{pactree pkg} (from the \texttt{pacman-contrib} package) 
        \item List last 20 installed packages: 
        \begin{lstlisting}
          expac --timefmt='%Y-%m-%d %T' '%l\t%n' | sort | tail -n 20
        \end{lstlisting}
      \end{itemize}

      \item To check size of current packages and dependencies, download \texttt{expac} and run \texttt{expac -H M '\%m \\t\%n' | sort -h} 

      \item The package cache stored in \texttt{/var/cache/pacman/pkg/} keeps old or uninstalled versions of packages automatically. This is helpful since it also keeps older versions of packages in the cache, and you can manually downgrade in case some packages break.  
      \begin{itemize}
        \item We can delete all cached versions of installed and uninstalled packages, except for the most recent 3, by running \texttt{paccache -r} (provided by the \texttt{pacman-contrib} package). 
        \item To remove all cached packages not currently installed, run \texttt{pacman -Sc}
        \item To remove all cached aggressively, run \texttt{pacman -Scc}
        \item To downgrade, you go into the package cache directory and say you want to see which versions of neovim you have installed. You can \texttt{ls} the directory to see the following. 
        
          \begin{lstlisting}
            neovim-0.9.5-1-x86_64.pkg.tar.zst
            neovim-0.9.5-1-x86_64.pkg.tar.zst.sig
            neovim-0.9.5-2-x86_64.pkg.tar.zst
            neovim-0.9.5-2-x86_64.pkg.tar.zst.sig
          \end{lstlisting}

          We have an older version of neovim installed, and to roll it back we can use 
          \begin{lstlisting} 
            pacman -U neovim-0.9.5-1-x86_64.pkg.tar.zst
          \end{lstlisting}
      \end{itemize} 
    \end{enumerate}

    The pacman log (\texttt{/var/log/pacman.log}) is also useful since it logs all pacman outputs when you do anything with pacman. So if you are looking for the packages that have been installed in the latest \texttt{pacman -Syu}, then you can use this to individually see each package that has been upgraded. 

  \subsection{Yay}

    Yay is used to install from the Arch User repository and must be updated separately. To run this, you can either run \texttt{yay -Syu} or you can just run \texttt{yay}. Since this is not officially maintained, these packages are more likely to break something. The yay logs are not stored separately can can be accessed in the pacman logs. 

  \subsection{Dpkg and Deb files}

    Ubuntu is a Linux distribution within the family of Debian-based systems (with Debian, Linux Mint, etc.). File of the $\texttt{.deb}$ format is used to distribute and install software packages on these systems. A deb package contains the files for a particular software application or library, along with metadata that describes the package and instructions on how to install or remove it. The package format follows a specific structure and includes files such as control files, data files, and scripts. Therefore, many downloaded packages may come in this format, similar to how a file is zipped before we have to extract it. 

    Dpkg is the primary package manager for Debian based systems. It installs, builds, removes, configures, and retrieves information for Debian packages of the $\texttt{.deb}$ format. Given that we have some file $\texttt{package.deb}$ downloaded, the command 
    \begin{lstlisting}
      dpkg -i package.deb
    \end{lstlisting}
    installs the specified package from the $\texttt{package.deb}$ file. Removing it is just (note without the suffix) 
    \begin{lstlisting}
      dpkg -r package
    \end{lstlisting}

  \subsection{Apt}

    \href{https://www.reddit.com/r/Ubuntu/comments/9awvip/eli5_snap_and_flatpak_how_are_they_differ_from_apt/}{read more here}

    While dpkg is the native package manager for Debian based systems, apt is just a built-in Ubuntu tool to help install these Debian packages and manage dependencies. To run apt commands, we must have root privilege, so we should always use sudo. When these command are run, you should get a confirmation question asking whether you want to continue, with [Y/n]. The capital letter is the default, so you can either enter in `y' or just press ENTER. 
    \begin{enumerate}
      \item The update command connects to various URLs to download a list of available packages. Periodically, new packages are introduced to Debian and Ubunutu repositories all the time, so this command refreshes the index so that it knows what packages are available and at what versions. It is a good idea to run this before you use apt commands for the day. 
      \begin{lstlisting}
        sudo apt update
      \end{lstlisting}

      \item The upgrade command just updates all packages and their dependencies to their latest versions. However, this does not update packages which require the installation of \textit{additional} packages. 
      \begin{lstlisting}
        sudo apt upgrade 
      \end{lstlisting}

      \item The dist upgrade updates packages including those that need installation of new dependencies. So it is a good idea to run upgrade first and then dist-upgrade after.  
      \begin{lstlisting}
        sudo apt dist-upgrade 
      \end{lstlisting}
    \end{enumerate}

    Installing and removing packages is easy. 

    \begin{enumerate}
      \item We can install from the apt repository with 
      \begin{lstlisting}
        sudo apt install htop
      \end{lstlisting}

      \item We can remove it with 
      \begin{lstlisting}
        sudo apt remove htop
      \end{lstlisting}
    \end{enumerate}

    If you don't know the name of the application or package you want to install, then you can search for a keyword with apt search. Say that you want to install vim but you don't know what the actual package name is called. You can just type 

    \begin{lstlisting}
      apt search vim
    \end{lstlisting}

    The central location where apt gets its updates from is contained in the $\texttt{/etc/apt/sources.list}$ file. Here is a snippet of it in my system. 
    \begin{lstlisting}
      # deb cdrom:[Ubuntu 22.04.1 LTS _Jammy Jellyfish_ - Release amd64 (20220809.1)]/ 
      jammy main restricted

      # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
      # newer versions of the distribution.
      deb http://us.archive.ubuntu.com/ubuntu/ jammy main restricted
      # deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy main restricted

      ## Major bug fix updates produced after the final release of the
      ## distribution.
      deb http://us.archive.ubuntu.com/ubuntu/ jammy-updates main restricted
      # deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy-updates main restricted

      ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
      ## team. Also, please note that software in universe WILL NOT receive any
      ## review or updates from the Ubuntu security team.
      deb http://us.archive.ubuntu.com/ubuntu/ jammy universe
      # deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy universe
      deb http://us.archive.ubuntu.com/ubuntu/ jammy-updates universe
      # deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy-updates universe
      ...
    \end{lstlisting}

  \subsection{Snap and Flatpak}

    Other package managers that you may need to use often are snap and flatpak, which can both be installed with 
    \begin{lstlisting}
      sudo apt install snap flatpak 
    \end{lstlisting}

\section{Windows Managers and Desktop Environments}

  These days, the terms window managers (WMs) and Desktop Environments (DEs) are used interchangeably, but they mean slightly different things. A window manager is the display software that determines how the pixels for each window overlaps with other and their movement. This is generally divided into two paradigms with the most familiar being \textbf{floating WMs} and the other being \textbf{tiling WMs}. Even before I knew about tiling WMs, I found myself manually tiling windows on floating WMs, so the move to tiling WMs was a no-brainer. 
  
  Some DEs and WMs are: 
  \begin{enumerate}
    \item GNOME 
    \item KDE Plasma
    \item Qtile
  \end{enumerate}

\section{Shells and Terminals}

  Beginners may think of the shell and the terminal to be the same thing, but they are different. The \textbf{shell} is a command line interpreter, a layer that sits on top of the kernel in which the user can interact with. It is essentially the only API to the kernel where the user can input commands and processes them. The \textbf{terminal emulator} is a wrapper program that runs a shell and allows us to access the API. It may be useful to think of the shell as like a programming language and the terminal as a text editor like VSCode. 

  The three most common shells are the following: 
  \begin{enumerate}
    \item \textbf{Bash}: 
    \item \textbf{Zsh}: 
    \item \textbf{Fish}:  
  \end{enumerate}

  Some common terminal emulators (most of which comes as a part of the desktop environment) are the following: 
  \begin{enumerate}
    \item \textbf{Kitty}: 
    \item \textbf{Alacritty}: 
    \item \textbf{Gnome-Terminal}: 
  \end{enumerate}

  \subsection{Crontab}

    To schedule jobs, you run $\texttt{crontab -e}$, which will give you a text file for which you can list jobs. It looks like  

    \begin{lstlisting}
      # Edit this file to introduce tasks to be run by cron.
      # 
      # Each task to run has to be defined through a single line
      # indicating with different fields when the task will be run
      # and what command to run for the task
      # 
      # To define the time you can provide concrete values for
      # minute (m), hour (h), day of month (dom), month (mon),
      # and day of week (dow) or use '*' in these fields (for 'any').
      # 
      # Notice that tasks will be started based on the cron's system
      # daemon's notion of time and timezones.
      # 
      # Output of the crontab jobs (including errors) is sent through
      # email to the user the crontab file belongs to (unless redirected).
      # 
      # For example, you can run a backup of all your user accounts
      # at 5 a.m every week with:
      # 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
      # 
      # For more information see the manual pages of crontab(5) and cron(8)
      # 
      # m h  dom mon dow   command
    \end{lstlisting}

    In the bottom line, we can add the following to run $\texttt{sudo apt update}$ every minute. The 5 columns refer to minute (0-59), hour (0-24), date of month (1-31), month (1-12), and date of week (0-7, where 0 and 7 is Sunday). The asterick means every instance of. 

    \begin{lstlisting}
      # Run every minute
      * * * * * sudo apt update 

      # Run at 9:15am every first day of the month 
      15 9 1 * * sudo apt update

      # Run for every minute of every hour for the 13th day of every month if it is Friday
      * * 13 * 5 sudo apt update
    \end{lstlisting}
    You get the idea. 


\end{document}


\documentclass{article}

% packages
  % basic stuff for rendering math
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath} 
  \usepackage{amssymb}
  % \usepackage{amsthm}

  % extra math symbols and utilities
  \usepackage{mathtools}        % for extra stuff like \coloneqq
  \usepackage{mathrsfs}         % for extra stuff like \mathsrc{}
  \usepackage{centernot}        % for the centernot arrow 
  \usepackage{bm}               % for better boldsymbol/mathbf 
  \usepackage{enumitem}         % better control over enumerate, itemize
  \usepackage{hyperref}         % for hypertext linking
  \usepackage{fancyvrb}          % for better verbatim environments
  \usepackage{newverbs}         % for texttt{}
  \usepackage{xcolor}           % for colored text 
  \usepackage{listings}         % to include code
  \usepackage{lstautogobble}    % helper package for code
  \usepackage{parcolumns}       % for side by side columns for two column code
  

  % page layout
  \usepackage{fancyhdr}         % for headers and footers 
  \usepackage{lastpage}         % to include last page number in footer 
  \usepackage{parskip}          % for no indentation and space between paragraphs    
  \usepackage[T1]{fontenc}      % to include \textbackslash
  \usepackage{footnote}
  \usepackage{etoolbox}

  % for custom environments
  \usepackage{tcolorbox}        % for better colored boxes in custom environments
  \tcbuselibrary{breakable}     % to allow tcolorboxes to break across pages

  % figures
  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{float}            % for [H] figure placement
  \usepackage{tikz}
  \usepackage{tikz-cd}
  \usepackage{circuitikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usepackage{graphicx}
  \usepackage{algorithmic}
  \usepackage{caption} 
  \usepackage{subcaption}
  \captionsetup{font=small}

  % for tabular stuff 
  \usepackage{dcolumn}

  \usepackage[nottoc]{tocbibind}
  \pdfsuppresswarningpagegroup=1
  \hfuzz=5.002pt                % ignore overfull hbox badness warnings below this limit

% New and replaced operators
  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator{\pos}{pos}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\braket}[2]{\langle #1 | #2 \rangle}
  \newcommand{\qed}{\hfill$\blacksquare$}     % I like QED squares to be black

% Custom Environments
  \newtcolorbox[auto counter, number within=section]{question}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Question \thetcbcounter ~(#1)}
  }

  \newtcolorbox[auto counter, number within=section]{exercise}[1][]
  {
    colframe = teal!25,
    colback  = teal!10,
    coltitle = teal!20!black,  
    breakable, 
    title = \textbf{Exercise \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{solution}[1][]
  {
    colframe = violet!25,
    colback  = violet!10,
    coltitle = violet!20!black,  
    breakable, 
    title = \textbf{Solution \thetcbcounter}
  }
  \newtcolorbox[auto counter, number within=section]{lemma}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Lemma \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{theorem}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Theorem \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proposition}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Proposition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{corollary}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Corollary \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proof}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Proof. }
  } 
  \newtcolorbox[auto counter, number within=section]{definition}[1][]
  {
    colframe = yellow!25,
    colback  = yellow!10,
    coltitle = yellow!20!black,  
    breakable, 
    title = \textbf{Definition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{example}[1][]
  {
    colframe = blue!25,
    colback  = blue!10,
    coltitle = blue!20!black,  
    breakable, 
    title = \textbf{Example \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{code}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Code \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{algo}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Algorithm \thetcbcounter ~(#1)}
  } 

  \BeforeBeginEnvironment{example}{\savenotes}
  \AfterEndEnvironment{example}{\spewnotes}
  \BeforeBeginEnvironment{lemma}{\savenotes}
  \AfterEndEnvironment{lemma}{\spewnotes}
  \BeforeBeginEnvironment{theorem}{\savenotes}
  \AfterEndEnvironment{theorem}{\spewnotes}
  \BeforeBeginEnvironment{corollary}{\savenotes}
  \AfterEndEnvironment{corollary}{\spewnotes}
  \BeforeBeginEnvironment{proposition}{\savenotes}
  \AfterEndEnvironment{proposition}{\spewnotes}
  \BeforeBeginEnvironment{definition}{\savenotes}
  \AfterEndEnvironment{definition}{\spewnotes}
  \BeforeBeginEnvironment{exercise}{\savenotes}
  \AfterEndEnvironment{exercise}{\spewnotes}
  \BeforeBeginEnvironment{proof}{\savenotes}
  \AfterEndEnvironment{proof}{\spewnotes}
  \BeforeBeginEnvironment{solution}{\savenotes}
  \AfterEndEnvironment{solution}{\spewnotes}
  \BeforeBeginEnvironment{question}{\savenotes}
  \AfterEndEnvironment{question}{\spewnotes}
  \BeforeBeginEnvironment{code}{\savenotes}
  \AfterEndEnvironment{code}{\spewnotes}
  \BeforeBeginEnvironment{algo}{\savenotes}
  \AfterEndEnvironment{algo}{\spewnotes}

  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \definecolor{darkblue}{rgb}{0,0,139}
  \definecolor{lightgray}{gray}{0.93}
  \renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$\textcolor{blue}{#1}}

  % default options for listings (for code)
  \lstset{
    autogobble,
    frame=ltbr,
    language=Python,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=fullflexible,
    keepspaces=true,
    basicstyle={\small\ttfamily},
    numbers=left,
    firstnumber=1,                        % start line number at 1
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{lightgray}, 
    breaklines=true,                      % break lines
    breakatwhitespace=true,
    tabsize=3, 
    xleftmargin=2em, 
    framexleftmargin=1.5em, 
    stepnumber=1
  }

% Page style
  \pagestyle{fancy}
  \fancyhead[L]{Python}
  \fancyhead[C]{Muchang Bahng}
  \fancyhead[R]{Fall 2024} 
  \fancyfoot[C]{\thepage / \pageref{LastPage}}
  \renewcommand{\footrulewidth}{0.4pt}          % the footer line should be 0.4pt wide
  \renewcommand{\thispagestyle}[1]{}  % needed to include headers in title page

\begin{document}

\title{Python}
\author{Muchang Bahng}
\date{Fall 2024}

\maketitle
\tableofcontents
\pagebreak

A course on intermediate Python that developers should be aware of. These aren't specifically in order. 

\section{Names and Values}

    There are a lot of parallel characteristics between python variable assignment and C++ pointers. When we assign a variable to an object in python, what we are doing under the hood is creating the value/object in the heap memory (hence we use \texttt{malloc} rather than initializing on the stack) and initializing a pointer to point to that place in memory. 

    The left hand side is called a \textbf{name}, or a \textbf{variable}, and the right hand side is called the \textbf{value}. We say \textit{the name references, is assigned, or is bound to the value}. In fact, this name is really just a pointer to the memory location of where the value is stored, and we can access this using the built-in \texttt{id} function. 

    \begin{figure}[H]
      \centering 
      \begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          # Python 
          x = 4
          print(x) # 4
          print(id(x)) # 4382741696
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          # C  
          int* x_ = malloc(sizeof(int)); 
          *x_ = 4; 
          int** x = &x_; 
          printf("%d\n", **x); // 4
          printf("%p\n", *x);  // 0x600003ff4000
        \end{lstlisting}
      \end{minipage}
      \caption{Referencing an int variable in Python and C. I realize that this isn't completely equivalent since the C code uses a pointer to a pointer, but it helps explain other things a bit easier so bear with me. } 
      \label{fig:int}
    \end{figure}

    \begin{figure}[H]
      \centering 
      \begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          # Python 
          y = [1, 2, 3]
          print(y)        # [1, 2, 3]
          print(id(y))    # 4314417472
          .
          .
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          # C  
          int* x_ = malloc(sizeof(int) * 3); 
          x_[0] = 1; x_[1] = 2; x_[2] = 3; 
          int** x = &x_; 
          for (int i = 0; i < 3; ++i) {
            printf("%d ", *(*x+i)); // 1 2 3
          }
          printf("\n%p", *x);  // 0x6000011cc040
        \end{lstlisting}
      \end{minipage}
      \caption{Referencing a list in Python and C.} 
      \label{fig:list}
    \end{figure}

  \subsection{Mutating vs Rebinding}

    So far so good. But what if we wanted to change \texttt{x} or \texttt{y}? This is where we have to be careful about when defining \textit{change}. 
    \begin{enumerate}
      \item We can change by taking the value that the name references/points to and \textit{mutate} it. Types of values where we can do this are called \textit{mutable types}, which have methods that allow this change (e.g. \texttt{\_\_setitem\_\_} or \texttt{append} for lists). In this case, the memory address it points to should stay the same. 
      \item We can change by creating a new value/object and changing the name to point to this new object. If no other variables points to the original object, then the memory is automatically freed. This is how \textit{immutable types} are changed, and the memory address it points to should be different. What immutable really means is that you cannot change the value that the pointer is pointing to without changing the actual memory location. 
    \end{enumerate}

    So which one is it that Python does? The answer is: it depends.\footnote{For more information, look at \href{https://nedbatchelder.com/text/names.html}{https://nedbatchelder.com/text/names.html}.} 

    \begin{example}[Pass By Reference vs By Value]
      There are two ways a programmer can interpret the following iconic example.
      \begin{lstlisting}
        x = 4 
        y = x 
        print(x, y) # obviously prints 4, 4
        y = 5
        print(x, y) # what about this? 
      \end{lstlisting}

      \begin{enumerate}
        \item \textit{Passing By Reference}. The first interpretation is that by setting \texttt{y = 5}, we are modifying the value that \texttt{y} points to be \texttt{5}. Since the pointer \texttt{x} also points to the same memory address pointed by \texttt{y}, then \texttt{x} also should equal \texttt{5}. 
        \item \textit{Passing By Value}. By setting \texttt{y = 5}, we create a new \texttt{int} object, reassign the pointer \texttt{y} to the new object. Therefore \texttt{x} still points to \texttt{4} and \texttt{y} now points to \texttt{5}. 
      \end{enumerate}
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // Pass by Reference
          int* x_ = malloc(sizeof(int)); 
          *x_ = 4; 
          int** x = &x_; 
          int** y = &x_; 
          printf("%d, %d\n", **x, **y); // 4, 4

          **y = 5; 
          printf("%d, %d\n", **x, **y); // 5, 5
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // Pass by Value
          int* x_ = malloc(sizeof(int)); 
          *x_ = 4; 
          int** x = &x_; 
          int** y = &x_; 
          printf("%d, %d\n", **x, **y); // 4, 4

          int *y_ = malloc(sizeof(int)); 
          *y_ = 5; 
          y = &y_; 
          printf("%d, %d\n", **x, **y); // 4, 5
        \end{lstlisting}
      \end{minipage}

      Though Python does not technically use references vs values, this analogy is helpful to think about.  
    \end{example}

    Seeing as how an integer is immutable and a list is mutable, let's look at how it affects them. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = 4 
      print(x, id(x)) # 4 4374664384
      x = x + 1
      print(x, id(x)) # 5 4374664416
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      y = [1, 2]
      print(y, id(y))  # [1, 2] 4340042048
      y.append(3)
      print(y, id(y)) # [1, 2, 3] 4340042048
    \end{lstlisting}
    \end{minipage}

    As we see, we rebind for immutable types, which changes the pointing memory address, and mutate for mutable types, which doesn't change the address. Therefore, if an object is mutable, then we can mutate it. 

    \begin{example}[Warning]
      This is very subtle and implementation specific. For immutable types, we are pretty much guaranteed rebinding, but for mutable types, we may not be so sure.  
      \begin{enumerate}
        \item If we instantiate two lists and concatenate them using \texttt{+} into a list with a new name, we call the \texttt{\_\_add\_\_} method, which creates a new list object and binds it to that new list.  
        \begin{lstlisting}
          y = [1, 2]
          z = [3]
          print(y, id(y))  # [1, 2] 4380248384
          print(z, id(z))  # [3] 4380250176
          a = z + y
          print(a, id(a))  # [1, 2, 3] 4380551424

          a[1] = 4
          print(a) # [3, 4, 2]
          print(y) # [1, 2]
          print(z) # [3]
        \end{lstlisting}

        \item If we instantiate two lists and extend them using \texttt{+=}, then we call the \texttt{\_\_extend\_\_} method, which extends \texttt{z} with a copy of \texttt{y}. Note that \texttt{z[1:]} and \texttt{y} are two different lists objects in memory, not the same reference. 
        \begin{lstlisting}
          y = [1, 2]
          z = [3]
          print(y, id(y))  # [1, 2] 4380248384
          print(z, id(z))  # [3] 4380250176
          z += y
          print(z, id(z))  # [3, 1, 2] 4380250176

          z[2] = 9
          print(y) # [1, 2]
          print(z) # [3, 1, 9]
        \end{lstlisting}

        \item Just to see an example of an immutable type, even using the \texttt{iadd} method does not keep its original memory address. The entire thing is always allocated to new memory. 
          \begin{lstlisting}
            x = "Hello " 
            print(id(x)) # 4382416384
            print(x)     # Hello
            x += "World"
            print(id(x)) # 4382723056
            print(x)     # Hello World
          \end{lstlisting}
      \end{enumerate}
    \end{example}

    This explains a lot of the weird phenomena, and it is extremely important to know whether a variable is copied by reference or by value, since you'll be able to predict the behavior on one variable if you modify the other one. The common immutable types in Python are string, int, float.


    \begin{example}
      To drive the point home, take a look at this. T

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          # Pass by value
          x = 4 
          y = x
          # Points to same address
          print(id(x)) # 4382741696 
          print(id(y)) # 4382741696 
          x += 1 
          # Now it doesn't
          print(x)    # 5
          print(y)    # 4
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          # Pass by reference
          x = [] 
          y = x
          # Points to same address 
          print(id(x)) # 4383459648
          print(id(y)) # 4383459648
          x.append(1) 
          # Still points to same address
          print(x)     # [1]
          print(y)     # [1]
        \end{lstlisting}
      \end{minipage}
    \end{example}

    \begin{example}[Common Traps]
      To initialize a list of zeros, we can just do 
      \begin{lstlisting}
        >>> x = [0] * 5
        >>> x[0] = 1
        >>> x
        [1, 0, 0, 0, 0] 
      \end{lstlisting}
      This is all good since primitive types are immutable, so modifying one really just rebinds it to another value and doesn't affect the others. However, if we are initializing a list of lists, then we get something different. 
      \begin{lstlisting}
        >>> x = [[]] * 5
        >>> print(x)
        [[], [], [], [], []]
        >>> x[0].append(1)
        >>> x
        [[1], [1], [1], [1], [1]] 
      \end{lstlisting}
      This is because we are instantiating 5 names that all point to the same empty list. Modifying one really is an act of mutating, leading to the changes persisting across all names. This is because the inner list is multiplied and therefore copied \textit{by reference}. This means that all the lists are simply pointing to the same object in memory, and modifying one modifies all.  
    \end{example}

  \subsection{Assignments are Everywhere}

    Let's look at a few more examples where assignment are, starting with enhanced for loops. 

    \begin{theorem}[Assignments in Enhanced For Loops]
      Enhanced for loops of form \texttt{for elem in x} is really an assignment of \texttt{elem} to each element of \texttt{x}. All of the following are assignments. 
      \begin{lstlisting}
        for elem in ... 
        [... for elem in ...]
        (... for elem in ...)
        {... for elem in ...}
      \end{lstlisting}
    \end{theorem}

    Take a look at this anomaly. 
    \begin{lstlisting}
      x = [1, 2, 3] 
      for elem in x: 
          elem += 1 
      print(x) # [1, 2, 3]
    \end{lstlisting}
    With the above theorem, the problem is clear. In the first iteration, we have \texttt{elem = 1} and \texttt{x[0] = 1}. \texttt{elem} has been incremented with \texttt{iadd} and therefore is rebound to \texttt{2}, but this does not affect \texttt{x[0]}, leading to no changes. Note that if the elements were mutable, then we can make these changes persist. 
    \begin{lstlisting}
      x = [[1], [2], [3]]
      for elem in x: 
          elem[0] += 1 
      print(x) # [[2], [3], [4]]
    \end{lstlisting}
    In here, \texttt{elem} and \texttt{x[0]} are bound to \texttt{[1]} and have the same memory address. I then access the memory address of the first element of \texttt{elem} and rebind it to its increment. While the \texttt{1} changes to a \texttt{2}, and \texttt{elem[0]} points to a different memory address, the memory address of \texttt{elem[0]} itself does not change! Therefore, we have effectively changed the value of the element and have basically mutated the array using the \texttt{setitem} dunder method. 
    
    This also persists in functions as well. 

    \begin{theorem}[Assignments in Functions]
      Arguments in functions are also assigned, in local scope of course.  
    \end{theorem}

    Compare these two snippets. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      def augment_twice(a_list, val):
        a_list.append(val)
        a_list.append(val)

      nums = [1, 2, 3]
      augment_twice(nums, 4)
      print(nums)         # [1, 2, 3, 4, 4]
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      def augment_twice_bad(a_list, val):
        a_list = a_list + [val, val]

      nums = [1, 2, 3]
      augment_twice_bad(nums, 4)
      print(nums)         # [1, 2, 3]
      .
    \end{lstlisting}
    \end{minipage}
 
    \begin{enumerate}
      \item In the LHS, \textbf{nums} is bound to \texttt{[1, 2, 3]}. In the function scope, \texttt{a\_list} is also bound to the same list. We augment \texttt{4} twice, which mutates the object, and upon returning, the name \texttt{a\_list} is removed. However, the changes persist and is seen by \texttt{nums}. 
      \item In the RHS, \texttt{nums} is also bound to \texttt{[1, 2, 3]}. In the function, \texttt{a\_list} is being rebound since we use the \texttt{add} method, effectively creating a new list in memory. Now the two variables point to different objects with different memory addresses, and when the function returns, the new list is deleted. Note that this could be avoided if we use the \texttt{iadd} dunder method, which leads to the memory address being preserved. 
    \end{enumerate}

  \subsection{Object Caching}

    In general, if we initialize two variables to be the same value, they do not point to the same memory address. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      # Example of when two variables are 
      # initialized to be the same value, but 
      # do not point to the same memory
      x = 1000
      y = 1000
      print(id(x)) # 4385025360
      print(id(y)) # 4385026288 
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      int* x_ = malloc(sizeof(int)); 
      *x_ = 1000; 
      int** x = &x_; 

      int* y_ = malloc(sizeof(int)); 
      *y_ = 1000; 
      int** y = &y_; 

      printf("%p\n", *x); 0x600001be8040 
      printf("%p\n", *y); 0x600001be8050 
    \end{lstlisting}
    \end{minipage}

    However, we can initialize \texttt{y} to be equal to \texttt{x}, which tells it to point to the same memory address as \texttt{x} is, thus having the same \texttt{id}. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = 1000 
      y = x 
      print(id(x)) # 4303203888 
      print(id(y)) # 4303203888 
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      int* x_ = malloc(sizeof(int)); 
      *x_ = 1000; 
      int** x = &x_; 

      int** y = &x_; 

      printf("%p\n", *x); 0x600002368040 
      printf("%p\n", *y); 0x600002368040 
    \end{lstlisting}
    \end{minipage}

    This does not change for mutable types either. 
    \begin{lstlisting}
      x = [] 
      print(id(x)) # 4378741056
      x = [] 
      print(id(x)) # 4378742848
    \end{lstlisting}

    Usually, just setting the values equal does not have it point to the same memory address, but for integers \texttt{[-5, 256]}, Python caches these numbers so that even if we initialize two numbers with the same integer value, they will always point to the same address. 

    \begin{lstlisting}
      # Don't need to set y = x
      x = 200 
      y = 200 
      print(id(x)) # 4314934592 
      print(id(y)) # 4314934592
    \end{lstlisting}

    This is a CPython-specific fact that you should be aware of. 

  \subsection{Default Arguments are Evaluated when Function is Defined}

    We are used to writing functions with default arguments. An important implementation detail is that default arguments are evaluated when a function is \textit{defined}, not when it is called. Consider the following buggy example. 

    \begin{lstlisting}
      def stuff(x = []): 
          x.append(3)
          print(x)

      stuff() # [3]
      stuff() # [3, 3]
    \end{lstlisting}

    There are two unexpected errors with this: 
    \begin{enumerate}
      \item We would expect the second call to \texttt{stuff} to print \texttt{[3]}. 
      \item The list that \texttt{x} references to should be garbage collected (more on this later) when the name has been deleted after the function returned, but it did not. 
    \end{enumerate}

    We will address this first problem. It turns out that the default argument \texttt{[]} is created in memory and every call with the default argument assigns \texttt{x} to this same list object in the same address. That is, no new lists are created. 

    This is of course not a problem if default arguments are immutable types likes integers. Even though the default argument is bound to the same object in memory for all calls, the value cannot be modified since you can only rebind it to another object, so it will not contaminate other calls. 

\section{Function Closures and Variable Scopes}

  Therefore, this can lead to buggy behavior when using mutable types where it may be passed by reference. 

  Nonlocal and global keywords. 

\section{Lists}

  Lists are implemented as an array of pointers, which can point to any object in memory which is why Python lists can be dynamically allocated. We should be familiar with the general operations we can do with a list, which are implemented as dunder methods. 

  \begin{definition}[Length]
    The \texttt{list.\_\_len\_\_()} method returns the length of a list, which is stored as metadata and is thus $O(1)$ retrieval time. It is invoked by \texttt{len(list) <-> list.\_\_len\_\_()}. 
  \end{definition}

  \begin{definition}[Set Item, Get Item, Del Item]
    The following three methods are getter, setter, and delete functions on the \texttt{list[T]} array given the index. 
    \begin{enumerate}
      \item The \texttt{\_\_getitem\_\_(i) -> T} returns the value of the index of the list. Since we can do pointer arithmetic on the array, which is again just 8 byte pointers, we essentially have $O(1)$ retrieval time. It is invoked by \texttt{list[i] <-> list.\_\_getitem\_\_(i)}. 
      \item The \texttt{\_\_setitem\_\_(i, val) -> None} returns \texttt{None} and sets the value of the index. It is invoked by \texttt{list[i] = val <-> list.\_\_setitem\_\_(i, val)}. 
      \item The \texttt{\_\_delitem\_\_(i) -> None} deletes the value at that index. It is invoked by \texttt{del list[i] <-> list.\_\_delitem\_\_(i)}. 
    \end{enumerate}
  \end{definition}

  The next few definitions are not dunder methods, but are important. 
  \begin{definition}[Append, Insert, Pop]
    \texttt{List.append(val)} is amortized $O(1)$ but is quite slow if we are inserting into the middle with \texttt{List.insert(i, val)}. 
    \texttt{List.pop()} is great for removing from the back of the list, with $O(1)$, but not so great for removing from the front, where all the elements have to be shifted $O(n)$. 
    Dynamically resizing the array, where all the elements of the previous array gets copied over to a larger array, is slightly different. For example, in an old implementation of Python, the new size is implemented to be \texttt{new\_size + new\_size >> 3 + (new\_size < 9 ? 3 : 6)}, which approximately doubles the size (like Java, which exactly doubles the list size), giving us amortized $O(1)$. 
  \end{definition}

  \begin{definition}[Extend]
    
  \end{definition}

  \begin{definition}[Sort]
    
  \end{definition}

  List slicing is quite slow since we are copying the references to every element in the list. Note that the values are not copied themselves, but we are creating an array of new pointers. 

  Slicing can be done past last index. Slicing creates a copy of the sublist. 

  \subsection{Queues}

    A \texttt{collections.deque} (double ended queue) is implemented as a doubly linked list. 

\section{Hash Maps}

    In general, a hashmap can be implemented in the following ways. We take an object and hash its \textit{value}, giving us another memory address. This intuitively implies that this object is immutable, since changing the object will lead to a different memory address. A convenient way to bypass this is to convert lists into tuples.\footnote{However, there are languages where you can hash mutable objects. Again, this is an implementation detail.} The hash function may map two different values to the same memory address, so we can deal with collisions in different ways.\footnote{Good visuals here: \href{https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/}{https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/}.}

    \begin{enumerate}
      \item \textit{Linked List}. The hashed address actually is a linked list, and every time we add to it we append to the linked list. 
      \item \textit{Probing}. If we have two objects $x_1$ and $x_2$ which both map to the same $y = h(x_1) = h(x_2)$, then we can predefine another function $f$ that will act on $h(x_2)$ when it sees that $h(x_1)$ is already occupied, effectively mapping it to $f(h(x_2))$. Two common ones is $f(x) = x + 1$, which maps it to the next address, called \textit{linear probing}, or we can scale it in different ways, e.g. \textit{quadratic probing}. 
      \item \textit{Double Hashing, Open Addressing}. We can hash the hash differently, effectively doing $(h_1(x) + i \cdot h_2(x)) \mathrm{mod} S$, and keep incrementing $i$ from $0$ to whenever it sees a new spot. 
    \end{enumerate}

    \begin{definition}[Python Dictionaries]
      Python does indeed implement dictionaries as hash maps/tables and uses open addressing to handle collisions, meaning that it can only store one and only one entry. Python's hash table is also a contiguous block of memory, so you can actually do $O(1)$ lookup by index as well, though the indices aren't stored. 

      \begin{figure}[H]
        \centering 
        \begin{lstlisting}
          -+-----------------+
          0| <hash|key|value>|
          -+-----------------+
          1|      ...        |
          -+-----------------+
          .|      ...        |
          -+-----------------+
          i|      ...        |
          -+-----------------+
          .|      ...        |
          -+-----------------+
          n|      ...        |
          -+-----------------+ 
        \end{lstlisting}
        \caption{Logical model of Python Hash table. It consists of the keys, the hash of the keys, and the values that are stored in the hashed memory address. The indices are shown on the left, but they are not stored along with the table. }
        \label{fig:hash_table}
      \end{figure}

      When a new dict is initialized, it starts with 8 slots. 
      \begin{enumerate}
        \item When adding entries to the table, we take the key $k$, hash it to $h$, and we do an additional mask operation \texttt{i = mask(key) \& mask}, where \texttt{mask = PyDictMINSIZE - 1} (in CPython). 
        \item If the slot is empty, the entry is added to the slot. If the slot is occupied, CPython (and PyPy) compares the hash and the key (with \texttt{==}, not \texttt{is}) of the entry in the slot against what we are inserting. If \textit{both} match, it thinks the entry already exists and uses open addressing to move onto the next entry. 
        \item The dict will be resized if it is 2/3 full to avoid slowing down lookups. 
      \end{enumerate}
    \end{definition}

    It is well known that the keys and hash tables are not guaranteed to be in sorted order, and this is true in general. However, in Python it is different. 

    \begin{theorem}
      From Python 3.7+ (for all implementations) and CPython 3.6+, dicts preserve insertion order, so calling \texttt{dict.keys()} will return keys in insertion order
    \end{theorem}

    \begin{example}[Back to References]
      As a review, when we iterate over a dict with an enhanced for loop, we are just calling \texttt{next} on the keys or values that may be a copy by value or a copy by reference. 

      \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        # y is copied by value so incrementing 
        # it rebinds it
        >>> x = {"a" : 1, "b" : 2, "c" : 3}
        >>> for k in x: 
        ...     y = x[k]
        ...     y += 1
        ... 
        >>> x
        {'a': 1, 'b': 2, 'c': 3} 
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        # v is passed by value, so incrementing 
        # it rebinds it
        >>> x = {"a" : 1, "b" : 2, "c" : 3}
        >>> for v in x.values(): 
        ...     v += 1
        ... 
        >>> x
        {'a': 1, 'b': 2, 'c': 3} 
        .
      \end{lstlisting}
      \end{minipage}
    \end{example}

  \subsection{Dict Class}

    We should also be familiar with some of the dunder methods. 

    \begin{definition}[Get]
      There are two ways to access from a dictionary. 
      \begin{enumerate}
        \item \texttt{dict[key]} retrieves the value and throws a \texttt{KeyNotFoundError} if a key does not exist. 
        \item \texttt{dict.get(key, def)} retrieves the value and will return \texttt{def} if the key does not exist. 
      \end{enumerate}
    \end{definition}
    
    \begin{definition}[Items]
      Given a dictionary \texttt{dict}, we can run \texttt{dict.items()} to get a \textit{view} of the dictionary. Since this is a view, it does not copy the entire dictionary, and is presented as a list of tuples. However, this is not an iterator either. T 
    \end{definition}

  \subsection{Dict-Like Data Structures}
  
    Let's look through the different dict-like data structures. 

    \begin{definition}[Defaultdict]
      A nice trick is to initialize a \texttt{collections.defaultdict}, which is a subclass of \texttt{Dict} that allows you to use \texttt{dict[key]} and automatically initializes the value to some default value if the key does not exist. It is initialized in the following ways. 
      \begin{enumerate}
        \item \texttt{defaultdict(int)} 
        \item \texttt{defaultdict(dict: Dict)} 
        \item \texttt{defaultdict(log: Function, dict)} runs the function \texttt{log} every time a new key is added. 
      \end{enumerate}
    \end{definition}

    \begin{definition}[Counter]
      \texttt{collections.Counter} is good for finding the count of elements and does not require you to initialize the count to $0$ before incrementing it. 

      \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        data = [1, 1, 2, 3] 
        counter = {} 
        for d in data: 
            if d not in counter: 
                counter[d] = 0 
            counter[d] += 1
        {1: 2, 2: 1, 3: 1}
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        from collections import Counter
        data = [1, 1, 2, 3] 
        counter = Counter() 
        for d in data: 
            counter[d] += 1 
        Counter({1: 2, 2: 1, 3: 1})
        .
      \end{lstlisting}
      \end{minipage}
    \end{definition}

  \subsection{Extending Dictionaries}

\section{Additional Built-In Data Structures}

  \subsection{Heaps} 

\section{Iterators and Loops}

  Iterables, Iterators, Generators, zipping, range vs xrange. Range is an iterable, not iterator. 

  For loops and while loops are straightforward enough, but it's important to know the difference between them. 

  \subsection{Dynamic Evaluation of Condition During Loop}

    In while loops, the condition is rechecked and thus any functions called during this is recomputed at each loop, and so when deleting things from a list, the loop already accounts for the new length. However, a for loop evaluates the length of the list only once and leads to index violation errors.  

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = [1, 2, 3, 4]
      print(x)
      i = 0
      while i < len(x): 
          print(len(x))
          if x[i] == 2: 
              del x[i]
          i += 1
      print(x)

      [1, 2, 3, 4]
      4
      4
      3
      [1, 3, 4]
      
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      x = [1, 2, 3, 4]
      print(x) 

      for i in range(len(x)):
          print(i, x[i])
          if x[i] == 2: 
              del x[i]
      print(x)

      [1, 2, 3, 4]
      0 1
      1 2
      2 4
      IndexError: list index out of range
      .
    \end{lstlisting}
    \end{minipage}

    This can also be a problem when evaluating to a list where you may need to append more elements to it. Here we use the previous initial list. We want to append 5 and 6 since 2 and 4 are even, but the extra 6 added will require us to add 7 as well.   In a for loop, this also breaks down. The for loop only accounts up to the length of the original list, which will end with 6 as the last element added. Whether you want the condition to by dynamically evaluated at every loop depends on the problem. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = [1, 2, 3, 4] 
      print(x)

      i = 0 
      while i < len(x): 
          print(x[i])
          if x[i] % 2 == 0: 
              x.append(max(x) + 1) 
          i += 1

      print(x)

      [1, 2, 3, 4]
      [1, 2, 3, 4, 5, 6, 7] 
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      x = [1, 2, 3, 4]
      print(x)

      for i in range(len(x)): 
          if x[i] % 2 == 0: 
              x.append(max(x) + 1) 

      print(x)

      [1, 2, 3, 4]
      [1, 2, 3, 4, 5, 6]
      .
      .
      .
    \end{lstlisting}
    \end{minipage}

  \subsection{Iterators and Enhanced For Loops}

    A list is an example of an \textit{iterable} object. An \texttt{Iterable} class implements an \texttt{\_\_iter\_\_()} method that transforms it into an \texttt{Iterator} object. An \texttt{Iterator} objects allows one to generate some value every time a \texttt{\_\_next\_\_()} method is called. It should implement the next function and an \texttt{\_\_iter\_\_()} method also, which just returns itself. Here is an example for a list. 

    \begin{lstlisting}
      class Iterator: 

        def __init__(self, input: list): 
          self.index = 0 
          self.input = input
          self.limit = len(input)

        def __iter__(self): 
          return self

        def __next__(self): 
          if self.index > self.limit: 
            raise StopIteration
          self.index += 1 
          return self.input[self.index]
    \end{lstlisting}

    So far, we have talked about looping through a list by looking at the indices. Another way is to to use an \textit{enhanced for loop} to iterate directly over the values. When we use an enhanced for loop, we are really just creating an iterator object around the list and doing a while loop. Therefore, a for loop is really just a while loop!  

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = [1, 2, 3, 4] 
      for elem in x: 
          print(elem)
      .
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      x = [1, 2, 3, 4] 
      x_ = iter(x) 
      while True: 
        try: 
          item = next(x_)
        except StopIteration: 
          break 
        print(item)
    \end{lstlisting}
    \end{minipage}

    This means that every for loop is really just a while loop. For loops were created early on in programming for convenience. Even when doing for loops over indexes, the \texttt{range} is really an iterable, and so you can convert it into an iterator and do the same thing. 

    Another fact about \texttt{range} is that it is \textit{lazy}, meaning that to save memory, calling \texttt{range(100)} does not generate a list of 100 elements. The iterator really evaluates the next number on demand, which adds runtime overhead but saves memory.   

    \begin{example}[Common Trap]
      Look at the following code 
      \begin{lstlisting}
        >>> x = [1, 2, 3, 4]
        >>> for elem in x: 
        ...     elem += 1 
        ... 
        >>> x
        [1, 2, 3, 4] 
      \end{lstlisting}
      This is clearly not our intended behavior. This is because in the backend, the \texttt{elem} is really being returned by calling \texttt{next()} on the iterator object. The type being returned is an \texttt{int}, a primitive type, and therefore it is passed \textit{by value}. Even though \texttt{elem} and \texttt{x[i]} points to the same memory address, once we reassign \texttt{elem += 1}, elem just gets reassigned to another number, which does not affect \texttt{x[i]}. Note that this does not work as well since \texttt{elem} is just being copied by value and not by reference, and again further changes to \texttt{elem} will decouple it from \texttt{x[i]}. 
      \begin{lstlisting}
        >>> x = [1, 2, 3, 4] 
        >>> for i, elem in enumerate(x): 
        ...     elem = x[i]
        ...     elem += 1
        ... 
        >>> x
        [1, 2, 3, 4] 
      \end{lstlisting}
      To actually fix this behavior, we must make sure to call the \texttt{\_\_setitem\_\_(i, val)} method, which can be done as such. 
      \begin{lstlisting}
        >>> x = [1, 2, 3, 4]
        >>> for i in range(len(x)): 
        ...     x[i] += 1 
        ... 
        >>> x
        [2, 3, 4, 5] 
      \end{lstlisting}
      Note that if we had nonprimitive types in the list, then the iterator will copy by reference, and we don't have this problem. 
      \begin{lstlisting}
        >>> x = [[1], [2], [3]]
        >>> for elem in x: 
        ...     elem.append(4)
        ... 
        >>> x
        [[1, 4], [2, 4], [3, 4]] 
      \end{lstlisting}
    \end{example}
 
\section{Item Assignment with Walrus Operator}

  Avoids Repeated Computation

\section{Raising Exceptions}

  Many beginners prefer to return None, but you should really be raising exceptions. 

\section{Positional and Keyword Arguments} 

\section{Decorators}

  Note that in Python, functions are first-class citizens, which means three things: 
  \begin{enumerate}
    \item They can be treated as objects. 
      \begin{lstlisting}
        def shout(text): 
          return text.upper() 

        print(shout('Hello'))  # HELLO 
        yell = shout 
        print(yell('Hello'))   # HELLO
      \end{lstlisting}
    \item They can be passed into another function as an argument. 
      \begin{lstlisting}
        def shout(text): 
          return text.upper() 

        def whisper(text): 
          return text.lower() 

        def greet(func): 
          greeting = func("Hi, How are You.")
          print (greeting) 

        greet(shout)    # HI, HOW ARE YOU.
        greet(whisper)  # hi, how are you. 
      \end{lstlisting}
    \item They can be returned by another function. 
      \begin{lstlisting}
        def create_adder(x): 
          def adder(y): 
            return x+y 

          return adder 

        add_15 = create_adder(15) 
        print(add_15(10)) # 25 
      \end{lstlisting}
  \end{enumerate}

  Say that you have a function \texttt{f} that does something. I want to modify the behavior so that I do something either before of after \texttt{f} is called automatically, but I don't want to manually add code into the function body. What I can do is simply define another function \texttt{wrapper} and call \texttt{f} inside it. 
  \begin{lstlisting}
    def f(): 
        print("Hello world") 

    def wrapper(): 
        print("started") 
        f()
        print("ended") 

    wrapper() # "started\n Hello world\n ended"
  \end{lstlisting}

  Great, we can do this for one function. But what if there were thousands of functions I want to do this for? Rather than creating a wrapper function for each function, I can make a third function called \texttt{decorator} that takes in the original function \texttt{f} and outputs the \texttt{wrapper} function. 

  \begin{lstlisting}
    def decorator(f): 
      def wrapper(): 
        print("started") 
        f()
        print("ended") 

      return wrapper

    def f(): 
      print("Hello world") 

    wrapper = decorator(f)
    wrapper() # "started\n Hello world\n ended"

    decorator(f) # <function decorator.<locals>.wrapper at 0x100b38e00>
    decorator(f)() # "started\n Hello world\n ended"
  \end{lstlisting}

  This way, I can modify any function I want with this behavior, and is known as \textit{function aliasing}. This is essentially what a decorator is. 

  \begin{definition}[Decorators]
    \textbf{Decorators} are used to modify the behavior of your functions without changing its actual code, used with the \texttt{\@} operator. The two are equivalent. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      def decorator(f): 
        def wrapper(): 
          print("started") 
          f()
          print("ended") 

        return wrapper

      def f(): 
        print("Hello world") 

      f = decorator(f)
      f() # "started\n Hello world\n ended"
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      def decorator(f): 
        def wrapper(): 
          print("started") 
          f()
          print("ended") 

        return wrapper

      @decorator
      def f(): 
        print("Hello world") 

      f() # "started\n Hello world\n ended"
    \end{lstlisting}
    \end{minipage}

    This means that every time I call the function \texttt{f}, it really calls the function \texttt{decorator} with \texttt{f} passed into it as an argument. With functions that have arguments, the wrapper function should also have the same arguments. Generically, we can just use the \texttt{\*args} and \texttt{\*\*kwargs} arguments to unpack these variables so that \texttt{wrapper}'s arguments always matches those of \texttt{f}'s arguments, but we can modify these arguments for extra functionality as well. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      # generic args and kwargs
      def decorator(f): 
        def wrapper(*args, **kwargs): 
          print("started") 
          f(*args, **kwargs)
          print("ended") 

        return wrapper

      @decorator
      def f(string): 
        print(string) 

      f("Hello World")
      # started
      # Hello World
      # ended
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      # custom arguments 
      def decorator(f): 
        def wrapper(string, start_msg): 
          print(start_msg) 
          f(string)
          print("ended") 

        return wrapper

      @decorator
      def f(string): 
        print(string) 

      f("Hello World", "time to go")
      # time to go
      # Hello World
      # ended
    \end{lstlisting}
    \end{minipage}
    If we want to get the return values of this function, we can store the return value in temporary variable \texttt{tmp}, run whatever code after the function \texttt{f}, and finally return \texttt{tmp} in \texttt{wrapper}. 

    \begin{lstlisting}
      def decorator(f): 
          def wrapper(*args, **kwargs): 
              print("started") 
              tmp = f(*args, **kwargs)
              print("ended") 
              return tmp

          return wrapper

      @decorator
      def f(string): 
          return string + "!"

      print(f("Hello World"))
      # started
      # ended
      # Hello World!
    \end{lstlisting}
  \end{definition}

  \begin{example}[Measuring Total and CPU Runtime]
    If we want to find the runtime of a function, we can do this easily. 

    \begin{lstlisting}
      import time 

      def runtime(f): 
        def wrapper(*args, **kwargs): 
          start = time.time() 
          product = f(*args, **kwargs) 
          end = time.time() 
          print(f"Took {end - start} s") 
          return product
        return wrapper

      @runtime
      def dot(list1, list2): 
        res = 0 
        for x, y in zip(list1, list2): 
          res += x * y 
        return res

      x = [1, 2, 3]
      y = [2, 2, 3]
      result = dot(x, y)  # Took 3.814697265625e-06 s 
      print(result)       # 15 
    \end{lstlisting}

    However, this is not accurate as the OS will switch between different processes. Therefore, the process time is more accurate. 

    \begin{lstlisting}
      import numpy as np
      import time

      def cpu_usage(f):
        def wrapper(*args, **kwargs):
          start_cpu = time.process_time()
          result = f(*args, **kwargs)
          end_cpu = time.process_time()
          print(f"CPU time: {end_cpu - start_cpu:.6f} seconds")
          return result
        return wrapper

      @cpu_usage
      def matrix_mult(a, b): 
        return np.matmul(a, b)

      x = np.random.randn(2000, 2000)

      matrix_mult(x, x) # CPU time: 0.772730 seconds
    \end{lstlisting}
  \end{example}

  \begin{example}[Memory Usage]
    We can measure memory usage with the \texttt{psutil} library. 
    \begin{lstlisting}
      import numpy as np
      import psutil, os 

      def memory_usage(f):
        def wrapper(*args, **kwargs):
          process = psutil.Process(os.getpid())
          mem_before = process.memory_info().rss
          result = f(*args, **kwargs)
          mem_after = process.memory_info().rss
          print(f"Memory usage: {(mem_after - mem_before) / 1024 / 1024:.2f} MB")
          return result
        return wrapper

      @memory_usage 
      def matrix_mult(a, b): 
        return np.matmul(a, b)

      x = np.random.randn(2000, 2000)
      matrix_mult(x, x) # Memory usage: 46.81 MB
    \end{lstlisting}
  \end{example}

  \begin{example}[Measuring Function Call Count]
    To measure how many times a function has been called, we can use the decorator. 
    \begin{lstlisting}
      def call_counter(f):
          def wrapper(*args, **kwargs):
              wrapper.count += 1
              print(f"Function '{f.__name__}' called {wrapper.count} times")
              return f(*args, **kwargs)
          wrapper.count = 0
          return wrapper

      @call_counter
      def factorial(x): 
          if x == 1: 
              return 1 
          return x * factorial(x - 1)

      result = factorial(7)
      # Function 'factorial' called 1 times
      # Function 'factorial' called 2 times
      # Function 'factorial' called 3 times
      # Function 'factorial' called 4 times
      # Function 'factorial' called 5 times
      # Function 'factorial' called 6 times
      # Function 'factorial' called 7 times
      print(result)       
      # 5040
    \end{lstlisting}
  \end{example}

  functools.wraps. 

\section{Composing Classes}

  If you find yourself nesting built-in types, this is prob an indicator to compose classes. @dataclass.dataclass operator to define simple data structures. 

\section{Web Scraping}

  The relevant packages that must be imported are $\texttt{bs4, urllib.request}$. 

  We first define the URL of the website that we want to scrape. For example, let us take the wikipedia article on the Eastern Front of WWII. 
  \begin{python}
  from bs4 import BeautifulSoup
  from urllib.request import Request, urlopen
  import urllib.request

  #Define the URL we want to scrape
  wiki_url = r"https://en.wikipedia.org/wiki/Eastern_Front_(World_War_II)"
  \end{python}
  Then, we use the $\texttt{request}$ function in $\texttt{urllib.request}$ (which is a library for opening URLs) to make a \textbf{HTTP request} to the website. More information can be found in the HTTP section in this book, but in general once the Python program identifies the IP address of the host computer hosting the requested URL, it sends the HTTP request (usually $\texttt{HTTP/1.1}$). The host computer then sends back an HTTP response with both the content and metadata about it. We usually set this HTTP response as a variable: 
  \begin{python}
  >>>response_object = urllib.request.urlopen(wiki_url)
  >>>print(type(response_object)) 
  >>>print(response_object)
  <class 'http.client.HTTPResponse'>
  <http.client.HTTPResponse object at 0x7fa3382de280>
  \end{python}

  \begin{definition}
  The $\texttt{urlopen}$ function has the following paramaters: 
  \begin{python}
  urllib.request.urlopen(url, data=None, timeout, cafile=None, capath=None, cadefault=False, context=None)
  \end{python}
  \begin{enumerate}
      \item Open the URL $\texttt{url}$, which can either be a string or a $\texttt{Request}$ object. 
      \item $\texttt{data}$ must be an object specifying additional data to be sent to the server, or $\texttt{None}$ if no such data is needed. 
      \item The optional $\texttt{timeout}$ parameter specifies a timeout in seconds for blocking operations like the connection attempt. Default is the global default timeout setting. 
      \item The optional $\texttt{cafile, capath}$ parameters specify a set of trusted CA certificates for HTTPS requests. 
      \item $\texttt{cadefault}$ parameter is ignored. 
      \item $\texttt{context}$ can be set to $\texttt{None}$. 
  \end{enumerate}
  \end{definition}
  With this, HTML request object, we can input it into the $\texttt{BeautifulSoup}$ function of the $\texttt{bs4}$ library, which gives us a $\texttt{BeautifulSoup}$ object that represents the document as a nested data structure (note that this is not a string!). 
  \begin{python}
  soup = BeautifulSoup(response_object, "html.parser")
  print(type(soup))     #<class 'bs4.BeautifulSoup'>
  print(soup)
  #This gives us a nice representation of the HTML as a nested data structure.
  \end{python}
  One may notice the second argument $\texttt{"html.parser"}$; we can leave this alone. HTML parsing is basically taking in HTML code and extracting relevant information like the title of the page, paragraphs in the page, headings in the page, links, bold text, etc. This is really what $\texttt{BeautifulSoup}$ does. 

  To make the returned BeautifulSoup object a bit easier to read, we can use $\texttt{.prettify()}$. 
  \begin{python}
  html_doc = 
  """<html><head><title>The Dormouse's story</title></head>
  <body>
  <p class="title"><b>The Dormouse's story</b></p>
  <p class="story">Once upon a time there were three little sisters; and their names were
  <a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>,
  <a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
  <a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
  and they lived at the bottom of a well.</p>
  <p class="story">...</p>
  """
  soup2 = BeautifulSoup(html_doc, 'html.parser')
  print(soup2.prettify())
  # <html>
  #  <head>
  #   <title>
  #    The Dormouse's story
  #   </title>
  #  </head>
  #  <body>
  #   <p class="title">
  #    <b>
  #     The Dormouse's story
  #    </b>
  #   </p>
  #   <p class="story">
  #    Once upon a time there were three little sisters; and their names were
  #    <a class="sister" href="http://example.com/elsie" id="link1">
  #     Elsie
  #    </a>
  #    ,
  #    <a class="sister" href="http://example.com/lacie" id="link2">
  #     Lacie
  #    </a>
  #    and
  #    <a class="sister" href="http://example.com/tillie" id="link3">
  #     Tillie
  #    </a>
  #    ; and they lived at the bottom of a well.
  #   </p>
  #   <p class="story">
  #    ...
  #   </p>
  #  </body>
  # </html>
  \end{python}

  \begin{definition}[Find method]
  The $\texttt{find}$ method finds the first instance of a HTML element with a certain tag. 
  \begin{python}
      soup = BeautifulSoup(response_object, "html.parser") 
      print(soup.find("a"))
      #<a id="top"></a>
  \end{python}
  We can confirm that this is indeed the first element with tag $\texttt{<a>}$ when looking at the page source in the browser. 
  \begin{enumerate}
      \item If we would like it to have an additional attribute of a $\texttt{href}$ (which means that it has a link attached), then we can just write
      \begin{python}
      link = soup.find("a", href=True)
      print(link)
      #<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
      #Note that this is not a string, even though it looks like a string. 
      print(type(link))     #What is the type? It is a tag.
      #bs4.element.Tag 
      print(link.name)      #What is the name of this tag? 
      #'a'
      \end{python}
      
      \item We can look for other attributes in the $\texttt{<a att1 = ' ' att2 = ' ' >}$ and use them to find the elements with tag $\texttt{tag}$ that have these attributes. 
      \begin{python}
      link = soup.find("tag", att1=True, att2 = "This")
      print(link) 
      \end{python}
      
      \item We can also get the dictionary of all the attributes with the $\texttt{.attrs}$ method. 
      \begin{python}
      print(link.attrs) 
      #{'class': ['mw-jump-link'], 'href': '#mw-head'}
      \end{python}
      
      \item The $\texttt{text}$ attribute returns the text (i.e. the text that is actually shown on the website) of the element with the tag. 
  \end{enumerate}
  \end{definition}

  \begin{definition}[Find\_all method]
  The $\texttt{find\_all}$ method works exactly like the $\texttt{find}$ method, but it displays a $\texttt{ResultSet}$ object (which acts like a list) with all the elements having the required tag and meeting certain attribute requirements. 
      \begin{python}
      links = soup.find_all('a', href=True)
      print(type(links))     #type of this find_all object
      print(len(links))      
      #bs4.element.ResultSet
      #3098                  #This website contains 3098 links! 
      \end{python}
  \begin{enumerate}
      \item We can loop through this $\texttt{ResultSet}$ as if it were a list, but we can't assume that every element of this set is going to have the same attributes. For example, every element has a $\texttt{href}$ attribute (since we built the list that way), but not every element has the $\texttt{title}$ attribute. Therefore, we must use $\texttt{try, except}$. 
      \begin{python}
      for link in links[0:10]:
          print(link['href'])
          try: 
              print(link['title'])
          except:
              continue
      \end{python}
      
      \item We can $\texttt{find\_all}$ elements that have either one of multiple tags by inputting a list rather than a string as the argument: 
      \begin{python}
      #search for tables and a tags
      tables_and_a = soup.find_all(['table', 'a'])
      \end{python}
      
      \item We can add additional arguments to make the attributes more specific: 
      \begin{python}
      #table headers with style attribute
      table_headers = soup.find_all('th', style='width: 10\%;')
      print(table_headers)
      #[<th style="width: 10\%;">Date </th>]
      
      #find all the wiki tables
      wiki_tables = soup.find_all('table', class_='wikitable')
      \end{python}
      Since $\texttt{class}$ is already a keyword in Python, the attribute is $\texttt{class\_}$. 
      
      \item We can $\texttt{find\_all}$ with multiple attributes, by inputting a dictionary. 
      \begin{python}
      #a list of all tags that have a href and a title, and have the class value mw-direct. 
      a_tags_multi = soup.find_all('a', {'href':True, 'title':True, 'class':"mu=redirect"})
      \end{python}
      
      \item We can also define a function to find the items
      \begin{python}
      def list_with_links(tag): 
          return tag.name == 'li' and len(tag.find_all('a'))>7
          
      #list items with a tags a
      list_with_a = soup.find_all(list_with_links)
      \end{python}
  \end{enumerate}
  \end{definition}

  \subsubsection{Family Tree}
  \begin{definition}[Children and Descendants]
  Given a HTML code, a \textbf{child} of a tag is the direct subtag, and the \textbf{descendants} of a tag are all the children and children of those children, etc. 
  \begin{python}
  #define the simple tree
  simple_tree = 
  '''<html><body><a><b>text1</b><c>text2</c></a></body></html>'''

  #pass the simple tree into our parser to create some simple soup. 
  simple_soup = BeautifulSoup(simple_tree, 'html.parser')

  #we can always print it in a familiar structure. 
  print(simple_soup.prettify())

  #<html>
  # <body>
  #  <a>
  #   <b>
  #    text1
  #   </b>
  #   <c>
  #    text2
  #   </c>
  #  </a>
  # </body>
  #</html>
  \end{python}
  If we want just a list of the children we can use the content attribute:
  \begin{python}
  a_content = simple_soup.a.contents  #the 'a' stands for the a tag
  display(a_content)
  [<b>text1</b>, <c>text2</c>]  #this is actually not a list!

  #an identical way to get the list of children is as such:
  print(simple_soup.a.children) #this is a list!
  \end{python}
  All of the descendants of a tag can be gotten as such: 
  \begin{python}
  print(simple_soup.a.descendants)
  [<b>text1</b>, text1, <c>text2</c>, text2]
  \end{python}
  \end{definition}

  \begin{definition}[Parents]
  We can go backwards to get the parent tag: 
  \begin{python}
  #get the parent of the 'a' tag 
  print(simple_soup.a.parent)
  #<body><a><b>text1</b><c>text2</c></a></body>

  #get the parent of the parent of the 'a' tag
  print(simple_soup.a.parent.parent)
  #<html><body><a><b>text1</b><c>text2</c></a></body></html>
  \end{python}
  Now, just like the descendants, we can get all the parents of the 'a' tag. 
  \begin{python}
  for parent in simple_soup.a.parents: 
      print(parent) 
  #<body><a><b>text1</b><c>text2</c></a></body>
  #<html><body><a><b>text1</b><c>text2</c></a></body></html>
  #<html><body><a><b>text1</b><c>text2</c></a></body></html>
  \end{python}
  The first line is the body tag, the second is the html tag, and the final line is the entire document itself. This can also be found with the $\texttt{find\_parent}$ method: 
  \begin{python}
  print(simple_soup.b.find_parent())   #find parent of b tag
  print(simple_soup.b.find_parents())  #find all parents of b tag
  #<a><b>text1</b><c>text2</c></a>
  #[<a><b>text1</b><c>text2</c></a>,
  #<body><a><b>text1</b><c>text2</c></a></body>,
  #<html><body><a><b>text1</b><c>text2</c></a></body></html>,
  #<html><body><a><b>text1</b><c>text2</c></a></body></html>]
  \end{python}
  \end{definition}

  We've learned how to go up or down, but we can do sideways to get a tag's \textbf{siblings}. 

  \begin{definition}
  A tag can have either a sibling after it or before it, denoted by the $\texttt{next\_sibling}$ and $\texttt{previous\_sibling}$ method. 
  \begin{python}
  #print the element with tag b
  print(simple_soup.b)
  #<b>text1</b>

  #print the next sibling (what comes after) of b
  print(simple_soup.b.next_sibling)
  #<c>text2</c>

  #print the previous sibling of b
  print(simple_soup.b.previous_sibling) 
  #None
  \end{python}
  We can see that b has one sibling after it, which is c, but since it is the first element in its generation, there is no previous sibling. This can also be done with the $\texttt{find\_next\_sibling}$ method. 
  \begin{python}
  simple_soup.b.find_next_sibling()      #find the next sibling of b tag
  simple_soup.b.find_next_siblings()     #find all next siblings of b tag 
  simple_soup.b.find_previous_sibling()  #find the previous sibling of b tag
  simple_soup.b.find_previous_siblings() #find all previous siblings of b tag 
  \end{python}
  \end{definition}

  \begin{definition}[Order of Parsing using next\_element]
  The order in which a HTML file was parsed can be determined by the $\texttt{next\_element}$ method. 
  \begin{python}
  #grab the body
  print(simple_soup.body) 
  #<body><a><b>text1</b><c>text2</c></a></body>

  print(simple_soup.body.next_element)
  #<a><b>text1</b><c>text2</c></a>
  \end{python}

  However, the order in which it is parsed does not align always with the sibling order. Therefore, the $\texttt{next\_element}$ and $\texttt{previous\_element}$ method simply refers to the order in which the HTML was parsed, nothing more. This can also be found using the $\texttt{find\_next}$ method. 
  \begin{python}
  simple_soup.a.find_next()        #find the next element of a tag
  simple_soup.a.find_all_next()    #find all next elements of a tag
  simple_soup.a.find_previous()    #find the previous element of a tag
  simple_soup.a.find_all_previous()#find all previous elements of a tag
  \end{python}
  \end{definition}

  \subsubsection{Adding Attributes to Certain Tags}
  Say that you have parsed a HTML file and you have the, say, first a-tag element. We can display its $\texttt{href}$ attribute normally as such: 
  \begin{python}
  a_tag = table.a 
  print(a_tag) 
  #<a href="#cite_note-37">[37]</a>

  print(a_tag['href'])
  # '#cite_note-37'
  \end{python}
  We can also \textit{add our own attribute $\texttt{style}$ to this tag} as such: 
  \begin{python}
  a_tag['style'] = 'my new width'
  print(a_tag)
  #<a href="#cite_note-37" style="my new width">[37]</a>
  \end{python}

  This is extremely useful since it allows us to \textit{tag} certain elements with an attribute for easy identification of these elements for later on when we're analyzing data. 

  We can also \textit{add text/string to the tag}. 
  \begin{python}
  #here we add a new string to the a tag
  a_tag.string = "My New String"
  print(a_tag) 
  #<a href="#cite_note-37" style="my new width">My New String</a>
  \end{python}

  Since we can add values, we also have the capability to delete them. The $\texttt{clear}$ method clear all the string in the tag. 
  \begin{python}
  #grab the first a tag
  tag = table.a
  print(tag)
  #<a href="#cite_note-37" style="my new width">My New String</a>

  tag.clear()
  print(tag)
  #<a href="#cite_note-37" style="my new width"></a>
  \end{python}

  \textit{Note that all the changes that you do to the tags are permanent! You must re-request the HTML and parse through it again to get the original version!}

  \begin{definition}[Extracting a tag]
  Given a certain section of HTML code, we can choose to \textbf{extract} a certain portion of the code that has a specific tag, which basically removes that portion from the original code. We can take this extracted portion and store it as a variable.
  \begin{python}
  #grab a table body
  print(table.tbody)

  #extrac the first table header 
  th_tag = table.tbody.tr.extract()

  #display the extracted tag
  print(th_tag)
  #<th style="width: 10\%;">Date</th>
  \end{python}
  Again, note that every time you extract a portion of the HTML code, you're permanently removing it! After extracting enough times, there won't be any more tags to extract and you'll get an error statement (which is a drawback). 
  \end{definition}

  \begin{definition}
  To get the strings that belong to a certain tag, we do the following: 
  \begin{python}
  #printing the first string that you find in the table header tag
  print(table.th.string)  

  #get all the strings that belong to a table body
  for string in list(table.tbody.strings)[0:10]: 
      print(string)
  \end{python}
  We have to convert $\texttt{table.tbody.strings}$ to a list in order to slice it (since we only want to show the first 10 strings). 

  However, this will produce a lot of line breaks, so the more popular one to go to is the $\texttt{stripped\_strings}$ method. 
  \begin{python}
  for string in list(table.tbody.stripped_strings)[0:10]: 
      print(string)
  \end{python}
  \end{definition}


\end{document}

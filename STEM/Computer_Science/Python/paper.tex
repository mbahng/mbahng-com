\documentclass{article}

% packages
  % basic stuff for rendering math
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath} 
  \usepackage{amssymb}
  % \usepackage{amsthm}

  % extra math symbols and utilities
  \usepackage{mathtools}        % for extra stuff like \coloneqq
  \usepackage{mathrsfs}         % for extra stuff like \mathsrc{}
  \usepackage{centernot}        % for the centernot arrow 
  \usepackage{bm}               % for better boldsymbol/mathbf 
  \usepackage{enumitem}         % better control over enumerate, itemize
  \usepackage{hyperref}         % for hypertext linking
  \usepackage{fancyvrb}          % for better verbatim environments
  \usepackage{newverbs}         % for texttt{}
  \usepackage{xcolor}           % for colored text 
  \usepackage{listings}         % to include code
  \usepackage{lstautogobble}    % helper package for code
  \usepackage{parcolumns}       % for side by side columns for two column code
  

  % page layout
  \usepackage{fancyhdr}         % for headers and footers 
  \usepackage{lastpage}         % to include last page number in footer 
  \usepackage{parskip}          % for no indentation and space between paragraphs    
  \usepackage[T1]{fontenc}      % to include \textbackslash
  \usepackage{footnote}
  \usepackage{etoolbox}

  % for custom environments
  \usepackage{tcolorbox}        % for better colored boxes in custom environments
  \tcbuselibrary{breakable}     % to allow tcolorboxes to break across pages

  % figures
  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{float}            % for [H] figure placement
  \usepackage{tikz}
  \usepackage{tikz-cd}
  \usepackage{circuitikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usepackage{graphicx}
  \usepackage{algorithmic}
  \usepackage{caption} 
  \usepackage{subcaption}
  \captionsetup{font=small}

  % for tabular stuff 
  \usepackage{dcolumn}

  \usepackage[nottoc]{tocbibind}
  \pdfsuppresswarningpagegroup=1
  \hfuzz=5.002pt                % ignore overfull hbox badness warnings below this limit

% New and replaced operators
  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator{\pos}{pos}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\braket}[2]{\langle #1 | #2 \rangle}
  \newcommand{\qed}{\hfill$\blacksquare$}     % I like QED squares to be black

% Custom Environments
  \newtcolorbox[auto counter, number within=section]{question}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Question \thetcbcounter ~(#1)}
  }

  \newtcolorbox[auto counter, number within=section]{exercise}[1][]
  {
    colframe = teal!25,
    colback  = teal!10,
    coltitle = teal!20!black,  
    breakable, 
    title = \textbf{Exercise \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{solution}[1][]
  {
    colframe = violet!25,
    colback  = violet!10,
    coltitle = violet!20!black,  
    breakable, 
    title = \textbf{Solution \thetcbcounter}
  }
  \newtcolorbox[auto counter, number within=section]{lemma}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Lemma \thetcbcounter ~(#1)}
  }
  \newtcolorbox[auto counter, number within=section]{theorem}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Theorem \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proposition}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Proposition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{corollary}[1][]
  {
    colframe = red!25,
    colback  = red!10,
    coltitle = red!20!black,  
    breakable, 
    title = \textbf{Corollary \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{proof}[1][]
  {
    colframe = orange!25,
    colback  = orange!10,
    coltitle = orange!20!black,  
    breakable, 
    title = \textbf{Proof. }
  } 
  \newtcolorbox[auto counter, number within=section]{definition}[1][]
  {
    colframe = yellow!25,
    colback  = yellow!10,
    coltitle = yellow!20!black,  
    breakable, 
    title = \textbf{Definition \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{example}[1][]
  {
    colframe = blue!25,
    colback  = blue!10,
    coltitle = blue!20!black,  
    breakable, 
    title = \textbf{Example \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{code}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Code \thetcbcounter ~(#1)}
  } 
  \newtcolorbox[auto counter, number within=section]{algo}[1][]
  {
    colframe = green!25,
    colback  = green!10,
    coltitle = green!20!black,  
    breakable, 
    title = \textbf{Algorithm \thetcbcounter ~(#1)}
  } 

  \BeforeBeginEnvironment{example}{\savenotes}
  \AfterEndEnvironment{example}{\spewnotes}
  \BeforeBeginEnvironment{lemma}{\savenotes}
  \AfterEndEnvironment{lemma}{\spewnotes}
  \BeforeBeginEnvironment{theorem}{\savenotes}
  \AfterEndEnvironment{theorem}{\spewnotes}
  \BeforeBeginEnvironment{corollary}{\savenotes}
  \AfterEndEnvironment{corollary}{\spewnotes}
  \BeforeBeginEnvironment{proposition}{\savenotes}
  \AfterEndEnvironment{proposition}{\spewnotes}
  \BeforeBeginEnvironment{definition}{\savenotes}
  \AfterEndEnvironment{definition}{\spewnotes}
  \BeforeBeginEnvironment{exercise}{\savenotes}
  \AfterEndEnvironment{exercise}{\spewnotes}
  \BeforeBeginEnvironment{proof}{\savenotes}
  \AfterEndEnvironment{proof}{\spewnotes}
  \BeforeBeginEnvironment{solution}{\savenotes}
  \AfterEndEnvironment{solution}{\spewnotes}
  \BeforeBeginEnvironment{question}{\savenotes}
  \AfterEndEnvironment{question}{\spewnotes}
  \BeforeBeginEnvironment{code}{\savenotes}
  \AfterEndEnvironment{code}{\spewnotes}
  \BeforeBeginEnvironment{algo}{\savenotes}
  \AfterEndEnvironment{algo}{\spewnotes}

  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \definecolor{darkblue}{rgb}{0,0,139}
  \definecolor{lightgray}{gray}{0.93}
  \renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$\textcolor{blue}{#1}}

  % default options for listings (for code)
  \lstset{
    autogobble,
    frame=ltbr,
    language=Python,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=fullflexible,
    keepspaces=true,
    basicstyle={\small\ttfamily},
    numbers=left,
    firstnumber=1,                        % start line number at 1
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{lightgray}, 
    breaklines=true,                      % break lines
    breakatwhitespace=true,
    tabsize=3, 
    xleftmargin=2em, 
    framexleftmargin=1.5em, 
    stepnumber=1
  }

% Page style
  \pagestyle{fancy}
  \fancyhead[L]{Python}
  \fancyhead[C]{Muchang Bahng}
  \fancyhead[R]{Fall 2024} 
  \fancyfoot[C]{\thepage / \pageref{LastPage}}
  \renewcommand{\footrulewidth}{0.4pt}          % the footer line should be 0.4pt wide
  \renewcommand{\thispagestyle}[1]{}  % needed to include headers in title page

\begin{document}

\title{Python}
\author{Muchang Bahng}
\date{Fall 2024}

\maketitle
\tableofcontents
\pagebreak

A course on intermediate Python that developers should be aware of. These aren't specifically in order. 

\section{Names and Values}

    There are a lot of parallel characteristics between python variable assignment and C++ pointers. When we assign a variable to an object in python, what we are doing under the hood is creating the value/object in the heap memory (hence we use \texttt{malloc} rather than initializing on the stack) and initializing a pointer to point to that place in memory. 

    The left hand side is called a \textbf{name}, or a \textbf{variable}, and the right hand side is called the \textbf{value}. We say \textit{the name references, is assigned, or is bound to the value}. In fact, this name is really just a pointer to the memory location of where the value is stored, and we can access this using the built-in \texttt{id} function. 

    \begin{figure}[H]
      \centering 
      \begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          # Python 
          x = 4
          print(x) # 4
          print(id(x)) # 4382741696
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          # C  
          int* x_ = malloc(sizeof(int)); 
          *x_ = 4; 
          int** x = &x_; 
          printf("%d\n", **x); // 4
          printf("%p\n", *x);  // 0x600003ff4000
        \end{lstlisting}
      \end{minipage}
      \caption{Referencing an int variable in Python and C. I realize that this isn't completely equivalent since the C code uses a pointer to a pointer, but it helps explain other things a bit easier so bear with me. } 
      \label{fig:int}
    \end{figure}

    \begin{figure}[H]
      \centering 
      \begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          # Python 
          y = [1, 2, 3]
          print(y)        # [1, 2, 3]
          print(id(y))    # 4314417472
          .
          .
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          # C  
          int* x_ = malloc(sizeof(int) * 3); 
          x_[0] = 1; x_[1] = 2; x_[2] = 3; 
          int** x = &x_; 
          for (int i = 0; i < 3; ++i) {
            printf("%d ", *(*x+i)); // 1 2 3
          }
          printf("\n%p", *x);  // 0x6000011cc040
        \end{lstlisting}
      \end{minipage}
      \caption{Referencing a list in Python and C.} 
      \label{fig:list}
    \end{figure}

  \subsection{Mutating vs Rebinding}

    So far so good. But what if we wanted to change \texttt{x} or \texttt{y}? This is where we have to be careful about when defining \textit{change}. 
    \begin{enumerate}
      \item We can change by taking the value that the name references/points to and \textit{mutate} it. Types of values where we can do this are called \textit{mutable types}, which have methods that allow this change (e.g. \texttt{\_\_setitem\_\_} or \texttt{append} for lists). In this case, the memory address it points to should stay the same. 
      \item We can change by creating a new value/object and changing the name to point to this new object. If no other variables points to the original object, then the memory is automatically freed. This is how \textit{immutable types} are changed, and the memory address it points to should be different. What immutable really means is that you cannot change the value that the pointer is pointing to without changing the actual memory location. 
    \end{enumerate}

    So which one is it that Python does? The answer is: it depends.\footnote{For more information, look at \href{https://nedbatchelder.com/text/names.html}{https://nedbatchelder.com/text/names.html}.} 

    \begin{example}[Pass By Reference vs By Value]
      There are two ways a programmer can interpret the following iconic example.
      \begin{lstlisting}
        x = 4 
        y = x 
        print(x, y) # obviously prints 4, 4
        y = 5
        print(x, y) # what about this? 
      \end{lstlisting}

      \begin{enumerate}
        \item \textit{Passing By Reference}. The first interpretation is that by setting \texttt{y = 5}, we are modifying the value that \texttt{y} points to be \texttt{5}. Since the pointer \texttt{x} also points to the same memory address pointed by \texttt{y}, then \texttt{x} also should equal \texttt{5}. 
        \item \textit{Passing By Value}. By setting \texttt{y = 5}, we create a new \texttt{int} object, reassign the pointer \texttt{y} to the new object. Therefore \texttt{x} still points to \texttt{4} and \texttt{y} now points to \texttt{5}. 
      \end{enumerate}
      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          // Pass by Reference
          int* x_ = malloc(sizeof(int)); 
          *x_ = 4; 
          int** x = &x_; 
          int** y = &x_; 
          printf("%d, %d\n", **x, **y); // 4, 4

          **y = 5; 
          printf("%d, %d\n", **x, **y); // 5, 5
          .
          .
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          // Pass by Value
          int* x_ = malloc(sizeof(int)); 
          *x_ = 4; 
          int** x = &x_; 
          int** y = &x_; 
          printf("%d, %d\n", **x, **y); // 4, 4

          int *y_ = malloc(sizeof(int)); 
          *y_ = 5; 
          y = &y_; 
          printf("%d, %d\n", **x, **y); // 4, 5
        \end{lstlisting}
      \end{minipage}

      Though Python does not technically use references vs values, this analogy is helpful to think about.  
    \end{example}

    Seeing as how an integer is immutable and a list is mutable, let's look at how it affects them. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = 4 
      print(x, id(x)) # 4 4374664384
      x = x + 1
      print(x, id(x)) # 5 4374664416
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      y = [1, 2]
      print(y, id(y))  # [1, 2] 4340042048
      y.append(3)
      print(y, id(y)) # [1, 2, 3] 4340042048
    \end{lstlisting}
    \end{minipage}

    As we see, we rebind for immutable types, which changes the pointing memory address, and mutate for mutable types, which doesn't change the address. Therefore, if an object is mutable, then we can mutate it. 

    \begin{example}[Warning]
      This is very subtle and implementation specific. For immutable types, we are pretty much guaranteed rebinding, but for mutable types, we may not be so sure.  
      \begin{enumerate}
        \item If we instantiate two lists and concatenate them using \texttt{+} into a list with a new name, we call the \texttt{\_\_add\_\_} method, which creates a new list object and binds it to that new list.  
        \begin{lstlisting}
          y = [1, 2]
          z = [3]
          print(y, id(y))  # [1, 2] 4380248384
          print(z, id(z))  # [3] 4380250176
          a = z + y
          print(a, id(a))  # [1, 2, 3] 4380551424

          a[1] = 4
          print(a) # [3, 4, 2]
          print(y) # [1, 2]
          print(z) # [3]
        \end{lstlisting}

        \item If we instantiate two lists and extend them using \texttt{+=}, then we call the \texttt{\_\_extend\_\_} method, which extends \texttt{z} with a copy of \texttt{y}. Note that \texttt{z[1:]} and \texttt{y} are two different lists objects in memory, not the same reference. 
        \begin{lstlisting}
          y = [1, 2]
          z = [3]
          print(y, id(y))  # [1, 2] 4380248384
          print(z, id(z))  # [3] 4380250176
          z += y
          print(z, id(z))  # [3, 1, 2] 4380250176

          z[2] = 9
          print(y) # [1, 2]
          print(z) # [3, 1, 9]
        \end{lstlisting}

        \item Just to see an example of an immutable type, even using the \texttt{iadd} method does not keep its original memory address. The entire thing is always allocated to new memory. 
          \begin{lstlisting}
            x = "Hello " 
            print(id(x)) # 4382416384
            print(x)     # Hello
            x += "World"
            print(id(x)) # 4382723056
            print(x)     # Hello World
          \end{lstlisting}
      \end{enumerate}
    \end{example}

    This explains a lot of the weird phenomena, and it is extremely important to know whether a variable is copied by reference or by value, since you'll be able to predict the behavior on one variable if you modify the other one. The common immutable types in Python are string, int, float.


    \begin{example}
      To drive the point home, take a look at this. T

      \noindent\begin{minipage}{.5\textwidth}
        \begin{lstlisting}[]{Code}
          # Pass by value
          x = 4 
          y = x
          # Points to same address
          print(id(x)) # 4382741696 
          print(id(y)) # 4382741696 
          x += 1 
          # Now it doesn't
          print(x)    # 5
          print(y)    # 4
        \end{lstlisting}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\textwidth}
        \begin{lstlisting}[]{Output}
          # Pass by reference
          x = [] 
          y = x
          # Points to same address 
          print(id(x)) # 4383459648
          print(id(y)) # 4383459648
          x.append(1) 
          # Still points to same address
          print(x)     # [1]
          print(y)     # [1]
        \end{lstlisting}
      \end{minipage}
    \end{example}

    \begin{example}[Common Traps]
      To initialize a list of zeros, we can just do 
      \begin{lstlisting}
        >>> x = [0] * 5
        >>> x[0] = 1
        >>> x
        [1, 0, 0, 0, 0] 
      \end{lstlisting}
      This is all good since primitive types are immutable, so modifying one really just rebinds it to another value and doesn't affect the others. However, if we are initializing a list of lists, then we get something different. 
      \begin{lstlisting}
        >>> x = [[]] * 5
        >>> print(x)
        [[], [], [], [], []]
        >>> x[0].append(1)
        >>> x
        [[1], [1], [1], [1], [1]] 
      \end{lstlisting}
      This is because we are instantiating 5 names that all point to the same empty list. Modifying one really is an act of mutating, leading to the changes persisting across all names. This is because the inner list is multiplied and therefore copied \textit{by reference}. This means that all the lists are simply pointing to the same object in memory, and modifying one modifies all.  
    \end{example}

  \subsection{Assignments are Everywhere}

    Let's look at a few more examples where assignment are, starting with enhanced for loops. 

    \begin{theorem}[Assignments in Enhanced For Loops]
      Enhanced for loops of form \texttt{for elem in x} is really an assignment of \texttt{elem} to each element of \texttt{x}. All of the following are assignments. 
      \begin{lstlisting}
        for elem in ... 
        [... for elem in ...]
        (... for elem in ...)
        {... for elem in ...}
      \end{lstlisting}
    \end{theorem}

    Take a look at this anomaly. 
    \begin{lstlisting}
      x = [1, 2, 3] 
      for elem in x: 
          elem += 1 
      print(x) # [1, 2, 3]
    \end{lstlisting}
    With the above theorem, the problem is clear. In the first iteration, we have \texttt{elem = 1} and \texttt{x[0] = 1}. \texttt{elem} has been incremented with \texttt{iadd} and therefore is rebound to \texttt{2}, but this does not affect \texttt{x[0]}, leading to no changes. Note that if the elements were mutable, then we can make these changes persist. 
    \begin{lstlisting}
      x = [[1], [2], [3]]
      for elem in x: 
          elem[0] += 1 
      print(x) # [[2], [3], [4]]
    \end{lstlisting}
    In here, \texttt{elem} and \texttt{x[0]} are bound to \texttt{[1]} and have the same memory address. I then access the memory address of the first element of \texttt{elem} and rebind it to its increment. While the \texttt{1} changes to a \texttt{2}, and \texttt{elem[0]} points to a different memory address, the memory address of \texttt{elem[0]} itself does not change! Therefore, we have effectively changed the value of the element and have basically mutated the array using the \texttt{setitem} dunder method. 
    
    This also persists in functions as well. 

    \begin{theorem}[Assignments in Functions]
      Arguments in functions are also assigned, in local scope of course.  
    \end{theorem}

    Compare these two snippets. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      def augment_twice(a_list, val):
        a_list.append(val)
        a_list.append(val)

      nums = [1, 2, 3]
      augment_twice(nums, 4)
      print(nums)         # [1, 2, 3, 4, 4]
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      def augment_twice_bad(a_list, val):
        a_list = a_list + [val, val]

      nums = [1, 2, 3]
      augment_twice_bad(nums, 4)
      print(nums)         # [1, 2, 3]
      .
    \end{lstlisting}
    \end{minipage}
 
    \begin{enumerate}
      \item In the LHS, \textbf{nums} is bound to \texttt{[1, 2, 3]}. In the function scope, \texttt{a\_list} is also bound to the same list. We augment \texttt{4} twice, which mutates the object, and upon returning, the name \texttt{a\_list} is removed. However, the changes persist and is seen by \texttt{nums}. 
      \item In the RHS, \texttt{nums} is also bound to \texttt{[1, 2, 3]}. In the function, \texttt{a\_list} is being rebound since we use the \texttt{add} method, effectively creating a new list in memory. Now the two variables point to different objects with different memory addresses, and when the function returns, the new list is deleted. Note that this could be avoided if we use the \texttt{iadd} dunder method, which leads to the memory address being preserved. 
    \end{enumerate}

  \subsection{Object Caching}

    In general, if we initialize two variables to be the same value, they do not point to the same memory address. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      # Example of when two variables are 
      # initialized to be the same value, but 
      # do not point to the same memory
      x = 1000
      y = 1000
      print(id(x)) # 4385025360
      print(id(y)) # 4385026288 
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      int* x_ = malloc(sizeof(int)); 
      *x_ = 1000; 
      int** x = &x_; 

      int* y_ = malloc(sizeof(int)); 
      *y_ = 1000; 
      int** y = &y_; 

      printf("%p\n", *x); 0x600001be8040 
      printf("%p\n", *y); 0x600001be8050 
    \end{lstlisting}
    \end{minipage}

    However, we can initialize \texttt{y} to be equal to \texttt{x}, which tells it to point to the same memory address as \texttt{x} is, thus having the same \texttt{id}. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = 1000 
      y = x 
      print(id(x)) # 4303203888 
      print(id(y)) # 4303203888 
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      int* x_ = malloc(sizeof(int)); 
      *x_ = 1000; 
      int** x = &x_; 

      int** y = &x_; 

      printf("%p\n", *x); 0x600002368040 
      printf("%p\n", *y); 0x600002368040 
    \end{lstlisting}
    \end{minipage}

    This does not change for mutable types either. 
    \begin{lstlisting}
      x = [] 
      print(id(x)) # 4378741056
      x = [] 
      print(id(x)) # 4378742848
    \end{lstlisting}

    Usually, just setting the values equal does not have it point to the same memory address, but for integers \texttt{[-5, 256]}, Python caches these numbers so that even if we initialize two numbers with the same integer value, they will always point to the same address. 

    \begin{lstlisting}
      # Don't need to set y = x
      x = 200 
      y = 200 
      print(id(x)) # 4314934592 
      print(id(y)) # 4314934592
    \end{lstlisting}

    This is a CPython-specific fact that you should be aware of. 

  \subsection{Default Arguments are Evaluated when Function is Defined}

    We are used to writing functions with default arguments. An important implementation detail is that default arguments are evaluated when a function is \textit{defined}, not when it is called. Consider the following buggy example. 

    \begin{lstlisting}
      def stuff(x = []): 
          x.append(3)
          print(x)

      stuff() # [3]
      stuff() # [3, 3]
    \end{lstlisting}

    There are two unexpected errors with this: 
    \begin{enumerate}
      \item We would expect the second call to \texttt{stuff} to print \texttt{[3]}. 
      \item The list that \texttt{x} references to should be garbage collected (more on this later) when the name has been deleted after the function returned, but it did not. 
    \end{enumerate}

    We will address this first problem. It turns out that the default argument \texttt{[]} is created in memory and every call with the default argument assigns \texttt{x} to this same list object in the same address. That is, no new lists are created. 

    This is of course not a problem if default arguments are immutable types likes integers. Even though the default argument is bound to the same object in memory for all calls, the value cannot be modified since you can only rebind it to another object, so it will not contaminate other calls. 

\section{Function Closures and Variable Scopes}

  Therefore, this can lead to buggy behavior when using mutable types where it may be passed by reference. 

  Nonlocal and global keywords. 

\section{Lists}

  Lists are implemented as an array of pointers, which can point to any object in memory which is why Python lists can be dynamically allocated. We should be familiar with the general operations we can do with a list, which are implemented as dunder methods. 

  \begin{definition}[Length]
    The \texttt{list.\_\_len\_\_()} method returns the length of a list, which is stored as metadata and is thus $O(1)$ retrieval time. It is invoked by \texttt{len(list) <-> list.\_\_len\_\_()}. 
  \end{definition}

  \begin{definition}[Set Item, Get Item, Del Item]
    The following three methods are getter, setter, and delete functions on the \texttt{list[T]} array given the index. 
    \begin{enumerate}
      \item The \texttt{\_\_getitem\_\_(i) -> T} returns the value of the index of the list. Since we can do pointer arithmetic on the array, which is again just 8 byte pointers, we essentially have $O(1)$ retrieval time. It is invoked by \texttt{list[i] <-> list.\_\_getitem\_\_(i)}. 
      \item The \texttt{\_\_setitem\_\_(i, val) -> None} returns \texttt{None} and sets the value of the index. It is invoked by \texttt{list[i] = val <-> list.\_\_setitem\_\_(i, val)}. 
      \item The \texttt{\_\_delitem\_\_(i) -> None} deletes the value at that index. It is invoked by \texttt{del list[i] <-> list.\_\_delitem\_\_(i)}. 
    \end{enumerate}
  \end{definition}

  The next few definitions are not dunder methods, but are important. 
  \begin{definition}[Append, Insert, Pop]
    \texttt{List.append(val)} is amortized $O(1)$ but is quite slow if we are inserting into the middle with \texttt{List.insert(i, val)}. 
    \texttt{List.pop()} is great for removing from the back of the list, with $O(1)$, but not so great for removing from the front, where all the elements have to be shifted $O(n)$. 
    Dynamically resizing the array, where all the elements of the previous array gets copied over to a larger array, is slightly different. For example, in an old implementation of Python, the new size is implemented to be \texttt{new\_size + new\_size >> 3 + (new\_size < 9 ? 3 : 6)}, which approximately doubles the size (like Java, which exactly doubles the list size), giving us amortized $O(1)$. 
  \end{definition}

  \begin{definition}[Extend]
    
  \end{definition}

  \begin{definition}[Sort]
    
  \end{definition}

  List slicing is quite slow since we are copying the references to every element in the list. Note that the values are not copied themselves, but we are creating an array of new pointers. 

  Slicing can be done past last index. Slicing creates a copy of the sublist. 

  \subsection{Queues}

    A \texttt{collections.deque} (double ended queue) is implemented as a doubly linked list. 

\section{Hash Maps}

    In general, a hashmap can be implemented in the following ways. We take an object and hash its \textit{value}, giving us another memory address. This intuitively implies that this object is immutable, since changing the object will lead to a different memory address. A convenient way to bypass this is to convert lists into tuples.\footnote{However, there are languages where you can hash mutable objects. Again, this is an implementation detail.} The hash function may map two different values to the same memory address, so we can deal with collisions in different ways.\footnote{Good visuals here: \href{https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/}{https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/}.}

    \begin{enumerate}
      \item \textit{Linked List}. The hashed address actually is a linked list, and every time we add to it we append to the linked list. 
      \item \textit{Probing}. If we have two objects $x_1$ and $x_2$ which both map to the same $y = h(x_1) = h(x_2)$, then we can predefine another function $f$ that will act on $h(x_2)$ when it sees that $h(x_1)$ is already occupied, effectively mapping it to $f(h(x_2))$. Two common ones is $f(x) = x + 1$, which maps it to the next address, called \textit{linear probing}, or we can scale it in different ways, e.g. \textit{quadratic probing}. 
      \item \textit{Double Hashing, Open Addressing}. We can hash the hash differently, effectively doing $(h_1(x) + i \cdot h_2(x)) \mathrm{mod} S$, and keep incrementing $i$ from $0$ to whenever it sees a new spot. 
    \end{enumerate}

    \begin{definition}[Python Dictionaries]
      Python does indeed implement dictionaries as hash maps/tables and uses open addressing to handle collisions, meaning that it can only store one and only one entry. Python's hash table is also a contiguous block of memory, so you can actually do $O(1)$ lookup by index as well, though the indices aren't stored. 

      \begin{figure}[H]
        \centering 
        \begin{lstlisting}
          -+-----------------+
          0| <hash|key|value>|
          -+-----------------+
          1|      ...        |
          -+-----------------+
          .|      ...        |
          -+-----------------+
          i|      ...        |
          -+-----------------+
          .|      ...        |
          -+-----------------+
          n|      ...        |
          -+-----------------+ 
        \end{lstlisting}
        \caption{Logical model of Python Hash table. It consists of the keys, the hash of the keys, and the values that are stored in the hashed memory address. The indices are shown on the left, but they are not stored along with the table. }
        \label{fig:hash_table}
      \end{figure}

      When a new dict is initialized, it starts with 8 slots. 
      \begin{enumerate}
        \item When adding entries to the table, we take the key $k$, hash it to $h$, and we do an additional mask operation \texttt{i = mask(key) \& mask}, where \texttt{mask = PyDictMINSIZE - 1} (in CPython). 
        \item If the slot is empty, the entry is added to the slot. If the slot is occupied, CPython (and PyPy) compares the hash and the key (with \texttt{==}, not \texttt{is}) of the entry in the slot against what we are inserting. If \textit{both} match, it thinks the entry already exists and uses open addressing to move onto the next entry. 
        \item The dict will be resized if it is 2/3 full to avoid slowing down lookups. 
      \end{enumerate}
    \end{definition}

    It is well known that the keys and hash tables are not guaranteed to be in sorted order, and this is true in general. However, in Python it is different. 

    \begin{theorem}
      From Python 3.7+ (for all implementations) and CPython 3.6+, dicts preserve insertion order, so calling \texttt{dict.keys()} will return keys in insertion order
    \end{theorem}

    \begin{example}[Back to References]
      As a review, when we iterate over a dict with an enhanced for loop, we are just calling \texttt{next} on the keys or values that may be a copy by value or a copy by reference. 

      \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        # y is copied by value so incrementing 
        # it rebinds it
        >>> x = {"a" : 1, "b" : 2, "c" : 3}
        >>> for k in x: 
        ...     y = x[k]
        ...     y += 1
        ... 
        >>> x
        {'a': 1, 'b': 2, 'c': 3} 
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        # v is passed by value, so incrementing 
        # it rebinds it
        >>> x = {"a" : 1, "b" : 2, "c" : 3}
        >>> for v in x.values(): 
        ...     v += 1
        ... 
        >>> x
        {'a': 1, 'b': 2, 'c': 3} 
        .
      \end{lstlisting}
      \end{minipage}
    \end{example}

  \subsection{Dict Class}

    We should also be familiar with some of the dunder methods. 

    \begin{definition}[Get]
      There are two ways to access from a dictionary. 
      \begin{enumerate}
        \item \texttt{dict[key]} retrieves the value and throws a \texttt{KeyNotFoundError} if a key does not exist. 
        \item \texttt{dict.get(key, def)} retrieves the value and will return \texttt{def} if the key does not exist. 
      \end{enumerate}
    \end{definition}
    
    \begin{definition}[Items]
      Given a dictionary \texttt{dict}, we can run \texttt{dict.items()} to get a \textit{view} of the dictionary. Since this is a view, it does not copy the entire dictionary, and is presented as a list of tuples. However, this is not an iterator either. T 
    \end{definition}

  \subsection{Dict-Like Data Structures}
  
    Let's look through the different dict-like data structures. 

    \begin{definition}[Defaultdict]
      A nice trick is to initialize a \texttt{collections.defaultdict}, which is a subclass of \texttt{Dict} that allows you to use \texttt{dict[key]} and automatically initializes the value to some default value if the key does not exist. It is initialized in the following ways. 
      \begin{enumerate}
        \item \texttt{defaultdict(int)} 
        \item \texttt{defaultdict(dict: Dict)} 
        \item \texttt{defaultdict(log: Function, dict)} runs the function \texttt{log} every time a new key is added. 
      \end{enumerate}
    \end{definition}

    \begin{definition}[Counter]
      \texttt{collections.Counter} is good for finding the count of elements and does not require you to initialize the count to $0$ before incrementing it. 

      \noindent\begin{minipage}{.5\textwidth}
      \begin{lstlisting}[]{Code}
        data = [1, 1, 2, 3] 
        counter = {} 
        for d in data: 
            if d not in counter: 
                counter[d] = 0 
            counter[d] += 1
        {1: 2, 2: 1, 3: 1}
      \end{lstlisting}
      \end{minipage}
      \hfill
      \begin{minipage}{.49\textwidth}
      \begin{lstlisting}[]{Output}
        from collections import Counter
        data = [1, 1, 2, 3] 
        counter = Counter() 
        for d in data: 
            counter[d] += 1 
        Counter({1: 2, 2: 1, 3: 1})
        .
      \end{lstlisting}
      \end{minipage}
    \end{definition}

  \subsection{Extending Dictionaries}

\section{Additional Built-In Data Structures}

  \subsection{Heaps} 

\section{Iterators and Loops}

  Iterables, Iterators, Generators, zipping, range vs xrange. Range is an iterable, not iterator. 

  For loops and while loops are straightforward enough, but it's important to know the difference between them. 

  \subsection{Dynamic Evaluation of Condition During Loop}

    In while loops, the condition is rechecked and thus any functions called during this is recomputed at each loop, and so when deleting things from a list, the loop already accounts for the new length. However, a for loop evaluates the length of the list only once and leads to index violation errors.  

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = [1, 2, 3, 4]
      print(x)
      i = 0
      while i < len(x): 
          print(len(x))
          if x[i] == 2: 
              del x[i]
          i += 1
      print(x)

      [1, 2, 3, 4]
      4
      4
      3
      [1, 3, 4]
      
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      x = [1, 2, 3, 4]
      print(x) 

      for i in range(len(x)):
          print(i, x[i])
          if x[i] == 2: 
              del x[i]
      print(x)

      [1, 2, 3, 4]
      0 1
      1 2
      2 4
      IndexError: list index out of range
      .
    \end{lstlisting}
    \end{minipage}

    This can also be a problem when evaluating to a list where you may need to append more elements to it. Here we use the previous initial list. We want to append 5 and 6 since 2 and 4 are even, but the extra 6 added will require us to add 7 as well.   In a for loop, this also breaks down. The for loop only accounts up to the length of the original list, which will end with 6 as the last element added. Whether you want the condition to by dynamically evaluated at every loop depends on the problem. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = [1, 2, 3, 4] 
      print(x)

      i = 0 
      while i < len(x): 
          print(x[i])
          if x[i] % 2 == 0: 
              x.append(max(x) + 1) 
          i += 1

      print(x)

      [1, 2, 3, 4]
      [1, 2, 3, 4, 5, 6, 7] 
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      x = [1, 2, 3, 4]
      print(x)

      for i in range(len(x)): 
          if x[i] % 2 == 0: 
              x.append(max(x) + 1) 

      print(x)

      [1, 2, 3, 4]
      [1, 2, 3, 4, 5, 6]
      .
      .
      .
    \end{lstlisting}
    \end{minipage}

  \subsection{Iterators and Enhanced For Loops}

    A list is an example of an \textit{iterable} object. An \texttt{Iterable} class implements an \texttt{\_\_iter\_\_()} method that transforms it into an \texttt{Iterator} object. An \texttt{Iterator} objects allows one to generate some value every time a \texttt{\_\_next\_\_()} method is called. It should implement the next function and an \texttt{\_\_iter\_\_()} method also, which just returns itself. Here is an example for a list. 

    \begin{lstlisting}
      class Iterator: 

        def __init__(self, input: list): 
          self.index = 0 
          self.input = input
          self.limit = len(input)

        def __iter__(self): 
          return self

        def __next__(self): 
          if self.index > self.limit: 
            raise StopIteration
          self.index += 1 
          return self.input[self.index]
    \end{lstlisting}

    So far, we have talked about looping through a list by looking at the indices. Another way is to to use an \textit{enhanced for loop} to iterate directly over the values. When we use an enhanced for loop, we are really just creating an iterator object around the list and doing a while loop. Therefore, a for loop is really just a while loop!  

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      x = [1, 2, 3, 4] 
      for elem in x: 
          print(elem)
      .
      .
      .
      .
      .
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      x = [1, 2, 3, 4] 
      x_ = iter(x) 
      while True: 
        try: 
          item = next(x_)
        except StopIteration: 
          break 
        print(item)
    \end{lstlisting}
    \end{minipage}

    This means that every for loop is really just a while loop. For loops were created early on in programming for convenience. Even when doing for loops over indexes, the \texttt{range} is really an iterable, and so you can convert it into an iterator and do the same thing. 

    Another fact about \texttt{range} is that it is \textit{lazy}, meaning that to save memory, calling \texttt{range(100)} does not generate a list of 100 elements. The iterator really evaluates the next number on demand, which adds runtime overhead but saves memory.   

    \begin{example}[Common Trap]
      Look at the following code 
      \begin{lstlisting}
        >>> x = [1, 2, 3, 4]
        >>> for elem in x: 
        ...     elem += 1 
        ... 
        >>> x
        [1, 2, 3, 4] 
      \end{lstlisting}
      This is clearly not our intended behavior. This is because in the backend, the \texttt{elem} is really being returned by calling \texttt{next()} on the iterator object. The type being returned is an \texttt{int}, a primitive type, and therefore it is passed \textit{by value}. Even though \texttt{elem} and \texttt{x[i]} points to the same memory address, once we reassign \texttt{elem += 1}, elem just gets reassigned to another number, which does not affect \texttt{x[i]}. Note that this does not work as well since \texttt{elem} is just being copied by value and not by reference, and again further changes to \texttt{elem} will decouple it from \texttt{x[i]}. 
      \begin{lstlisting}
        >>> x = [1, 2, 3, 4] 
        >>> for i, elem in enumerate(x): 
        ...     elem = x[i]
        ...     elem += 1
        ... 
        >>> x
        [1, 2, 3, 4] 
      \end{lstlisting}
      To actually fix this behavior, we must make sure to call the \texttt{\_\_setitem\_\_(i, val)} method, which can be done as such. 
      \begin{lstlisting}
        >>> x = [1, 2, 3, 4]
        >>> for i in range(len(x)): 
        ...     x[i] += 1 
        ... 
        >>> x
        [2, 3, 4, 5] 
      \end{lstlisting}
      Note that if we had nonprimitive types in the list, then the iterator will copy by reference, and we don't have this problem. 
      \begin{lstlisting}
        >>> x = [[1], [2], [3]]
        >>> for elem in x: 
        ...     elem.append(4)
        ... 
        >>> x
        [[1, 4], [2, 4], [3, 4]] 
      \end{lstlisting}
    \end{example}
 
\section{Item Assignment with Walrus Operator}

  Avoids Repeated Computation

\section{Raising Exceptions}

  Many beginners prefer to return None, but you should really be raising exceptions. 

\section{Positional and Keyword Arguments} 

\section{Decorators}

  Note that in Python, functions are first-class citizens, which means three things: 
  \begin{enumerate}
    \item They can be treated as objects. 
      \begin{lstlisting}
        def shout(text): 
          return text.upper() 

        print(shout('Hello'))  # HELLO 
        yell = shout 
        print(yell('Hello'))   # HELLO
      \end{lstlisting}
    \item They can be passed into another function as an argument. 
      \begin{lstlisting}
        def shout(text): 
          return text.upper() 

        def whisper(text): 
          return text.lower() 

        def greet(func): 
          greeting = func("Hi, How are You.")
          print (greeting) 

        greet(shout)    # HI, HOW ARE YOU.
        greet(whisper)  # hi, how are you. 
      \end{lstlisting}
    \item They can be returned by another function. 
      \begin{lstlisting}
        def create_adder(x): 
          def adder(y): 
            return x+y 

          return adder 

        add_15 = create_adder(15) 
        print(add_15(10)) # 25 
      \end{lstlisting}
  \end{enumerate}

  Say that you have a function \texttt{f} that does something. I want to modify the behavior so that I do something either before of after \texttt{f} is called automatically, but I don't want to manually add code into the function body. What I can do is simply define another function \texttt{wrapper} and call \texttt{f} inside it. 
  \begin{lstlisting}
    def f(): 
        print("Hello world") 

    def wrapper(): 
        print("started") 
        f()
        print("ended") 

    wrapper() # "started\n Hello world\n ended"
  \end{lstlisting}

  Great, we can do this for one function. But what if there were thousands of functions I want to do this for? Rather than creating a wrapper function for each function, I can make a third function called \texttt{decorator} that takes in the original function \texttt{f} and outputs the \texttt{wrapper} function. 

  \begin{lstlisting}
    def decorator(f): 
      def wrapper(): 
        print("started") 
        f()
        print("ended") 

      return wrapper

    def f(): 
      print("Hello world") 

    wrapper = decorator(f)
    wrapper() # "started\n Hello world\n ended"

    decorator(f) # <function decorator.<locals>.wrapper at 0x100b38e00>
    decorator(f)() # "started\n Hello world\n ended"
  \end{lstlisting}

  This way, I can modify any function I want with this behavior, and is known as \textit{function aliasing}. This is essentially what a decorator is. 

  \begin{definition}[Decorators]
    \textbf{Decorators} are used to modify the behavior of your functions without changing its actual code, used with the \texttt{\@} operator. The two are equivalent. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      def decorator(f): 
        def wrapper(): 
          print("started") 
          f()
          print("ended") 

        return wrapper

      def f(): 
        print("Hello world") 

      f = decorator(f)
      f() # "started\n Hello world\n ended"
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      def decorator(f): 
        def wrapper(): 
          print("started") 
          f()
          print("ended") 

        return wrapper

      @decorator
      def f(): 
        print("Hello world") 

      f() # "started\n Hello world\n ended"
    \end{lstlisting}
    \end{minipage}

    This means that every time I call the function \texttt{f}, it really calls the function \texttt{decorator} with \texttt{f} passed into it as an argument. With functions that have arguments, the wrapper function should also have the same arguments. Generically, we can just use the \texttt{\*args} and \texttt{\*\*kwargs} arguments to unpack these variables so that \texttt{wrapper}'s arguments always matches those of \texttt{f}'s arguments, but we can modify these arguments for extra functionality as well. 

    \noindent\begin{minipage}{.5\textwidth}
    \begin{lstlisting}[]{Code}
      # generic args and kwargs
      def decorator(f): 
        def wrapper(*args, **kwargs): 
          print("started") 
          f(*args, **kwargs)
          print("ended") 

        return wrapper

      @decorator
      def f(string): 
        print(string) 

      f("Hello World")
      # started
      # Hello World
      # ended
    \end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{.49\textwidth}
    \begin{lstlisting}[]{Output}
      # custom arguments 
      def decorator(f): 
        def wrapper(string, start_msg): 
          print(start_msg) 
          f(string)
          print("ended") 

        return wrapper

      @decorator
      def f(string): 
        print(string) 

      f("Hello World", "time to go")
      # time to go
      # Hello World
      # ended
    \end{lstlisting}
    \end{minipage}
    If we want to get the return values of this function, we can store the return value in temporary variable \texttt{tmp}, run whatever code after the function \texttt{f}, and finally return \texttt{tmp} in \texttt{wrapper}. 

    \begin{lstlisting}
      def decorator(f): 
          def wrapper(*args, **kwargs): 
              print("started") 
              tmp = f(*args, **kwargs)
              print("ended") 
              return tmp

          return wrapper

      @decorator
      def f(string): 
          return string + "!"

      print(f("Hello World"))
      # started
      # ended
      # Hello World!
    \end{lstlisting}
  \end{definition}

  \begin{example}[Measuring Total and CPU Runtime]
    If we want to find the runtime of a function, we can do this easily. 

    \begin{lstlisting}
      import time 

      def runtime(f): 
        def wrapper(*args, **kwargs): 
          start = time.time() 
          product = f(*args, **kwargs) 
          end = time.time() 
          print(f"Took {end - start} s") 
          return product
        return wrapper

      @runtime
      def dot(list1, list2): 
        res = 0 
        for x, y in zip(list1, list2): 
          res += x * y 
        return res

      x = [1, 2, 3]
      y = [2, 2, 3]
      result = dot(x, y)  # Took 3.814697265625e-06 s 
      print(result)       # 15 
    \end{lstlisting}

    However, this is not accurate as the OS will switch between different processes. Therefore, the process time is more accurate. 

    \begin{lstlisting}
      import numpy as np
      import time

      def cpu_usage(f):
        def wrapper(*args, **kwargs):
          start_cpu = time.process_time()
          result = f(*args, **kwargs)
          end_cpu = time.process_time()
          print(f"CPU time: {end_cpu - start_cpu:.6f} seconds")
          return result
        return wrapper

      @cpu_usage
      def matrix_mult(a, b): 
        return np.matmul(a, b)

      x = np.random.randn(2000, 2000)

      matrix_mult(x, x) # CPU time: 0.772730 seconds
    \end{lstlisting}
  \end{example}

  \begin{example}[Memory Usage]
    We can measure memory usage with the \texttt{psutil} library. 
    \begin{lstlisting}
      import numpy as np
      import psutil, os 

      def memory_usage(f):
        def wrapper(*args, **kwargs):
          process = psutil.Process(os.getpid())
          mem_before = process.memory_info().rss
          result = f(*args, **kwargs)
          mem_after = process.memory_info().rss
          print(f"Memory usage: {(mem_after - mem_before) / 1024 / 1024:.2f} MB")
          return result
        return wrapper

      @memory_usage 
      def matrix_mult(a, b): 
        return np.matmul(a, b)

      x = np.random.randn(2000, 2000)
      matrix_mult(x, x) # Memory usage: 46.81 MB
    \end{lstlisting}
  \end{example}

  \begin{example}[Measuring Function Call Count]
    To measure how many times a function has been called, we can use the decorator. 
    \begin{lstlisting}
      def call_counter(f):
          def wrapper(*args, **kwargs):
              wrapper.count += 1
              print(f"Function '{f.__name__}' called {wrapper.count} times")
              return f(*args, **kwargs)
          wrapper.count = 0
          return wrapper

      @call_counter
      def factorial(x): 
          if x == 1: 
              return 1 
          return x * factorial(x - 1)

      result = factorial(7)
      # Function 'factorial' called 1 times
      # Function 'factorial' called 2 times
      # Function 'factorial' called 3 times
      # Function 'factorial' called 4 times
      # Function 'factorial' called 5 times
      # Function 'factorial' called 6 times
      # Function 'factorial' called 7 times
      print(result)       
      # 5040
    \end{lstlisting}
  \end{example}

  functools.wraps. 

\section{Composing Classes}

  If you find yourself nesting built-in types, this is prob an indicator to compose classes. @dataclass.dataclass operator to define simple data structures. 

\end{document}

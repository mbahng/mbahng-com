\section{Unit and Integration Tests}

  Classical vs London school unit tests. 

  \begin{definition}[Unit Test]
    In classical unit testing, a \textbf{unit test} is a test that satisfies the 3 properties. 
    \begin{enumerate}
      \item \textit{Atomicity}. It verifies a single unit of behavior.\footnote{This may or may not encompass units of \textit{code}, which are generally classes in OOP. }
      \item \textit{Efficiency}. It does it quickly, and 
      \item \textit{Isolation}. It does it in isolation from other tests.\footnote{TBD}
    \end{enumerate}
  \end{definition}

  \begin{definition}[Integration Test]
    An \textbf{integration test} is a test doesn't satisfy precisely one of the three properties. 
    \begin{enumerate}
      \item \textit{Atomicity}. You may need to see how two units of code act together. 
      \item \textit{Efficiency}. This is subjective depending on your time constraints. 
      \item \textit{Isolation}. Multiple tests may use a shared dependency. 
    \end{enumerate}
    An \textbf{end-to-end test} is usually defined as not satisfying both atomicity and isolation, which often means that it doesn't run quickly either.  
  \end{definition} 

  To write a proper unit test, use the following, also called the Given-When-Then pattern. 
  \begin{enumerate}
    \item \textit{Arange}. Bring the system under test (SUT) and dependencies to a desired state. This is usually the largest of the three, but if it's significantly larger than the act and assert sections combined, then it's a good idea to extract the arrangements either into private methods or a separate function. 
    \item \textit{Act}. Call methods on SUT, pass the prepared dependencies, and capture the output (if any). 
    \item \textit{Assert}. Verify the outcome. This should be a single line of a method call, and be careful if it is not because then this indicates that an atomic behavior is really 2 methods, and there is an incorrect design choice somewhere. Then it can be followed by one or more assertions. 
    \item \textit{Teardown}. Depending on the language, this may be necessary if there is no automatic garbage disposal. 
  \end{enumerate}

  If you have an arange, act, assert, act, assert, etc., then this is a sign that it's an integration test. Alternatively, you should refactor it so that it is a sequence of unit tests. 

  \begin{theorem}[Avoid If Statements in Tests]
    An if statement is a conditional, and this is branching behavior that we don't want in a linear sequence of code in a unit test. 
  \end{theorem}


\documentclass{article}
\usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}


\usepackage[english]{babel}
\usepackage{tikz-cd, extarrows, esvect, esint, pgfplots, lipsum, bm, dcolumn}
\usetikzlibrary{arrows}
\usepackage{amsmath, amssymb, amsthm, mathrsfs, mathtools, centernot, hyperref, fancyhdr, lastpage}
\usepackage{graphicx} 
\usepackage{caption, subcaption}
\usepackage{enumitem}
\usepackage{fancyvrb,newverbs,xcolor}
\usepackage{tikz}
\usetikzlibrary{matrix}
\definecolor{cverbbg1}{gray}{0.93}
\newenvironment{cverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg1}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}

\renewcommand{\thispagestyle}[1]{}

\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\Sym}{Sym}
\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\std}{std}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Corr}{Corr}
\DeclareMathOperator*{\argmin}{\arg\!\min}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}{Example}[section]
\newtheorem{exercise}{Exercise}[section]
\newtheorem{corollary}{Corollary}[theorem]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\renewcommand{\qed}{\hfill$\blacksquare$}
\renewcommand{\footrulewidth}{0.4pt}% default is 0pt

\newenvironment{solution}{\noindent \textit{Solution.}}{}

\renewcommand{\thispagestyle}[1]{}


\begin{document}
\pagestyle{fancy}

\lhead{High Performance Computing}
\chead{Muchang Bahng}
\rhead{\date{Summer 2023}}
\cfoot{\thepage / \pageref{LastPage}}

\title{High Performance Computing}
\author{Muchang Bahng}

\maketitle

\tableofcontents

\pagebreak

In the first chapter, we introduce the basics of programming and computer hardware within the context of Windows or Mac operating systems, since that is what most people are familiar with. Then, I will explain everything within the context of Linux operating systems due to their greater flexibility and functionality, specifically Ubuntu 22.04 Jammy Jellyfish. 

\section{Basics}

\subsection{System Hardware}

\subsubsection{Non-Volatile Drive Storage}

A \textbf{drive} is basically a computer component used to store data. It may be a static storage device (e.g. a HDD or SSD) or may use removable media (e.g. thumb, disk, CD). All drives store nonvolatile data (also called nonvolatile memory, NVM), meaning that the data is not erased when the power is turned off.
\begin{enumerate}
    \item A \textbf{floppy disk drive} is a portable circular floppy plastic/metal disk coated with iron oxide or other magnetic material. They come in many sizes ranging from 3~8 inches in diameter, with the standard capacity being 1.44MB. When inserting the floppy disk into a computer, there is a read/write head that uses a magnet to polarize the iron particles in one of two directions, each represting a 0 or 1 in binary data. The head can also read these polarities in order to retrieve data stored on the disk in the form of polarized particles. Note that the head would read the disk "circularly" as the disk rotates. Each disk would be divided into typically 40 tracks with around 8 equal sectors.

    \item A \textbf{hard disk drive (HDD)} is an electro-mechanical data storage device that stores and retrieves digital data using magnetic storage and one or more rigid (hence, the name hard) rapidly rotating platters coated with magnetic material. Data is accessed in arandom-access manner, meaning that individual blocks of data can be stored and retrieved in any order. They usually come inside a metal case enclosing the entire drive (3.5-inch for computers and 2.5-inch for laptop HDDs). Since the data on the HDD is determined by the polarities of the magnetic material on the disks, it is sensitive to external magnetic fields that may corrupt the data. Furthermore, because the drive heads must align over an area of the disk in order to read or write data, and the disk is constantly spinning, there’s a delay before data can be accessed. The drive may need to read from multiple locations in order to launch a program or load a file, which means it may haveto wait for the platters to spin into the proper position multiple times before it can complete the command. If a drive is asleep or in a low-power state, it can take several seconds more for the disk to spin up to full power and begin operating. Their speeds are measured in RPM, with the normal range of desktop HDDs having 5400-7200 RPM. It is useful to know that 5400 RPM drives offer an average of 100MB/s read and 7200 RPM drives offer 120MB/s.

    \item A \textbf{Solid State Drive (SSD)} is an extra step up from the HDD. From the very beginning, it was clear that hard drives couldn’t possibly match the speeds at which CPUs could operate. Latency in HDDs is measured in milliseconds, compared with nanoseconds for your typical CPU. One millisecond is 1,000,000 nanoseconds, and it typically takes a hard drive 10-15 milliseconds to find data on the drive and begin reading it. The hard drive industry introduced smaller platters, on-disk memory caches, and faster spindle speeds to counteract this trend, but there’s only so fast drives can spin. Western Digital’s 10,000 RPM VelociRaptor family is the fastest set of drives ever built for the consumer market, while some enterprise drives spun as quickly as 15,000 RPM. The problem is, even the fastest spinning drive with the largest caches and smallest platters are still achingly slow as far as your CPU is concerned. Unlike HDDs, soid state drives do not need moving parts or spinning disks (hence their name). Instead, it uses NAND flash memory, which is a type of non-volatile storage that erases data in units called blocks and rewrites data at the Byte level. It also retains data for decades, regardless of whether the device is powered on or off. It is used in not only SSD, but also USB flash drives, SD cards, mobile phones, digital cameras, tablets, and others. The most fundamental unit of storage is the flash memory cell, which uses electron thresholds to hold certain bits of information, usually three bits (called TLC - triple level cell) or four bits (called QLC - quad level cell). If is no electron charge in the cell, the cell represents a 111 (for TLC) and 1111 (for QLC). Since each cell can store multiple bits of information, they are arranged in a large array (consisting of millions of cells stacked on top of each other) into a block, leading to a typical storage between 256KB and 4MB.
\end{enumerate}
On Windows, each type of drive on a computer are assigned a device/drive letter, a single alphabetic character A through Z. Computers containing a hard drive always have that default hard drive assigned to a C: drive letter, and external drives may be assigned different letters, such as Google Drive being assigned a G: drive letter. You may also notice that when opening the command prompt on windows, the leftmost letter represents which drive you are currently on. Note that the "wmic" is an abbreviation of Windows Management Interface Command. Some commands may require you to use an \textbf{elevated command prompt}, which can be used by opening the cmd file as an administrator. 
\begin{cverbatim}
C:\Users\bahng>
\end{cverbatim}

\begin{table}
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Windows CMD} & \textbf{MacOS Terminal} & \textbf{Task} \\
\hline
wmic LOGICALDISK LIST BRIEF & & Lists all the drives on your computer. Note that the DeviceID is simply the drive letter, the DriveType has numerical encodings (2: Removable disk, 3: Fixed local disk, 4: Network disk), the FreeSpace and Size are in bytes, and the VolumeName is the name of the disk. \\
\hline
wmic diskdrive get status, model & & Outputs the model name of the drive along with its status. If the status is OK, the health is good, and if it shows 'Pred Fail', your drive may crash soon. \\
\hline
chkdsk c: & & Checks the file system and provides a summary of issues on the drive. If the bad disk sectors are not 0, get technical assistance. \\
\hline
dfrgui & & Opens a window that tells you all types of drives on your computer. \\
\hline
\&lt;letter\&gt;: (d:) & & Changes the drive you are working in. \\
\hline
\end{tabular}
\end{table}

We demonstrate some of the commands here.
\begin{cverbatim}
C:\Users\bahng>wmic LOGICALDISK LIST BRIEF
  DeviceID  DriveType  FreeSpace     ProviderName  Size           VolumeName
  C:        3          838628864000                1003327844352  OS
  G:        3          71506178048                 107374182400   Google Drive

C:\Users\bahng>wmic diskdrive get status, model
  Model                      Status
  PM9A1 NVMe Samsung 1024GB  OK
\end{cverbatim}

\subsubsection{Volatile, Short-Term Storage}

Information travels from drives and other stores to the CPU, but the physical distance that the bits must travel across the motherboard also puts an upper limit on the retrieval speed (i.e. the speed of electromagnetic waves), especially if the distance must be covered thousands or millions of times back and forth. This limit is known as \textbf{latency}. This is why computers have a hierarchy of stores reserved for information that is accessed more frequently, some closer to the CPU and others even within the CPU itself!

\begin{enumerate}
    \item \textbf{Random Access Memory}, or \textbf{RAM}, is short-term memory that acts as a cache for the CPU that is 50-200 times faster than a regular SSD. It is volatile, meaning that all its memory is erased when the computer shuts down. The most recent type of RAM is DDR4, then DDR3, followed by DDR2, DDR, and SDRAM. In addition the speeds of RAM is 
    \begin{enumerate}
        \item DDR4: 2133mhz, 2400mhz, 2666mhz, 3200mhz
        \item DDR3: 1066mhz, 1300mhz, 1600mhz, 1866mhz
    \end{enumerate}
    where the mhz value represents how many times per second the RAM can access its memory. However, know that some motherboards have technical limitations to what kind of RAM speed it can handle, so in these cases, the system will throttle your faster RAM stick to meet this need. In terms of capacity, the following gives us nice benchmarks.
    \begin{enumerate}
        \item 4-8 GB: Laptops for web browsing and light gaming (e.g. my Macbook Air 2019)
        \item 16-32 GB: Laptops for gaming (possibly heavy) and programming
        \item 64-128 GB: Crazy stuff.
        \item 256 GB: This basically means you have a RAM that is pretty much the size of a typical SSD. This is usually for specialized research computers or clusters. 
    \end{enumerate}
    Finally, there are broad categories of RAM. 
    \begin{enumerate}
        \item \textbf{Static RAM (SRAM)} requires a constant power flow in order to function and therefore doesn't need to be refreshed to keep the data intact (hence the name static). Note that this does not mean that SRAM is nonvolatile. Therefore, the SRAM is typically used in CPU caches or video cards. 
        \item \textbf{Dynamic RAM (DRAM)} requires a periodic refresh of power in order to function. The capacitors that store data in DRAM gradually discharge energy (no energy means the data becomes lost). DRAM is found in systems memory and video graphics memory. 
        \item \textbf{Synchronous Dynamic RAM (SDRAM)} is a DRAM that operates in sync with the CPU clock, which means that it waits for the clock signal before responding to data input. This is advantageous since the CPU can process overlapping instructions in parallel, known as pipelining (the ability to reveive an instruction before the previous instruction has been fully resolved). This allows more instructions to be completed simultaneously. By contrast, DRAM is asynchronous, which means it responsd immediately to user input.
    \end{enumerate}
    
    \item \textbf{CPU caches} have a hierarchy that is divided into (from fastest to slowest) L1, L2, L3, and sometimes even L4. The CPU will check the L1 cache first to see if there is a hit (if there is, then data is retrieved extremely fast), then the L2, and so on. 
    \begin{enumerate}
        \item L1: 8-64 KB storage typically (but there are exceptions, i.e. the Apple M1 chip has a 192 KB L1 cache)
        \item L2: 256KB-8MB storage
        \item L3: 10-64MB storage (and sometimes up to 256MB for server chips)
    \end{enumerate}
\end{enumerate}

\begin{table}
\centering
\begin{tabular}{|p{6cm}|l|p{6cm}|}
\hline
\textbf{Windows CMD} & \textbf{MacOS Terminal} & \textbf{Task} \\
\hline
wmic MEMORYCHIP (get BankLabel, DeviceLocator, MemoryType, TypeDetail, Capacity, Speed) & & Outputs relevant information about the RAM. \\
\hline
wmic memoryship list full & & Outputs a list of all specifications of each memory stick. \\
\hline
systeminfo | findstr /C:"Total Physical Memory" & & Outputs the total RAM memory of your computer. \\
\hline
systeminfo |find "Available Physical Memory" & & Outputs the available RAM memory of your computer. \\
\hline
\end{tabular}
\end{table}

For my computer, the outputs are as such. It shows two memory sticks each with 8GB of memory, a memory type of 0 which is a DDR4 (type 24 means DDR3), speeds of 3200 mhz, and TypeDetail of 128 which means the RAM is synchronous (SDRAM).
\begin{cverbatim}
C:\Users\bahng>wmic MEMORYCHIP get BankLabel, DeviceLocator, MemoryType, TypeDetail, Capacity, Speed
BankLabel  Capacity    DeviceLocator  MemoryType  Speed  TypeDetail
            8589934592  DIMM A         0           3200   128
            8589934592  DIMM B         0           3200   128
\end{cverbatim}

The status of your CPU can be checked with the following commands
\begin{table}
\centering
\begin{tabular}{|p{6cm}|l|p{6cm}|}
\hline
\textbf{Windows CMD} & \textbf{MacOS Terminal} & \textbf{Task} \\
\hline
wmic cpu list full & & Outputs a list of all specifications of the CPU. \\
\hline
wmic cpu (get caption, deviceid, name, numberofcores, maxclockspeed, status) & & Outputs relevant information about the CPU. \\
\hline
\end{tabular}
\end{table}

\subsection{Program Lifecycle Phases}

First, we review some definitions. More on program lifecycle phases \href{https://en.wikipedia.org/wiki/Program_lifecycle_phase}{here}. Programming languages are broadly classified into two types. \textbf{High-level languages} are the familiar programming languages that we work with today (that allow much more abstraction), while \textbf{low-level languages} are very close to the hardware, such as machine language and assembly language. Programmers write programs in \textbf{source code} (usually high-level languages), which are then inputted into \textbf{language processors} that translate them into \textbf{object code} (usually \textbf{machine code} consisting of binary). The duration in which the source code of the program is being edited is called the \textbf{edit time}, while the \textbf{compile time} is when the source code is translated into machine code by a language processor. There are three types of language processors.
\begin{enumerate}
    \item A \textbf{compiler} is a language processor that reads the complete source program written in high-level language as a whole in one go and translates it into an equivalent program in machine language. The source code is translated to object code successfully if it is free of errors. The compiler specifies the errors at the end of the compilation with line numbers when there are any errors in the source code. The errors must be removed before the compiler can successfully recompile the source code again. (e.g. C, C++, C\#, Java)
    
    \item An \textbf{assmebler} is used to translate the program written in Assembly language (basically a low-level language with very strong correspondence between the instructions in the language and the machine code instructions) into machine code. The assembler is basically the 1st interface that is able to communicate humans with the machine. We need an assembler to fill the gap between human and machine so that they can communicate with each other. Code written in assembly language is some sort of mnemonics (instructions) like ADD, MUL, MUX, SUB, DIV, MOV and so on, and the assembler is basically able to convert these mnemonics into binary code.

    \item An \textbf{interpreter} translates a single statement of the source program into machine code and executes immediately before moving on to the next line. If there is an error in the statement, the interpreter terminates its translating at that statement and displays an error message. The interpreter moves on to the next line for execution only after the removal of the error. An interpreter directly executes instructions written source code without previously converting them to an object code or machine code. (e.g. Python, Pearl, JavaScript, Ruby)
\end{enumerate}
A quick compare and contrast.
\begin{table}
\centering
\begin{tabular}{|p{8cm}|p{8cm}|}
\hline
\textbf{Compiler} & \textbf{Interpreter} \\
\hline
Takes more time to analyze source code but execution time is faster. & Takes less time to analyze source code but execution time is slower. \\
\hline
Debugging is harder since the compiler generates an error message after the entire scan. & Debugging is easier since the interpreter continues translating the program until an error is met. \\
\hline
Requires a lot of memory for generating object codes. & Requires less memory because no object code is generated. \\
\hline
Generates intermediate object code. & No intermediate object code is generated. \\
\hline
\end{tabular}
\end{table}

The result of a successful compilation is an executable, which is a program in the form of a file containing millions of lines of very simple machine code instructions (e.g. add 2 numbers or compare 2 numbers), also called \textbf{processor instructions}. This executable can be stored somewhere in the computer drive for future use or it may be copied immediately in a faster memory state, such as the RAM. The \textbf{load time} is when the OS takes the program's executable from storage and puts it into an active memory (e.g. RAM) in order to begin execution. 

The CPU understands only a low level machine code language (aka native code), which is contained within the executable. The language of the machine code is hardwired into the design of the CPU hardware; it is not something that can be changed at will. Each family of compatible CPUs (e.g. the popular Intel x86 family) has its own, idiosyncratic machine code which is not compatible with the machine code of other CPU families. More information \href{https://web.stanford.edu/class/cs101/software-1.html}{here}. Once the instruction bytes are copied from storage to RAM, the CPU can run through the steps/lines at the rate of about 2 billion lines/steps per second. This execution phase, when the CPU executes the instructions until normal termination or a crash, is called the \textbf{runtime}.

\subsubsection{More on Executables}

More specifically, an \textbf{executable} is a file that contains a list of instructions and data to cause a computer's CPU to perform indicated tasks, as opposed to the data files, which are fundamentally strings of data that must be interpreted (parsed) by a program to be meaningful. Executables usually have extension names $\texttt{.exe}$ or $\texttt{.bat}$, and they can generally be run (invoked) in two ways: 
\begin{enumerate}
    \item The executable file can be run by simply double clicking on the file name, opening it, and having the user type commands in an interactive session of an interpter (like inputting commands in terminal window or a python shell).
    \item Alternatively, we can start writing a program, complete writing it, and then have this program compiled into an executable to be invoked.
\end{enumerate}
Some common examples of executables are:
\begin{enumerate}
    \item python.exe - used to run python scripts that have the .py extension, located at 
    \[\texttt{C: \textbackslash Users\textbackslash bahng\textbackslash AppData\textbackslash Local\textbackslash Programs\textbackslash Python\textbackslash Python39}\]
    \item pythonw.exe - used to run .pyw files for GUI programs
    \item terminal.exe (on MacOS)
    \item cmd.exe (on Windows OS)
    \item py.exe - an executable used to run the python.exe executable like a shortcut, located at 
    \[\texttt{C:\textbackslash windows\textbackslash py.exe}\]
\end{enumerate}

\subsubsection{Static vs Dynamic Languages}

\textbf{Type-checking} is the process of checking and verifying the type of a construct (constant, variable, array, list, object) and its usage context. It helps in minimizing the possibility of type errors in the program, and type checking may occur either at compile-time (static checking) or at run-time (dynamic checking). 
\begin{enumerate}
    \item \textbf{Statically-Typed Languages}: Since we type check during compilation, every detail about the variables and all the data types must be known before we do the compiling process. Once a variable is assigned a type, it can't be assigned to some other variable of a different type, and so the data type of a declared variable is fixed. This makes sense since in Java, C, C++, etc., the programmer must specify what the data type of each variable is by writing something like $\texttt{int myNum = 15}$.

    \item \textbf{Dynamically-Typed Languages}: Since we type-check during runtime, there is no need to specify the data type of each variable while writing code, which improves writing speed. These languages have the capability to identify the type of each variable during run-time, so we do not need to declare the data types of variables. In these languages, variables are bound to objects at run-time using assignment statements, and most modern languages (e.g. JavaScript, Python, PHP, etc.) are dynamically typed.
\end{enumerate}


\section{Linux Operating System}

\subsection{Setting Up Linux}

\subsubsection{Virtual Machines}

You can always try out Ubuntu (or any other distribution) through a \textbf{virtual machine}, which is a software emulation of a physical computer system. It allows you to run multiple operating systems or instances of an operating system on a single physical machine. Each virtual machine operates independently and has its own virtual hardware, including virtual CPU, memory, storage, and network interfaces. Virtual machines are created and managed by virtualization software called \textbf{hypervisors}. The hypervisor abstracts the underlying physical hardware and allows multiple virtual machines to share the same resources while isolating them from one another. This enables efficient utilization of hardware resources and provides flexibility in deploying and managing various operating systems and software applications. VMs generally have the advantage of being completely isolated from the main computer, so if anything wrong happens in the VM, it's fine. They can be used in research environments that are beta-testing unstable packages or for white-hacking practices. One example of a hypervisor is Oracle's \textbf{VirtualBox}, which is free to download. It should look like this when you open it for the first time. 
\begin{center}
    \includegraphics[scale=0.2]{Linux/VirtualBox.png}
\end{center}
Now in order to create a VM with its own OS, you need to have the appropriate \textbf{ISO file}, which is an exact copy of an entire optical disk such as a CD, DVD, or Blu-ray archived into a single file. The essentially stores the entire software needed to operate the OS. Therefore, you should download the proper ISO file from the internet (usually a couple GBs). 
\begin{enumerate}
    \item \href{https://ubuntu.com/download/desktop}{Ubunutu ISO files}
    \item \href{https://www.microsoft.com/en-us/software-download/windows10}{Windows 10 ISO files}
    \item Apple does not allow distribution of its ISO files, so you will need to download from unofficial sources, which may be unsafe. 
\end{enumerate}
Once you have this ISO file, you can reuse it to create as many VMs as you want of that OS. Now follow these instructions: Click the new button and select where the virtual machine data will be stored, along with its OS. You can set the RAM, but don't make it more than half of your host computer since it will hog up too much RAM. Choose ``Create a virtual hard disk now". Choose ``VDI (VirtualBox Disk Image)". Dynamically allocated just means that the virtual disk size will adaptively grow as your storage gets full. Set the disk size to be at least 20GB. 

After you created this, go to the VM settings (this is where you can edit your CPU cores, RAM cap, etc.). To add the ISO file, click on the ``Empty" tab right under the ``Controller:IDE", then the CD icon to the right, and ``choose a disk file". You should now choose the ISO file. Then go tweak other settings, and set the display:video memory to the max (128MB). Now you should be able to go through the installation wizard when you turn the VM on. 
\begin{figure}[hbt!]
    \centering 
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
        \includegraphics[width=\textwidth]{Linux/VM_Windows1.png}
        \caption{Windows 10 Set Up}
        \label{fig:d}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
        \includegraphics[width=\textwidth]{Linux/VM_Ubuntu1.png}
        \caption{Ubuntu 22.04 Set Up}
        \label{fig:d}
    \end{subfigure}
    \caption{What you should get once you open up the VM after adding ISO files. }
\end{figure}
Refer to the instructions for each OS. 
\begin{enumerate}
    \item For Windows: Say I don't have a product key. Click Windows 10 Home. Accept terms. Select the custom installation. Click the drive and click new, making the parititon at least 10534MB, and click apply. Next. Wait for the system to load. 
    \item For Ubuntu, you should get a GRUB view. Select ``Try or install Ubunutu". 
\end{enumerate}
You should now see one of these two screens. 
\begin{figure}[hbt!]
    \centering 
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
        \includegraphics[width=\textwidth]{Linux/VM_Windows2.png}
        \caption{Windows 10 Set Up}
        \label{fig:d}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
        \includegraphics[width=\textwidth]{Linux/VM_Ubuntu2.png}
        \caption{Ubuntu 22.04 Set Up}
        \label{fig:d}
    \end{subfigure}
    \caption{What you should get once you open up the VM after initial configuration and log in. }
\end{figure}
\begin{enumerate}
    \item For Windows, select your region. Select the keyboard layout. Sign in or create a Microsoft account. Choose privacy terms. Skip whatever. 
    \item For Ubuntu: Select Install Ubuntu with English. Set the keyboard layout. The normal installation may take a while, so I would select minimal depending on what you need. If you are short on time, you can uncheck the download updates while installing since you can always do that after you install. Click Erase disk and install Ubunutu. Choose region and add information. 
\end{enumerate}
Finally, you should see your desktop. 
\begin{figure}[hbt!]
    \centering 
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
        \includegraphics[width=\textwidth]{Linux/VM_Windows3.png}
        \caption{Windows 10 Set Up}
        \label{fig:d}
    \end{subfigure}
    \hfill 
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
        \includegraphics[width=\textwidth]{Linux/VM_Ubuntu3.png}
        \caption{Ubuntu 22.04 Set Up}
        \label{fig:d}
    \end{subfigure}
    \caption{What you should see once everything is set up. }
\end{figure}

\subsubsection{Pipeline for VM}
For my personal use, the packages below are ones that I end up installing every time I create a new VM to work in during research. 
\begin{cverbatim}
sudo apt update
sudo apt install snapd
sudo snap install --classic code
sudo snap install slack
sudo apt install git 
sudo snap install spotify 
sudo apt install htop


wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo dpkg -i google-chrome-stable_current_amd64.deb


sudo apt install virtualbox 
\end{cverbatim}

\subsubsection{Dual Booting Linux with Windows}

Once you are ready to use Linux consistently, it is optimal to dual boot it, which means that you have one computer that is divided into two: one for each operating system. Then you need to partition your drive and allocate it to your secondary OS. There are plenty of guides and tutorials online on how to do this. 

There may be a point where you may need to resize your drive partitions as you need more or less space in one of your OS. This is when we need to do \textbf{partition resizing}. To do this, we need an empty thumb drive with at least 8GB of space in it (everything in here will be deleted). Then in your Ubuntu, install balenaEtcher and an Ubuntu (any version) ISO file. Mount the ISO file into your USB drive using balenaEtcher, following the steps in \href{https://www.youtube.com/watch?v=Kyz9x71gEPI&t=504s}{this video} to eventually get into Gparted. Another popular \href{https://www.youtube.com/watch?v=vlVXPtJ20hA&t=467s}{guide} uses Rufus in the Windows system, but I have found that this does not work for me. 

\subsection{Shell Commands}

Let us first review some basic Unix commands that should be built in every new Ubuntu system. 
\begin{verbatim}
ls 
cd 
ls --color 
gedit 
df -h 
\end{verbatim}
Now 
\begin{verbatim}
htop 
\end{verbatim}
Additional 
\begin{verbatim}
grep
\end{verbatim}

\subsubsection{Crontab}

To schedule jobs, you run $\texttt{crontab -e}$, which will give you a text file for which you can list jobs. It looks like 
\begin{cverbatim}
# Edit this file to introduce tasks to be run by cron.
# 
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
# 
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
# 
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
# 
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
# 
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
# 
# For more information see the manual pages of crontab(5) and cron(8)
# 
# m h  dom mon dow   command
\end{cverbatim}
In the bottom line, we can add the following to run $\texttt{sudo apt update}$ every minute. The 5 columns refer to minute (0-59), hour (0-24), date of month (1-31), month (1-12), and date of week (0-7, where 0 and 7 is Sunday). The asterick means every instance of. 
\begin{cverbatim}
# Run every minute
* * * * * sudo apt update 

# Run at 9:15am every first day of the month 
15 9 1 * * sudo apt update

# Run for every minute of every hour for the 13th day of every month if it is Friday
* * 13 * 5 sudo apt update
\end{cverbatim}
You get the idea. 

\subsection{Booting Process}

The boot process on Linux is basically a series of activities that occur from the time you press the power button on your PC until the time the login screen appears. There are 4 main stages in the boot process of your operating system and they occur in the following order. 

\begin{enumerate}
    \item \textbf{BIOS} (\textbf{Basic Input/Output System}) is mainly responsible for loading the bootloader. When the computer starts, it runs a \textbf{Power on Self Test (POST)} to make sure that core hardware such as the memory and hard disk is working properly. Afterward, the BIOS will check the primary hard drives' \textbf{Master Boot Record (MBR)}, which is a section on your hard drive where the bootloader is located. \textbf{UEFI} (Unified Extensible Firmware Interface) is the successfor to BIOS, allowing for booting support for volumes over 2TB in size, but this doesn't matter. 
    
    \item The \textbf{bootloader} loads the kernel into the RAM with a set of kernel parameters. 
    
    \item The \textbf{kernel}'s primary function is to initialize devices and memory. Afterward, it loads the init process. 
    
    \item The \textbf{init} is responsible for starting and stopping essential services on your system. 
\end{enumerate}

\subsubsection{GRUB}

Regarding the bootloader, different operating systems have different kernels, and so for instances where you have a dual boot, the \textbf{GRUB} (\textbf{Grand Unified Bootloader}) provides us with a menu so that we can select the proper operating system or environment that we wish to long into. Here is a picture of a GRUB menu. 
\begin{center}
    \includegraphics[scale=0.3]{Linux/grub2-in-ubuntu.jpg}
\end{center}
Ubuntu does not display the GRUB menu by default. To see GRUB during boot you need to press the right-hand SHIFT key during boot. In fact, the $\texttt{/boot/grub/grub.cfg}$ file is the main configuration file for the GRUB bootloader, but it is not advised to edit it directly. Rather, we can edit the $\texttt{/etc/default/grub}$ file and run $\texttt{sudo update-grub}$ to that the changes are written to $\texttt{grub.cfg}$ automatically.  

\subsubsection{BIOS Setup}

For further booting functionality, you can press a certain key when booting (F2 on my Dell XPS15 9500) to enter the \textbf{BIOS setup}, which can look very different depending on the computer but looks like this for me: 
\begin{center}
    \includegraphics[scale=0.45]{Linux/ka02R000000Uot7QAC_pl_1.jpeg}
\end{center}
From here, we can edit different settings like boot options (priority of booting OS), certain video settings, etc. 

\subsubsection{Recovery Mode}

Occasionally, you may run into problems with booting up the system. You can go into \textbf{recovery mode} by looking at the advanced options in the GRUB menu and selecting the option that literally says recovery mode. 
\begin{center}
    \includegraphics[scale=0.3]{Linux/recovery1.png}
\end{center}
This gives us a list of options that we can take to fix the system. Every setting except root is automatically done. The root command gives us root privileges (no sudo is needed). This also means we have full access to all files, and we may cause irreversible damage to our system if we made a mistake. If we had not enabled read/write access with "Enable networking" the filesystem will be mounted read only, and we are unable to edit files. In case we don't have access to a network, or this was not desired, we can remount our filesystem(s) giving write access with the following command:  
\begin{cverbatim}
mount -o rw,remount /
\end{cverbatim}
With editing privileges, we can hopefully better diagnose or undo our problems. Finally, from the root shell type $\texttt{exit}$ to go back to the menu. 


\subsection{Directory Structure}
It should be clear that the $\texttt{~}$ stands for your user home directory, while $\texttt{/}$ stands for the root directory. 
\begin{cverbatim}
(base) mbahng@xps15:~\$ pwd
/home/mbahng
(base) mbahng@xps15:~\$ cd /
(base) mbahng@xps15:/\$ pwd
/
\end{cverbatim}

Let us now take a look at the contents of the root directory: 
\begin{cverbatim}
(base) mbahng@xps15:~\$ ls /
bin    dev   lib    libx32      mnt   root  snap  timeshift  var
boot   etc   lib32  lost+found  opt   run   srv   tmp
cdrom  home  lib64  media       proc  sbin  sys   usr
\end{cverbatim}
You can see that the root home directory is in here, as opposed to user home directories in the $\texttt{/home}$ folder. 
\begin{enumerate}
    \item $\texttt{root}$: This contains all the files for when you need to boot. You shouldn't mess with this. 
    \item $\texttt{etc}$: This is where you system wide configuration for applications is stored (unlike local configuration files for one user, which is stored in your home directory). It is often a target for backups. 
    \item $\texttt{media}$, $\texttt{mnt}$: Used for mounting external storage systems and even internal storage systems. 
    \item $\texttt{opt}$: A place where you can install whatever you want. Quite flexible. 
\end{enumerate}


\subsection{Users and Permission}

\subsubsection{Managing Users}

You should first check which users are on your system. Most people just check their home directory using 
\begin{cverbatim}
(base) mbahng@xps15:~\$ ls -l /home
total 8
drwxr-xr-x  3 root   root   4096 Jan 17 23:57 linuxbrew
drwxr-xr-x 44 mbahng mbahng 4096 Jul  2 13:27 mbahng
\end{cverbatim}
But this is not accurate. Rather, we should check the contents of the $\texttt{/etc/passwd}$ file, which has a list of users in our computer (1 per line). The purpose is to contain a listing of and the options that are associated with your user accounts on your server. 
\begin{cverbatim}
(base) mbahng@xps15:~\$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
...
\end{cverbatim}
Let us just examine my user. 
\begin{cverbatim}
(base) mbahng@xps15:~\$ cat /etc/passwd | grep mbahng
mbahng:x:1000:1000:mbahng,,,:/home/mbahng:/bin/bash
\end{cverbatim}
Going from left to right, mbahng is my user, the x stands for a hashed password that cannot be shown, the 1000 is the user id (UID), the 1000 is the group id (GID), mbahng is the user information field (optional), next $\texttt{/home/mbahng}$ is the user's home directory, and finally $\texttt{/bin/bash}$ is the shell designated for the user. When you create a user id when first installing Ubuntu, this will almost always have uid of 1000. On most linux distributions, the user accounts that will be used by humans are given uids of 1000 and above. Note that in Ubunutu 22.04, a home directory is not created automatically (this differs based on distribution) when we create a new user. So note the following commands. To add a user called batman, we have 
\begin{cverbatim}
(base) mbahng@xps15:~\$ sudo useradd batman         # just add user 
(base) mbahng@xps15:~\$ sudo useradd -m batman      # add user with home dir 
(base) mbahng@xps15:~\$ cat /etc/passwd | grep batman
batman:x:1001:1001::/home/batman:/bin/sh
\end{cverbatim}
and it gives a new uid that is the next available one from 1000, i.e. 1001. To delete the user, just do 
\begin{cverbatim}
(base) mbahng@xps15:~\$ sudo userdel batman         # delete user
(base) mbahng@xps15:~\$ sudo userdel -r batman      # delete user w/ home dir
\end{cverbatim}
Now let's talk about changing passwords. If you want to change your own password, you can just type $\texttt{passwd}$ and go through the steps. To set another user's password, you need to be in root mode and type 
\begin{cverbatim}
(base) mbahng@xps15:~\$ sudo passwd batman          # set password for batman
\end{cverbatim}

Note that we have a hashed version of the user's password in the $\texttt{/etc/passwd}$ file. We can actually see the full hashed versions by going into $\texttt{/etc/shadow}$. 

\subsubsection{Changing Permission}

Running $\texttt{ls -l}$ command lists all files and directories in your current working directory, along with their permissions. 
\begin{cverbatim}
-rw-rw-r--  1 mbahng mbahng 4336730777 Sep 29  2022  cuda_11.8.0_520.61.05_linux.run
drwxr-xr-x  9 mbahng mbahng       4096 Jul  1 23:33  Desktop
drwxr-xr-x  8 mbahng mbahng       4096 Jul  1 15:08  Documents
drwxr-xr-x  6 mbahng mbahng      12288 Jul  1 22:36  Downloads
drwxr-xr-x  4 mbahng mbahng       4096 Jun 29 19:43  Games
drwxr-xr-x  6 mbahng mbahng       4096 Feb 22 17:27  Jts
drwxrwxr-x  5 mbahng mbahng       4096 Jun 28 19:39  KakaoTalk
drwxr-xr-x 16 mbahng mbahng       4096 Jun  2 21:13  miniconda3
drwxrwxr-x  4 mbahng mbahng       4096 Jun 22 13:12  nltk_data
\end{cverbatim}
The first columm is a string of 10 characters representing the permissions. They are divided into 4 sections: 
\begin{cverbatim}
d   rwx   r-x   r-x 
\end{cverbatim}
The first letter can be a d, l, or -, meaning directory, link, or file, respectively. The next three groups, representing the permissions of the user (third columm), group (fourth), and everyone else, have the same format. It is rwx, which stands for read, write, execute. 
\begin{enumerate}
    \item Read: Means to read a file or read a directory. 
    \item Write: Means to edit a file or modify the contents of a directory. 
    \item Execute: Means to run the file as an executable or go $\texttt{cd}$ into the directory. 
\end{enumerate}
A dash in place of any one of them means that whatever entity does not have the permissions. However, we can set the permissions using the $\texttt{chmod}$ command. If we have a file named $\texttt{testfile.txt}$ in our current directory, we can add or revoke permissions with 
\begin{cverbatim}
chmod +r testfile.txt   // assign read permissions to all users
chmod +w testfile.txt   // assign write permissions to all users
chmod +x testfile.txt   // assign execute permissions to all users

chmod g+rw testfile.txt   // assign read and write to group 
chmod u-r testfile.txt   // revoke read to user
chmod o+x testfile.txt   // assign execute to other users 
\end{cverbatim} 
Writing all these can be tedious, so what we can do is take advantage of the numerical encodings of the permissions. Note that $r=4, w=2, x=1$, and so any number between $0$ and $7$ can encode the three bits (through the coefficients of the binary expansion). Therefore, if we wanted every permission for all users, we can write 
\begin{cverbatim}
chmod 770 testfile.txt
\end{cverbatim}
where the first 7 stands for $\texttt{rwx}$, the next 7 stands for $\texttt{rwx}$, and the final $0$ stands for $\texttt{---}$. To change the permissions for everything inside a directory (e.g. say you want to make all downloads only readable and writable by you), then you can type 
\begin{cverbatim}
chmod 600 ~/Downloads/*
\end{cverbatim}

\subsubsection{Changing Ownership}

If you have multiple users in your computer (type $\texttt{ls /home}$), then you may want to give ownership of a directory or folder to another user. 
\begin{cverbatim}
(base) mbahng@xps15: ls /home
batman mbahng
\end{cverbatim}
To change permissions of a file/directory to another user and group, we can use the $\texttt{chown}$ command (with sudo) 
\begin{cverbatim}
sudo chown -R batman:batman Downloads/
\end{cverbatim}

\subsection{Package Managers}

\subsubsection{Dpkg and Deb files}

Ubuntu is a Linux distribution within the family of Debian-based systems (with Debian, Linux Mint, etc.). File of the $\texttt{.deb}$ format is used to distribute and install software packages on these systems. A deb package contains the files for a particular software application or library, along with metadata that describes the package and instructions on how to install or remove it. The package format follows a specific structure and includes files such as control files, data files, and scripts. Therefore, many downloaded packages may come in this format, similar to how a file is zipped before we have to extract it. 

Dpkg is the primary package manager for Debian based systems. It installs, builds, removes, configures, and retrieves information for Debian packages of the $\texttt{.deb}$ format. Given that we have some file $\texttt{package.deb}$ downloaded, the command 
\begin{cverbatim}
dpkg -i package.deb
\end{cverbatim}
installs the specified package from the $\texttt{package.deb}$ file. Removing it is just (note without the suffix) 
\begin{cverbatim}
dpkg -r package
\end{cverbatim}

\subsubsection{Apt}

\href{https://www.reddit.com/r/Ubuntu/comments/9awvip/eli5_snap_and_flatpak_how_are_they_differ_from_apt/}{read more here}

While dpkg is the native package manager for Debian based systems, apt is just a built-in Ubuntu tool to help install these Debian packages and manage dependencies. To run apt commands, we must have root privilege, so we should always use sudo. When these command are run, you should get a confirmation question asking whether you want to continue, with [Y/n]. The capital letter is the default, so you can either enter in `y' or just press ENTER. 
\begin{enumerate}
    \item The update command connects to various URLs to download a list of available packages. Periodically, new packages are introduced to Debian and Ubunutu repositories all the time, so this command refreshes the index so that it knows what packages are available and at what versions. It is a good idea to run this before you use apt commands for the day. 
\begin{cverbatim}
sudo apt update
\end{cverbatim}
    \item The upgrade command just updates all packages and their dependencies to their latest versions. However, this does not update packages which require the installation of \textit{additional} packages. 
\begin{cverbatim}
sudo apt upgrade 
\end{cverbatim}
    \item The dist upgrade updates packages including those that need installation of new dependencies. So it is a good idea to run upgrade first and then dist-upgrade after.  
\begin{cverbatim}
sudo apt dist-upgrade 
\end{cverbatim}
\end{enumerate}
Installing and removing packages is easy. 
\begin{enumerate}
    \item We can install from the apt repository with 
\begin{cverbatim}
sudo apt install htop
\end{cverbatim}

    \item We can remove it with 
\begin{cverbatim}
sudo apt remove htop
\end{cverbatim}

\end{enumerate}
If you don't know the name of the application or package you want to install, then you can search for a keyword with apt search. Say that you want to install vim but you don't know what the actual package name is called. You can just type 
\begin{cverbatim}
apt search vim
\end{cverbatim}
The central location where apt gets its updates from is contained in the $\texttt{/etc/apt/sources.list}$ file. Here is a snippet of it in my system. 
\begin{cverbatim}
# deb cdrom:[Ubuntu 22.04.1 LTS _Jammy Jellyfish_ - Release amd64 (20220809.1)]/ 
jammy main restricted

# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
# newer versions of the distribution.
deb http://us.archive.ubuntu.com/ubuntu/ jammy main restricted
# deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy main restricted

## Major bug fix updates produced after the final release of the
## distribution.
deb http://us.archive.ubuntu.com/ubuntu/ jammy-updates main restricted
# deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy-updates main restricted

## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
## team. Also, please note that software in universe WILL NOT receive any
## review or updates from the Ubuntu security team.
deb http://us.archive.ubuntu.com/ubuntu/ jammy universe
# deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy universe
deb http://us.archive.ubuntu.com/ubuntu/ jammy-updates universe
# deb-src http://kr.archive.ubuntu.com/ubuntu/ jammy-updates universe
...
\end{cverbatim}

\subsubsection{Snap and Flatpak}
Other package managers that you may need to use often are snap and flatpak, which can both be installed with 
\begin{cverbatim}
sudo apt install snap flatpak 
\end{cverbatim}

\subsubsection{Wget}
wget is a command-line utility used to download files from the internet. It stands for "web get." 

\subsection{Scheduling Tasks with Cron}

\subsection{Desktop Customization}
GNOME 

\subsection{Wine}
Lutris

\section{Bash Scripting}

Learning bash scripting allows you to automate tasks that you would normally do in a terminal in a script. We just need to open a text editor and a bash script should always start with $\texttt{\#!/bin/bash}$ at the top, known as a shebang. From this, we can enter the commands that we would type as below.
\begin{cverbatim}
#!/bin/bash

ls
pwd
echo "Hello World!"
\end{cverbatim}

Now we can save it as \texttt{myscript.sh} (the suffix is not really needed if we have the shebang, but for clarity). Before we can run it, we must turn it into an executable with the command:

\begin{cverbatim}
chmod +x myscript.sh
\end{cverbatim}

By going into the working directory and running \texttt{ls --color}, we can color code all the files/directories, where green stands for executables and blue are directories. Now we can run it by:


\begin{cverbatim}
./myscript.sh
\end{cverbatim}

A nice editor for bashing is Vim. It is not necessary, but it's nice to know. 

\subsection{Vim}
Vim is a text editing software that discourages the use of the mouse. It is considered very niche but can be extremely efficient when mastered. There are many different installations of Vim, but we will use $\texttt{vim-nox}$, which provides support for scripting with various languages. 
\begin{cverbatim}
sudo apt install vim-nox
apt show vim-now
\end{cverbatim}
Now we should be able to go into our shell and type $\texttt{vim}$ to open the text editor. What shows up is a \textbf{buffer}, which is just some free memory that we can type in. This can be a new file that is not saved or an existing file that we are editing. When opening Vim, we are in \textbf{command mode}, which allows to run the following commands: 
\begin{enumerate}
    \item Quit the editor $\texttt{:q}$ or quit without saving $\texttt{:q!}$
    \item Go into \textbf{insert mode} at the beginning $\texttt{i}$ or at the end SHIFT + A
    \item Get out of insert mode ESC
    \item Save the file $\texttt{:w test.txt}$, where w stands for ``write" and $\texttt{test.txt}$ is the file name
    \item If you have opened an existing file, then you can save it simply by typing $\texttt{:w}$
    \item To undo your changes, type $\texttt{u}$
    \item Delete the line you are on $\texttt{dd}$
\end{enumerate}
Furthermore, if you are in command mode and you type $\texttt{:}$, you can press the up arrow to get your previous commands.

In command mode, we can use the arrow keys to navigate around but we can just as well do that with the H, J, K, L keys as well to save the trouble of having to reach down to the arrow keys.


\subsection{Variables}

We can set variables directly in the terminal. Note that there should not be spaces in between the equal sign and words. Furthermore, when we try to echo a variable, we must use a dollar sign to print the \textit{contents} of it. If we do not use it, then it will literally print the name of the variable.

\begin{cverbatim}
(base) mbahng@xps-15-9500:/Desktop$ myName="Muchang"
(base) mbahng@xps-15-9500:/Desktop$ echo $myName
Muchang
(base) mbahng@xps-15-9500:~/Desktop$ echo myName
myName
\end{cverbatim}

We must have the dollar sign since there are no keywords in bash. Unlike Python, where certain words like if, else, while, etc. are reserved for certain commands and therefore cannot be used as variables, we don't have this control in bash, so we need the \$. Also, if we declare a variable, it is tied to the session, so closing the terminal will delete all references.

Now we can simply apply this to a bash script. Below, we want to show one more property that distinguishes single quotes and double quotes. We want to use double quotes since single quotes will output as \textit{raw strings}.

\begin{cverbatim}
#!/bin/bash

myName="Muchang"
myAge="21"

echo "Hello, my name is $myName."
echo 'Hello, my name is $myName.'
echo "I am $myAge years old."
\end{cverbatim}

Running it gives:

\begin{cverbatim}
(base) mbahng@xps-15-9500:~/Desktop$ ./myscript.sh
Hello, my name is Muchang.
Hello, my name is $myName.
I am 21 years old.
\end{cverbatim}

Now to set the \textbf{variable equal to the output of a command}, like \texttt{pwd} or \texttt{ls}, we can just store it inside parentheses.

\begin{cverbatim}
(base) mbahng@xps-15-9500:/Desktop$ files=$(pwd)
(base) mbahng@xps-15-9500:/Desktop$ echo $files
/home/mbahng/Desktop
\end{cverbatim}

We can use this in combination with the \texttt{date} command to create maybe a script that greets us and returns the current time:

\begin{cverbatim}
#!/bin/bash

myName="Muchang"

echo "Hello, $myName."
echo "Today's date is $(date)"
\end{cverbatim}

Running it gives:

\begin{cverbatim}
(base) mbahng@xps-15-9500:~/Desktop$ ./myscript.sh
Hello, Muchang.
Today's date is Thu Jun 29 03:32:13 PM EDT 2023
\end{cverbatim}

\subsubsection{Environment Variables}
There are special types of variables, called \textbf{environment variables}, which are all in uppercase. Due to this reason, it is important to conventionally keep your own variables to not be all uppercase, as they may get confused with the environment variables. We can view all of them with the \texttt{env} command.

\begin{cverbatim}
(base) mbahng@xps-15-9500:~/Desktop$ env
SHELL=/bin/bash
SESSION_MANAGER=local/xps-15-9500:@/tmp/.ICE-unix/80970,unix/xps-15-9500:/tmp/.ICE-unix/80970
QT_ACCESSIBILITY=1
COLORTERM=truecolor
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
SSH_AGENT_LAUNCHER=gnome-keyring
XDG_MENU_PREFIX=gnome-
...
\end{cverbatim}

These are \textit{always} initialized and can be accessed, so we do not need to manually reference them.

\begin{cverbatim}
(base) mbahng@xps-15-9500:/Desktop$ echo $HOME
/home/mbahng
(base) mbahng@xps-15-9500:/Desktop$ echo $USER
mbahng
\end{cverbatim}

\subsubsection{PATH Variable}

To conveniently execute your scripts, it is advised to put them in your \texttt{/usr/local/bin} and to remove the \texttt{.sh} suffix. There are two reasons for this:
\begin{itemize}
\item \texttt{/usr/local/bin} is in the PATH environment variable, so your script can be accessed directly.
\item The directory is also in a convenient location where it is not in your home directory so you can allow third parties access to this script without compromising your own privacy.
\end{itemize}

\subsection{Basics}

\subsubsection{Math Operations}

To do basic math in Python, we just needed to type in \texttt{30 + 10} in the Python shell. However, in Bash, we need to use the \textbf{evaluate expression} command, abbreviated \texttt{expr}, where we can do addition, subtraction, multiplication (which needs the escape character since \texttt{*} is a wildcard), and integer division.

\begin{cverbatim}
(base) mbahng@xps-15-9500:$ expr 30 + 10
40
(base) mbahng@xps-15-9500:$ expr 30 - 10
20
(base) mbahng@xps-15-9500:$ expr 30 * 10
300
(base) mbahng@xps-15-9500:$ expr 30 / 10
3
(base) mbahng@xps-15-9500:~$ expr 30 / 8
3
\end{cverbatim}

Note that the spaces between the operation and the numbers are important.

\begin{cverbatim}
(base) mbahng@xps-15-9500:~$ expr 30+10
30+10
\end{cverbatim}

Again, we can store these integers in variables and operate on them.

\begin{cverbatim}
(base) mbahng@xps-15-9500:$ myNum1=100
(base) mbahng@xps-15-9500:$ echo $myNum1
100
(base) mbahng@xps-15-9500:$ expr $myNum1 + 50
150
(base) mbahng@xps-15-9500:$ myNum2=88
(base) mbahng@xps-15-9500:~$ expr $myNum1 - $myNum2
12
\end{cverbatim}

\subsubsection{Conditionals}

The syntax for a conditional is the following, where the conditionals are within square brackets, and we must always close the if statement with a \texttt{fi}.

\begin{cverbatim}
#!/bin/bash

myNum=200

if [ $myNum -eq 200 ]
then
echo "The condition is true."
else
echo "The variable does not equal 200."
fi
\end{cverbatim}

Let us clarify some more math operators:
\begin{itemize}
\item A \texttt{!} means not.
\item Equals (\texttt{-eq}) and not equals (\texttt{-ne}).
\item Greater than (\texttt{-gt}) and less than (\texttt{-lt}).
\end{itemize}

To check if there exists a file called \texttt{myfile} within a directory, we can write:

\begin{cverbatim}
#!/bin/bash

if [ -f ~/myfile ]
then
echo "The file exists"
else
echo "The file does not exist"
fi
\end{cverbatim}

We can do the same for directories by simply replacing the \texttt{-f} with a \texttt{-d}.

\subsubsection{Loops}

The syntax for a \texttt{while} loop is similar to a conditional, with square brackets. This prints out 1 through 10, with a 0.5 second timer in between.

\begin{cverbatim}
#!/bin/bash

myVar=1

while [ $myVar -le 10 ]
do
echo $myVar

bash
Copy code
# Increment by 1
myVar=$(( $myVar + 1))

# Sleep for 0.5 seconds
sleep 0.5
done
\end{cverbatim}

The syntax for a \texttt{for} loop within a range of numbers is:

\begin{cverbatim}
#!/bin/bash

for i in {1..10}
do
echo $i
sleep 1
done

echo "This is outside of the for loop."
\end{cverbatim}

We can also iterate over all files with a \texttt{.log} suffix in the \texttt{logfiles} directory and compress them using tar.

\begin{cverbatim}
#!/bin/bash

for file in logfiles/*.log
do
tar -czvf $file.tar.gz $file
done
\end{cverbatim}

\subsubsection{Outputting in a File}

We can also take all the outputs of whatever commands we ran and put them into a file with the \texttt{>>} symbol.

\begin{cverbatim}
mbahng@xps-15-9500:~/Desktop$ apt list >> packages.txt
\end{cverbatim}

\subsection{Exit Codes}

An \textbf{exit code} basically tells us whether our commands in the terminal ran or encountered some error. Up until now, we can make our best judgment in deciding whether our command actually ran successfully (that is, if there was no error). To properly diagnose this, we can output the contents of the \texttt{?} variable, which actually tells us whether the input command was a success or failure. The variable is initialized every time we enter a command.

\begin{cverbatim}
(base) mbahng@xps-15-9500:/Desktop$ ls -l /misc
ls: cannot access '/misc': No such file or directory
(base) mbahng@xps-15-9500:/Desktop$ echo $?
2
\end{cverbatim}

Basically, an exit code of 0 means that the command was successful, and anything other than 0 means a failure. The reason we want these exit codes is that when we automate tasks, we want scripts to run based on the exit codes of our original scripts. That is, if we get an exit code of 0, then this may trigger another bash script that emails the system administrator to let them know that something was wrong. We can create an example script that installs a package using apt as such:

\begin{cverbatim}
#!/bin/bash

package=htop

sudo apt install package

if [ $? -eq 0 ]
then
echo "The installation of $package was successful."
echo "The new command is available here:"
which $package
else
echo "$package failed to install."
fi
\end{cverbatim}

To manually force the exit code to be a certain number, we can do so as below. Note that since this is an \textit{exit} code, the script will end right at the line where we call \texttt{exit}. This is not like a break statement, where it breaks out of a loop to continue on the script. It literally terminates the script right here.

\begin{cverbatim}
#!/bin/bash

sudo apt install notexist
exit 0
\end{cverbatim}


\section{GPU Software}

Many software such as games or program libraries utilize the massively parallelized architecture of GPUs for higher performance. The two overwhelming companies that dominate the GPU market are \textbf{Nvidia} and \textbf{AMD}. I personally use Nivida so this guide will be directed more towards its products. 

The \textbf{GPU driver} is some software that translates our operating system instructions into instructions that the specific GPU can understand and execute. Therefore, it is extremely important to have the correct and latest driver for your specific GPU. The driver typically includes libraries to assist applications in using the GPU, tools for debugging and optimizing graphics performance, and a compiler that converts code written in high-level graphics languages (like OpenGL, Vulkan, DirectX, etc.) into instructions that the GPU can understand. 

You can check if your Ubuntu OS detects your GPU if you go to settings and scroll down to About. 
\begin{center}
    \includegraphics[scale=0.25]{GPU/Ubuntu_GPU.png}
\end{center}
Most likely Ubunutu will not detect it. As a second check, you can the following to see in terminal. 
\begin{cverbatim}
(base) mbahng@xps15:~$ nvidia-smi
Sun Jul  2 22:25:51 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 525.116.04   Driver Version: 525.116.04   CUDA Version: 12.0     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ...  Off  | 00000000:01:00.0 Off |                  N/A |
| N/A   53C    P8     1W /  50W |      5MiB /  4096MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|    0   N/A  N/A     14349      G   /usr/lib/xorg/Xorg                  4MiB |
+-----------------------------------------------------------------------------+
\end{cverbatim}
If nothing shows up, then you must install the proper driver. You can install different drivers depending on what GPU you have, so you can either do it in two ways. Note that the higher the number the newer (and better). 
\begin{enumerate}
    \item Go to the \href{https://www.nvidia.com/download/index.aspx}{Nvidia Drivers Download} page, select the properties of your system and GPU, and look at which version you need to download (535.54.03 or 535 for short in my case). 
    \begin{center}
        \includegraphics[scale=0.5]{GPU/nvidia_download.png}
    \end{center}
    Then go into terminal and type the following, replacing 535 with whichever version you got. 
    \begin{cverbatim}
sudo apt-get install nvidia-driver-535
    \end{cverbatim}

    \item Go to ``Software \& Updates" in Ubuntu, click on the ``Additional Drivers" and it will show you a list of compatible drivers. Choose any of the nonserver drivers. 
    \begin{center}
        \includegraphics[scale=0.3]{GPU/drivers_list.png}
    \end{center}
\end{enumerate}
Occasionally, there may be problems, such as a game not utilizing the GPU correctly or a package like PyTorch not having access to the GPU. In this case, try downgrading to a lower version and installing those. 




\section{Secure Shell (SSH) Protocol}



\end{document}


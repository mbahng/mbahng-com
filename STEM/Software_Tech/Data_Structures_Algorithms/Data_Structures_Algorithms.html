<!DOCTYPE html>
<html lang="en">
<head>
  <title>Muchang Bahng | Duke Math</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/CSS/Pictures/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/CSS/Pictures/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/CSS/Pictures/favicon.ico">
  <link rel="stylesheet" href="/CSS/Header_Footer.css">
  <link rel="stylesheet" href="/CSS/html_notes.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
</head>


<body>
<div class="header">
  <div id="menu_button" onclick="myFunction(this)">
      <div id="bar1"></div>
      <div id="bar2"></div>
      <div id="bar3"></div>
  </div>
  <a id="HeaderName" href="/index.html" style="text-decoration: none;">Muchang Bahng</a>
</div>
  
  <div class="space" style="height:100px;"></div>
  <div class="information">
  
  <p class="title">Data Structures & Algorithms</p>
  <hr>
  
  <div class="toc">
    <div class="toctitle">Contents</div>
    <ol class="toclist">
      <li><a href="#Section1">HTML</a></li>
    </ol>
  </div>

<div class="title_and_hide">
<p id="Section1" class="section_title">Lecture 2</p>
<a id="show_hide_1" class="show_hide" onclick="show_hide_1()">[Hide]</a></div>
<hr>
<div id="section_content_1">
There are primitive types and reference types in Java. <b>Primitive types</b> include the following and do not need a <code>new</code> keyword to create. 
<ul>
  <li>int/long: <code>int x = 5;</code></li>
  <li>float/double</li> 
  <li>boolean</li>
  <li>char</li>
</ul>

Reference types are every other type, and must be called as such
<pre>
  Scanner reader = new Scanner(...)
</pre>
You have the type (in uppercase), followed by the name of the variable, which equals a <code>new</code> and then its constructor. A  variable stores a reference to an object, i.e. a place in memory. 

<div class="subsection_title">Java Arrays</div>
Java arrays holds a <i>fixed</i> number of values of a <i>single type</i>. 
<pre>
  int[] numbers = new int[5];   // create new int array of 5 spaces 
  int[] myArray = {1, 2, 3};    // we can create a preinitialize array 
</pre>
The Python list is most similar to an <code>ArrayList</code>. 

<div class="subsection_title">Special Case: Strings</div>
Even though a <code>String</code> is a reference class, it is used so commonly that we have some built in convenience. We can initialize a string in two ways: 
<pre>
  String myString = new String("Hello");    // original way 
  String myString = "Hello";                // more convenient way
</pre>
The <code>+</code> operator is overloaded to concatentate strings. 
<pre>
  String s = "Hello "; 
  String y = "World"; 
  System.out.println(s + t);   // prints "Hello World"
</pre>
Strings are actually an array of characters. 
<pre>
  String message = "Hi CS201"; 
  System.out.println(message.length()); 
  System.out.println(message.charAt(0)); 
  System.out.println(message.substring(0, 4));
  System.out.println(message.equals("Hi CS201"));  
</pre>
One thing to note is that if we want to determine if two reference type objects are equal, then we should not do it with the <code>==</code>, but with the <code>.equals(...)</code> method. You can even convert between strings and arrays of characters: 
<pre>
  char[] letters = message.toCharArray(); 
  String originalMessage = new String(letters)
</pre>
We can split and join strings with the <code>.split()</code> (an object method) and the <code>.join(" ", words)</code> (a class method). 
<pre>
  String original = "hello cs 201"; 
  String[] words = original.split(" "); 

  String combined = String.join(" ", words); 
</pre>

<div class="subsection_title">Static vs Dynamic Methods</div>
There is not just a function like in Python. Since all code is a part of a class, there are static (class) methods and dynamic (object) methods. 
<pre>
  Student dukie = new Student("Muchang", 21, "Math"); 

  Student.walk(30); // Static method 
  dukie.declareMajor(); // Dynamic method 
</pre>

<div class="subsection_title">ArrayLists</div>
Arraylists have dynamic memory, but must still have one element type. 
<pre>
  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 
</pre>
We have the collection type <code>ArrayList</code>, followed by the element type in the angle brackets <code>&lt;Integer&gt;</code>, with the variable name <code>list</code>, followed by the <code>new</code> keyword to allocate memory, and finally calling the constructor <code>ArrayList<>()</code> to initialize. We could also just put the element type in the angle brackets, but we don't have to. Some methods: 
<pre>
  ArrayList &lt;Integer> intlist = new ArrayList<>(); 
  intlist.add(1);     // appends to end of the list
  intlist.get(0);     // gets the 0th element of the list
  intlist.contains(1) // returns true if element is in list 
  intlist.size()      // size of list
</pre>
Finally, note that these data structures like ArrayLists (not Arrays, though) can only contain reference types, so that is why we use <code>ArrayList&lt;Integer></code> rather than <code>ArrayList&lt;int></code>. <code>Integer</code> and <code>int</code> types are actually different, one's a reference and the other's a primitive, but they can be converted easily. 

To convert between Arrays and ArrayLists, we do the following 
<pre>
  ArrayList&lt;Integer> intList = new ArrayList<>(); 
  int[] intArray = {2, 0, 1}; 

  for (int number : intArray) {
    intList.add(number); 
  }

  int[] newIntArray = new int[intList.size()]; 

  for (int i = 0; i&lt;intList.size(); i++) {
    newIntArray[i] = intList.get(i)
  }

</pre>
</div>

<div class="title_and_hide">
<p id="Section2" class="section_title">Lecture 3: OOP</p>
<a id="show_hide_2" class="show_hide" onclick="show_hide_2()">[Hide]</a></div>
<hr>
<div id="section_content_2">

<div class="subsection_title">Print</div>
<pre>
System.out.printf("Today is %s %d", "January", 18); 

// You can print out an ArrayList as expected, but not for Arrays 
// So you use the toString static method 
int[] array = {1, 2, 3}; 
System.out.println(array);  // [I@7e9e5f8a 
System.out.println(Arrays.toString(array)); 
</pre>

<div class="subsection_title">HashSet</div>
A <b>hashset</b> is like an ArrayList. It stores a bunch of objects of the same type, but it doesn't store duplicates and there is no order. It uses the following methods: 
<ul>
  <li><code>.add()</code></li> 
  <li><code>.size()</code></li> 
  <li><code>.contains()</code></li>
</ul>
Adding an element that already exists in a hashset does not run an error. It just doesn't do anything to the hashset. 
<pre>
  HashSet&lt;String> strSet = new HashSet<>(); 
  strSet.add("Hello"); 
  strSet.add("World"); 
  strSet.add("Hello"); 

  System.out.println(strSet.size()) // prints 2, no duplicates
</pre>

<div class="subsection_title">Classes and Objects</div>

Code for setting up a class: 
<pre>
public class Point {
  public int x; 
  public int y;  

  public Point (int x, int y) {
    this.x = p.x; 
    this.y = p.y; 
  }

  public Point (Point p) {
    this.x = x; 
    this.y = y; 
  }

  public double distanceFrom(Point other) {
    return Math.sqrt((x - other.x)*(x - other.x) + (y - other.y)*(y - other.y)); 
  }

  @Override 
  public String toString() {
    return String.format("(%d, %d)", x, y); 
  }

  @Override 
  public boolean equals(Object o) {
    if (o != null || ! (o instanceof Point)) {
      return false; 
    }
    Point other = (Point) o; 
    if (other.x == x && other.y == y) {
      return true; 
    }

    return false; 
  }
}
</pre>
Generally for objects, we should use the <code>.equals()</code> method. It must be implemented for the given class. If it is not implemented, then the <code>.equals()</code> just checks memory locations, and so calling <code>p = new Point(0.0, 0.0)</code> and <code>q = new Point(0.0, 0.0)</code> and comparing them with <code>p.equals(q)</code> would return <code>false</code>. 

When we also create an array of a certain object, we must create the actual objects in the array by calling <code>new</code>. For example, we don't even create the Point objects in an initialized array. 
<pre>
  Point[] pointArray = new Point[5];  // creates the array and allocates memory 
  System.out.println(pointArray[0].x) // but didn't actually create the points, so error
</pre>
We could also store the same references to the variables. 
<pre>
  ArrayList&lt;Point> myPoints = new ArrayList<>(); 
  Point p = new Point(2.0, 2.0); 
  myPoints.add(p); 
  p.x = 3.4; 
  myPoints.add(p); 

  // This creates the ArrayList of form (p, p), which both reference 
  // the same Point object, so both of form (3.4, 2.0), (3.4, 2.0). 
</pre>
So, we should call <code>new</code> for every Point object. 
<code>
  ArrayList&lt;Point> myPoints = new ArrayList<>(); 
  for (int i = 0; i < 10; i++) {
    myPoints.add(new Point(0.0, 0.0)); 
  }

  Point p = new Point(0.0, 0.0); 
  System.out.println(pointList.contains(p)); 
</code>
The final line can print either true or false: 
<ul>
  <li>It prints false if there is no <code>.equals()</code> method implemented in the <code>Point</code> class. <code>.contains()</code> uses the <code>.equals()</code> method on every element of the ArrayList by running a for loop, so it will use the default implementation of checking references. </li>
  <li>If <code>.equals()</code> is implemented as before, it will check the values of x and y, so it will print <code>true</code>. </li>
</ul>
</div>

<div class="title_and_hide">
<p id="Section3" class="section_title">Lecture 4/5: Interfaces and Implementations</p>
<a id="show_hide_3" class="show_hide" onclick="show_hide_3()">[Hide]</a></div>
<hr>
<div id="section_content_3">

<div class="subsection_title">Public vs Private</div>

A <b>public</b> instance variable can be accessed by code outside of the class, while a <b>private</b> one can <i>only</i> be accessed by code inside of the class. 
<pre>
  public class Point {
    public int x; 
    private int y;  
  
    public Point (int x, int y) {
      this.x = x; 
      this.y = y; 
    }
  
    public static void main(String[] args) {
      Point p = new Point(1, 2); 
      System.out.println(p.x); // 1 
      System.out.println(p.y); // 2, since called within class
    }
  }
</pre>

<div class="subsection_title">Java Interface</div>

<b>Interfaces</b> in Java specify functionality by specifying what methods exist. Three of the most important <b>abstract data types</b> we study are all interfaces in Java: At the top, we have the Java <b>Collection</b>
<ul>
  <li>
    Lists: an ordered sequences of values
    <ul>
      <li>ArrayList</li> 
      <li>LinkedList</li>
    </ul>
  </li> 
  <li>
    Set: an unordered collection of unique elements
    <ul>
      <li>Hashset</li> 
      <li>TreeSet</li>
    </ul>
  </li> 
  <li>
    Map: A collection that associates keys and values
    <ul>
      <li>HashMap</li>
      <li>TreeMap</li>
    </ul>
  </li>
</ul>
So, an interface represents the functionality of whatever we will create, while the implementation is the actual concrete class. For example, we can create a list, more specifically, an arraylist. 
<pre>
  List&lt;String> strList = new ArrayList<>(); 
  // List is interface 
  // ArrayList is implementation
</pre>
So interfaces need an implementing class specified at creation. This implementation can have any instance variables, and must override and implement <i>all</i> methods. 

<div class="subsection_title">ArrayList Implementation</div>

Now let's talk about the efficiency of operations on data structures. For an ArrayList with n values, 
<ul>
  <li><code>get()</code>, a direct lookup in an array, is constant time O(1)</li> 
  <li><code>contains()</code>, which loops through an array calling <code>.equals</code> at each step, is O(n)</li>
  <li><code>size()</code> returns value of an instance variable tracking size, does not depend on the size of the list. </li>
  <li><code>.add()</code> works like this. An ArrayList really implements the Array class in the backend. If we add to an ArrayList, we either 
  <ul>
    <li>simply add to the first open position if there's space left (constant time O(1))</li> 
    <li>we grow the size of the ArrayList by creating a new larger array, copying everything, and then adding to the first open position. (linear time O(n)), since we have to add all the elements to the new array. </li>
  </ul>
  So how larger is this new array? Hopefully we don't want to copy everything to a larger one too often. Sometimes, we use a <b>multiplicative growth factor of 2</b>, which means that whenever the implementing array is full, we double the size of the array before adding new values. Since the adding is a combination of these two cases, we have a trade off: 
  <ul>
    <li>If we grow the size a huge amount, then we are mainly in the first case, so our list is mostly O(1). But this takes up a lot of memory. </li>
    <li>If we don't want the memory to be taken up, we increase the array size by a bit, but we usually must do the second case to add, making our list addition mostly O(n). </li>
  </ul>
  </li>
</ul>
Starting with a length 1 array, if we add N elements one at a time and when full, create a new array that is 
<ul>
  <li>is twice as large (geometric growth: 1, 2, 4, 8, 16, ...). Then, we must copy at sizes 1, 2, 4, 8, ... and the total values copied looks like 
    $$1 + 2 + 4 + \ldots + (N/4) + (N/2) = N - 1$$
  This is what the <code>Java.util.ArrayList</code> implements, and you can see the performance of adding is O(N). 
  </li>
  <li>has 1 more position (arithmetic growth: 1, 2, 3, ...). Then, we must copy at sizes 1, 2, 3, 4, ... and the total values copied looks like 
    $$1 + 2 + 3 + \ldots + (N - 1) = N (N - 1)/2$$  
  If the arithmetic pattern is adding, say 1,000,000 elements, then we are wasteful of memory. 
  </li>
</ul>
This geometric growth is a good tradeoff between performance and memory usage. It never uses more than twice the memory of an array in order to store it. Furthermore, the runtime of a geometric growth pattern is <b>amortized constant time</b>, which means that it is constant when averaged over a long time. This is because the vast majority of these operations are constant time, with a few add operations which require resizing to be longer. But these few ones happen less and less frequently that when averaged over a long period, we can treat it as constant. One thing to note is that while adding to the end of an ArrayList can be efficient, adding to the front is not since it must shift the entire Array, even if there is space left. 

<div class="subsection_title">Set Interface</div>

Sets are unordered and stores unique elements. 
<ul>
  <li>Check if element is in set using <code>.contains()</code> </li>
  <li>Add element to set using <code>.add()</code>. Returns <code>false</code> if already there </li> 
  <li>Remove element with <code>.remove()</code> </li>
  <li>Not guaranteed to store them in the order added. </li>
</ul>

We can loop over a set not with a regular for loop, but with an enhanced for loop. We can also convert between lists and sets by taking an empty ArrayList and using the <code>.addAll()</code> method. 
<pre>
  List&lt;String> myList = new ArrayList<>(); 
  myList.addAll(mySet); 
</pre>

<div class="subsection_title">HashSet Implementation</div>

The HashSet implementation offers constant time performacne for basic operations (add, remove, contains, size), under some assumptions. To count unique words in an Array of Strings, using a HashSet is much much faster than using ArrayLists, since the ArrayList code uses the contains function, which itself is linear. 
<pre>
  public static int countWordsHashSet(String[] words) {
    HashSet&lt;String> mySet = new HashSet<>(); 
    for (String w : words) {
      mySet.add(w); 
    }
    return mySet.size(); 
  }
</pre>
Compare it to the less efficient code: 
<pre>
  public static int countWordsHashSet(String[] words) {
    ArrayList&lt;String> myList = new ArrayList<>(); 
    for (String w : words) {
      if (!myList.contains(w)) {
        myList.add(w); 
      }
    }
    return myList.size() 
  }
</pre>

<div class="subection_title">Map Interface</div>
Maps pair keys with values, like a dictionary. 
<ul>
  <li><code>put(k, v)</code> associates value v with key k</li> 
  <li><code>get(k)</code> returns the value associated with key k</li>
  <li><code>containsKey(k)</code> returns true if key k is in the map</li>
</ul>
The two major implementations of maps are HashMap (very efficient put, get, containsKey), and the TreeMap (nearly as efficient, keeps keys sorted). 
<pre>
  Map&lt;String, String> addressBook = new TreeMap<>(); 
  addressBook.put("Bob", "101 E. Main St."); 
  addressBook.put("Xi", "121 Durham Ave."); 
  System.out.println(addressBook);  // can do this 
</pre>
One warning is that you should check before you get. If you call <code>.get(key)</code> on a key not in the map, it returns <code>null</code> and can cause the program to crash. We can avoid this by using the <code>putIfAbsent(key, value)</code>, which puts the key value pair if the key doesn't exist. 

<b>Single Values</b>: To update maps, we can't just modify the <code>.get()</code> part. We should use <code>.put()</code> to update it. 
<pre>
  Map&lt;String, Integer> myMap = new HashMap<>(); 
  myMap.put("hi", 0); 
  int val = myMap.get("hi"); 
  myMap.put("hi", val + 1); 
</pre>
<b>Collection Values</b>: The <code>.get()</code> returns the <i>reference</i> to the collection and updates the collection directly rather than the copy, since this may be very inefficient (e.g. if we have a list). 
<pre>
  Map&lt;String, List&lt;Integer>> otherMap = new HashMap<>(); 
  otherMap.put("hi", new ArrayList<>()); 
  otherMap.get("hi").add(0); 

</pre>



</div>

<div class="title_and_hide">
<p id="Section4" class="section_title">Lecture 6: Hashing, Hash Tables</p>
<a id="show_hide_4" class="show_hide" onclick="show_hide_4()">[Hide]</a></div>
<hr>
<div id="section_content_4">
The whole purpose of HashSets and HashMaps is to enable <i>efficient search</i>, in the way that add, remove, contains, and size are O(1). This sounds ridiculous at first glance. 

<div class="subsection_title">Hash Tables</div>

Let us talk about a hash table in the context of hash maps. A hash table is an array of key value pairs. But rather than adding to positions in order from 0, 1, 2, ..., we will calculate the hash of the key, which would return an int that specifies where we store this key-value pair. So to store, <code>&lt;"ok", 8></code>, we will calculate <code>hash("ok") == 5</code> and store it in the 5th index. 
<pre>
0 
1 
2 &lt;"hi", 5>
3 
4 
5 &lt;"ok", 8>
6 
7 
</pre>
We can immediately see how this makes search easier, since if we want to find the value associated with the key "ok", then we can calculate the hash of it to find the index and look it up on the array. Java implements this with the <code>.hashCode()</code> method on the key. More specifically, to get this index, we get the hash, we calculate <code>Math.abs(key.hashCode()) % list.size()</code> (remember to take the modulus to get the index between 0 and the list size). 
<ul>
  <li>To <code>put(key, value)</code>, we compute <code>hash(key)</code> and add it in that index. If there is already a key-value pair there, then update the value. </li>
  <li>To <code>get(key)</code>, we compute <code>hash(key)</code> and retrieve it from the index. </li> 
  <li>To <code>containsKey(key)</code>, we compute <code>hash(key)</code> and check if the key exists at the index hash position of the list. </li>
</ul>
So running <code>get(key)</code> on a HashMap looks up position <code>hash(key)</code> in the hash table and returns the value there. Immediately, we see that if <code>hash</code> is not injective (which it isn't), then we can run into <b>collisions</b>. This is solved using chaining or bucketing. Bucketing basically takes each index in the array and stores not just one key-value pair, but a list of key-value pairs. 

So basically, when we want to search for the value of a key, we compute the index of it with <code>hash(key)</code>, which would return a list of key-value pairs. Java would iterate through these keys and call the <code>.equals()</code> method to compare them. This can be a problem if you are dealing with keys that are custom built classes. 
<ul>
  <li>This means that if the key types are something that you've custom built, then you <i>must</i> define the <code>.equals()</code> methods in them! You must override and implement <code>.equals()</code>. </li> 
  <li>We must also custom implement the <code>.hashCode()</code> method. </li>
</ul>
This is optional, but we can override the <code>toString()</code> method to print something we want. 

Obviously, if we create a custom <code>hashCode()</code> method that trivially maps to 0, then we would just have one giant list in the bucket at index 0, which is no more efficient than a list search. So, we should ideally assume that given N pairs with M buckets, our hashing function is built so that the probability of two random (unequal keys) hash to the same bucket is 1/M. Note that this hash function is completely deterministic. 

We should talk about runtime/memory tradeoff. Given N pairs and M buckets (with SUHA): 
<ul>
  <li>N >> M means too many pairs in too few buckets, so runtime inefficient</li>
  <li>M >> N means too many buckets for too few pairs, so memory wasteful</li> 
  <li>M slightly larger than N is the sweet spot. </li>
</ul>
To maintain an ideal ratio, we basically create a new larger table (with geometric resizing) and rehash/copy everything until we reach it. 


</div>


<div class="title_and_hide">
<p id="Section4" class="section_title">Runtime Efficiency, Big O Notation</p>
<a id="show_hide_4" class="show_hide" onclick="show_hide_4()">[Hide]</a></div>
<hr>
<div id="section_content_4">

Let us observe the runtime efficiency of concatentating strings repeatedly. Strings are immutable in Java, which means that every time a string is concatenated, we are really just creating a new one with a proper, larger size in the backened and copying all characters over. This gives us a quadratic complexity of O(n^2). 
<pre>
  public static String repeatConcatA(int rept, String toConcat) {
    String result = new String(); 
    for (int i=0; i < reps; i++) {
      result += toConcat; 
    }
    return result; 
  }
</pre>
The following method using <b>StringBuilder</b>s gives a linear complexity since it is treated like an ArrayList of characters, which already has space allocated and grown geometrically. 
<pre>
  public static String repeatConcatB(int reps, String toConcat) {
    StringBuilder result = new StringBuilder(); 
    for (int i=0; i < reps; i++) {
      result.append(toConcat); 
    }
    return result.toString(); 
  }
</pre>
We can just see a chart of how long the entire method takes. More specifically, if we look at a chart telling us how long each repetition takes, if it increases on average, then we have greater than linear complexity, and if it decreases, then we have sublinearity. Suppose that we start with capacity N and double when out of capacity, appending a length N string R times. Then, the total length of this is NR, and we have to double it $log_2 (NR)$ times, each time copying the entire array. So, our total number of computations are 
$$3R + \sum_{i=0}^{\log_2 (NR)} 2^i \in O(R)$$
So StringBuilders are good for runtime efficiency when repeatedly adding characters, but it needs a bit more memory (but not more than twice of what it needs to store). 

Problems: 
<ol>
  <li>
    The following is O(n) since the loop body is O(1), and it's iterated over n times. 
    <pre>
      public int stuff (int n) {
        int sum = 0; 
        for (int k = 0; k < n; k ++) {
          sum += n; 
        }
        return sum; 
      }
    </pre>
  </li>
  <li>
    The following is O(n^2) since the loop body is O(1) and it's iterated over n(n-1)/2 times. 
    <pre>
      public int nested(int n) {
        int result = 0; 
        for (int i=0; i < n; i++) {
          for (int j = 0; j < i; j++) {
            result += 1; 
          }
        }
        return result; 
      }
    </pre>
  </li>
  <li>
    The following is O(log(n)). 
    <pre>
      public int calc (int n) {
        int sum = 0; 
        for (int k = 1; k < n; k = 2*k) {
          sum += k; 
        }
        return sum; 
      }
    </pre>
  </li>
  <li>
    The following is O(n^2). 
    <pre>
      public ArrayList&lt;String> uniqueWords (ArrayList&lt;String> words) {
        ArrayList&lt;String> unique = new ArrayList<>(); 
        for (String w : words) {        // O(1) run n times
          if (!unique.contains(w)) {    // O(n) run n times 
            unique.add(w);              // amortized O(1) run n times 
          }
        }
        return words; 
      }
    </pre>
    
  </li>
  <li>
    The following is O(n^2), where <code>result.add(0, s); </code> adds an element to the front of the list. Remember that this is O(n), since to add to the front, we have to shift the entire ArrayList. 
    <pre>
      public static List&lt;String> reverse(List&lt;String> input) {
        ArrayList&lt;String> result = new ArrayList<>(); 
        for (String s : input) {      // O(1) happens n times 
          result.add(0, s);           // O(n) happens n times
        }
        return result; 
      }
    </pre>
  </li>
</ol>

<div class="subsection_title">Complexity of Composed Methods</div>

Given the function 
<pre>
  public int stuff(int n) {
    int sum = 0; 
    for (int k = 0; k < n; k++) {
      sum += n; 
    }
    return sum; 
  }
</pre>
we would like to calculate the runtime complexity of <code>stuff(stuff(n))</code>. Well the runtime complexity of <code>stuff</code> is O(n) and returns n^2. Since we are putting n^2 into <code>stuff</code> again, which is linear, the total runtime complexity for the composition would be O(n^2). 

In general, if we have an <code>outer</code> and <code>inner</code> method, we would like to do the following: 
<ul>
  <li>Calculate the runtime complexity of <code>inner(n)</code>, say O(g(n))</li>
  <li>Calculate the value returned by <code>inner(n)</code>, say h(n).</li>
  <li>Calculate the runtime complexity of <code>outer(h(n))</code>, say O(f(n))</li>. 
  <li>The runtime complexity of the composition is really just the runtime complexity of <code>inner(n)</code> and then <code>outer(h(n))</code>, so we add them up 
  $$O(g(n)) + O(f(n))$$
  </li>
</ul>

</div>


<script src="/JS/html_notes.js"></script>
</body>
</html>
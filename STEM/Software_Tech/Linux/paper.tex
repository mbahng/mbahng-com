\documentclass{article}
  % preamble
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath, amssymb, amsthm, mathtools} % necessary
  \usepackage{lastpage} % insert last page number
  \usepackage{centernot} % for not slash

  \usepackage{circuitikz}
  \usepackage{tikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning,calc}

  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{hyperref} % hyperlinks
  \usepackage{fancyhdr} % fancy headers
  \usepackage{fancyvrb} % verbatim
  \usepackage{parskip}

  \usepackage{subcaption} % captions for figures
  \definecolor{cverbbg}{gray}{0.93}

  \setlength{\parindent}{0pt} % set no indent
  \hfuzz=5.002pt % ignore overfull hbox badness warnings below this limit

  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newenvironment{question}{\color{blue}}{\ignorespacesafterend}

  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\bracket}[2]{\langle #1 | #2 \rangle}

  \theoremstyle{definition}
  \newtheorem{theorem}{Theorem}[section]
  \newtheorem{proposition}[theorem]{Proposition}
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{example}{Example}[section]
  \newtheorem{exercise}{Exercise}[section]
  \newtheorem{corollary}{Corollary}[theorem]
  \newtheorem{definition}{Definition}[section]
  \renewcommand{\qed}{\hfill$\blacksquare$}
  \renewcommand{\footrulewidth}{0.4pt}% default is 0pt

  \newenvironment{solution}{\noindent \textit{Solution.}}{}
  \newenvironment{cverbatim}
    {\SaveVerbatim{cverb}}
    {\endSaveVerbatim
    \flushleft\fboxrule=0pt\fboxsep=.5em
    \colorbox{cverbbg}{%
      \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
    }
    \endflushleft
  }

  \renewcommand{\thispagestyle}[1]{} % needed for including header in title page

\begin{document}
\pagestyle{fancy}

\lhead{Linux}
\chead{Muchang Bahng}
\rhead{\date{Summer 2023}}
\cfoot{\thepage / \pageref{LastPage}}

\title{Linux}
\author{Muchang Bahng}
\date{January 2024}

\maketitle

\tableofcontents

\pagebreak 

The following set of notes describes the everyday use of a Linux operating system. I refer to it for mainly my personal desktop, but it is also useful for working in computing clusters. Some of the commands are specific to the Arch Linux distribution (since that is what I work with), but I occasionally include those from Ubuntu and Red Hat, since I run into these distributions often in servers. 

I try to organize this in a way so that one who wishes to get started in Linux can go through these notes chronologically. For now, we will assume that you have a Linux distribution installed. There are many resources beyond this book that helps you do that. 

  
\section{Introduction}

  \subsection{Vim and Neovim}
    
    Vim is guaranteed to be on every Linux system, so there is no need to install it. However, you may have to install Neovim (which is just a command away). Vim can be a really big pain in the ass to learn, but I got into it when I was watching some video streams from a senior software engineer at Netflix called The Primeagen. He moved around the code like I've never seen, and I was pretty much at the limit of my typing speed, so I decided to give it a try during the 2023 fall semester. My productivity plummetted during the first 2 days (which was quite scary given that I had homework due), but within a few weeks I was faster than before, so if you have the patience, I would recommend learning it. Here is a summary of reasons why I would recommend learning Vim: 
    
    \begin{enumerate}
      \item It pushes you to know the ins and outs of your editor. As a mechanic with his tools, a programmer should know exactly how to configure their editor.  
      \item The plugin ecosystem is much more diverse than other editors such as VSCode. You can find plugins/extensions for everything. Here is a summmary of them \href{https://github.com/rockerBOO/awesome-neovim\#neovim-lua-development}{here}. 
      \item You're faster. If you're going to be coding for the next 5 years, then why no t spend a month to master something that will make you faster? You'll increase total productivity. 
      \item Computing clusters and servers will be much easier to navigate since they all run Linux with Vim. 
      \item Vim is lightweight, and you don't have to open up VSCode every time you want to edit a configuration file.  
    \end{enumerate}
  
    \subsubsection{Vim vs Neovim}

      Experience wise, Vim and Neovim are very similar, and if you configure things rihght, you may not even be able to tell the difference. But there are 3 differences that I want to mention: 
      
      \begin{enumerate}
        \item Neovim can be configured in Lua, which is much cleaner than Vimscript. 
        \item Neovim provides mouse control right out of the box, which is convenient for me at times and can be easier to transition into, while Vim does not provide any mouse support. 
        \item There are some plugins that are provided in Neovim that are not in Vim. 
      \end{enumerate}

      Either way, the configuration is essentially the same. At startup, the text editor will parse some predetermined configuration file and load those settings. 

    \subsubsection{Vim Configuration File}

      In Vim, your configuration files are located in \texttt{~/.vimrc} and plugins are located in \texttt{~/.vim/}. In here, you can put in whatever options, keymaps, and plugins you want. All the configuration is written in VimScript. 

      \begin{cverbatim} 
        # options 
        filetype plugin indent on 
        syntax on 
        set background=dark
        set expandtab ts=2 sw=2 ai
        set nu
        set linebreak 
        set relativenumber        
        
        # keymaps
        inoremap <C-j> <esc>dvbi
        inoremap jk <esc>
        nnoremap <C-h> ge
        nnoremap <C-l> w 
      \end{cverbatim}
        
    \subsubsection{Neovim Configuration File}

      In Neovim, I organize it using Lua. It essentially looks for the \texttt{~/.config/nvim/init.lua} file and loads the options from there. We also have the option to import other Lua modules for better file structure with the \texttt{require} keyword. The tree structure of this configuration file should be the following below. The extra \texttt{user} director layer is necessary for isolating configuration files on multiple user environments.  
      
      \begin{cverbatim}
        ... ftplugin
        .   ... cpp.lua
        .   ... html.lua
        ... init.lua
        ... LICENSE
        ... lua
        .   ... user
        .       ... options.lua
        .       ... keymaps.lua
        .       ... plugins.lua
        .       ... telescope.lua
        .       ... toggleterm.lua
        ... plugin
            ... packer_compiled.lua
      \end{cverbatim}

      The init file is the ``main file'' which is parsed first. I generally don't put any explicit options in this file and reserve it only for require statements. It points to the following (group of) files: 
      \begin{enumerate}
        \item \textbf{options.lua}: This is where I store all my options. 
        \item \textbf{keymaps.lua}: All keymaps. 
        \item \textbf{plugins.lua}: First contains a script to automatically install packer if it is not there, and then contains a list of plugins to download. 
        \item \textbf{Plugin Files}: Individual configuration files for each plugin (e.g. if I install a colorscheme plugin, I should choose which specific colorscheme I want from that plugin). 
        \item \textbf{Filetype Configuration Files}: Options/keymaps/plugins to load for a specific filetype. This helps increase convenience and speed since I won't need plugins like VimTex if I am working in JavaScript. 
      \end{enumerate}

      Once you have your basic options and keymaps done, you'll be spending most of your time experimenting with plugins. It is worth to mention some good ones that I use. 
      \begin{enumerate}
        \item \textbf{Packer} as the essential package manager.  
        \item \textbf{Plenary} 
        \item \textbf{Telescope} for quick search and retrieval of files.  
        \item \textbf{Indent-blankline} for folding. 
        \item \textbf{Neoformat} for automatic indent format. 
        \item \textbf{Autopairs} and \textbf{autotag} to automatically close quotation marks and parantheses. 
        \item \textbf{Undotree} to generate and navigate undo history. 
        \item \textbf{Vimtex} for compilation of LaTeX documents. 
        \item \textbf{Onedark} and \textbf{Oceanic Next} for color schemes. 
        \item \textbf{Vim-Startify} for nice looking neovim startup. 
        \item \textbf{Comment} for commenting visual blocks of code. 
      \end{enumerate}

      It is also worthwhile to see how they are actually loaded in the backend. Each plugin is simply a github repo that has been cloned into \texttt{~/.local/share/nvim/site/pack/packer/}, which contains two directories. The packages in \texttt{start/} are loaded up every time Neovim starts, and those in \texttt{opt/} are packages that are loaded up when a command is called in a certain file (known as lazy loading). Therefore, if you have any problems with Neovim, you should probably look into these folders (and possibly delete them and reinstall them using Packer if needed).

    \subsubsection{Troubleshooting}

      A good test to run is \texttt{:checkhealth}, which checks for any errors or warnings in your Neovim configuration. You should aim to have every (non-optional) warning cleared, which usually involves having to install some package, making it executable and/or adding to \texttt{\$PATH}. 

      If you are getting plugin errors, you can also manually delete the plugin directory in `pack/packer` and run `PackerInstall` to re-pull the repos. This may help. 

  \subsection{Distributions and Package Managers}
    
    Linux comes in many flavors of distributions. Most beginners look at screenshots of these distributions on the internet and judge them based on their aesthetics (e.g. I like how Kali Linux looks so I'll go with that one). A common feature of all Linux distributions is that they provide the user the power to customize their system however they want, so you can essentially make every linuxdistribution look like any other. So what are some things you should consider when choosing a distribution? 
  
    \begin{enumerate}
      \item First is the popularity and how well it is supported. This includes the number of people who use the distribution (e.g. the Ubuntu StackExchange is a very large community) and how good the documentation is overall (e.g. the ArchLinux wiki is very well documented). 
      \item Each linux distribution essentially consists of a kernel and package manager. The architecture, design, and the update scheme of the kernel may be an interest to many linux users.  
      \item Every distribution has its own native package manager, and the availability of certain necessary packages, the ease of installation, and the updating schemes is also something to consider.  
      \item The ideals of the respective communities. The community behind each distribution has a certain set of ideals that they lean more towards. For example, the Ubuntu community likes having programs that are right out of the box, with good GUI support and is more beginner-friendly while Arch has more of a minimal and extremely customizable nature to it with its software being much more CLI dependent. 
    \end{enumerate}

    Let's begin with the package managers. Every application on your system (Firefox, Spotify, pdf readers, VSCode, etc.) is a package, and manually downloading and managing each one is impossible to do. Therefore, each distribution has its own native package manager that automatically takes care of downloading, installing, removing, checking dependency requirements of each package. In order to download a package, a package manager should also know where it is downloading \textit{from}. Essentially, a package manager itself can be downloaded with other package managers, so package managers are packages as well. 
    
    \begin{enumerate}
      \item \textbf{apt} : The advanced packaging tool is the native manager for Ubuntu distributions. 
      \item \textbf{pacman} : Native package manager for Arch Linux. 
      \item \textbf{yay} : The package manager for software in the \textbf{Arch User Repository}. 
      \item \textbf{snap} : 
      \item \textbf{flatpak} : 
      \item \textbf{dpkg} : Package manager for Debian based distributions. 
    \end{enumerate}

    Chances are if you are using one distribution, you would only have to work with a small subset of these package managers. Each package manager has one or more files in the computer that specify a list of \textbf{repositories}. 

    \subsubsection{Pacman}

      For example, the configuration file for pacman is located at \texttt{/etc/pacman.conf}. In the options section, I can configure stuff like text color, enabling/disabling parallel downloads, choosing specific packages to ignore upgrading, etc. Then, we can specify the servers that we should download from. In the text below, the server variable defines which server we should look at first, and then the Include variable stores the location of the file \texttt{mirrorlist} that defines a list of other servers that we should download from. 
      
      \begin{figure}
        \begin{cverbatim} 
          # The following paths are commented out with their default values listed.
          # If you wish to use different paths, uncomment and update the paths.
          #RootDir     = /
          #DBPath      = /var/lib/pacman/
          #CacheDir    = /var/cache/pacman/pkg/
          #LogFile     = /var/log/pacman.log
          #GPGDir      = /etc/pacman.d/gnupg/
          #HookDir     = /etc/pacman.d/hooks/
          HoldPkg     = pacman glibc
          #XferCommand = /usr/bin/curl -L -C - -f -o %o %u
          #XferCommand = /usr/bin/wget --passive-ftp -c -O %o %u
          #CleanMethod = KeepInstalled
          Architecture = auto

          # Pacman won't upgrade packages listed in IgnorePkg and members of IgnoreGroup
          #IgnorePkg   =
          #IgnoreGroup =

          #NoUpgrade   =
          #NoExtract   =

          # Misc options
          #UseSyslog
          #Color
          #NoProgressBar
          CheckSpace
          #VerbosePkgLists
          ParallelDownloads = 5
          ILoveCandy

        \end{cverbatim}
        \caption{Subset of contents of the \texttt{/etc/pacman.conf} file} \label{fig:pacman.conf}
      \end{figure}
      
      The mirrorlist file stores a list of URLs. Each URL is a \textbf{mirror}, which is a server that contains a physical replica of all the packages that are available to you via \texttt{pacman} (hence the name mirror). You can literally type in the links provided in Figure \ref{fig:mirrorlist} (replacing \texttt{\$repo} with \texttt{core} and \texttt{\$arch} with \texttt{x86\_64}). It contains a tarball of each package ready to be downloaded. Some repos might contain more packages than others, some might have packages that only they supply that others don’t, but if you can install the piece of software via your package manager then one of your configured repos is declaring they have it available and therefore should have the file on hand to give to you if asked for it. A list of all available mirrors are available \href{https://archlinux.org/mirrorlist/all/https/}{here} (this only uses HTTPS, but HTTP mirrors are also available).  

      \begin{figure}
        \begin{cverbatim}
          Server = https://archlinux.mailtunnel.eu/$repo/os/$arch
          Server = https://mirror.cyberbits.eu/archlinux/$repo/os/$arch
          Server = https://mirror.theo546.fr/archlinux/$repo/os/$arch
          Server = https://mirror.sunred.org/archlinux/$repo/os/$arch
          Server = https://mirror.f4st.host/archlinux/$repo/os/$arch
          Server = https://md.mirrors.hacktegic.com/archlinux/$repo/os/$arch
          Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch
          Server = https://mirror.moson.org/arch/$repo/os/$arch
          Server = https://archlinux.thaller.ws/$repo/os/$arch
        \end{cverbatim}
        \caption{Contents of the \texttt{/etc/pacman.d/mirrorlist} file}\label{fig:mirrorlist}
      \end{figure}
      
      The mirrors that you download from should be trustworthy and fast. The speed is mainly related to how close you are to that mirror geographically, so if you are moving to another country you should probably update this mirrorlist for faster download speeds. There is a default mirrorlist file that is generated, but you can download and use the \textbf{reflector} package to update it.  

      Here are some common commands: 
      \begin{enumerate}
        \item Install a package: \texttt{sudo pacman -S pkg1} (\texttt{-s} stands for synchronize)

        \item Remove a package: \texttt{sudo pacman -R pkg}
        \begin{itemize}
          \item remove dependencies also: \texttt{-s} (recursive)
          \item also remove configuration files: \texttt{-n} (no save)
          \item also removes children packages: \texttt{-c} (cascade)
        \end{itemize}

        \item Update all packages: \texttt{sudo pacman -Syu}
        \begin{itemize}
          \item synchronize: \texttt{-S}
          \item refresh package databases: \texttt{-y} (completely refresh: \texttt{-yy})
          \item system upgrade: \texttt{-u}
        \end{itemize}

        \item List installed packages: \texttt{pacman -Q}
        \begin{itemize}
          \item List detailed info about a package: \texttt{pacman -Qi pkg}
          \item List all files provided by a package: \texttt{pacman -Ql pkg}
          \item List all orphaned packages: \texttt{pacman -Qdt}
          \item List all packages that have updates available: \texttt{pacman -Qu}
          \item List all explicitly installed packages: \texttt{pacman -Qet}
          \item Display the dependency tree of a package: \texttt{pactree pkg} (from the \texttt{pacman-contrib} package) 
          \item List last 20 installed packages: 
          \begin{cverbatim}
            expac --timefmt='%Y-%m-%d %T' '%l\t%n' | sort | tail -n 20
          \end{cverbatim}
        \end{itemize}

        \item To check size of current packages and dependencies, download \texttt{expac} and run \texttt{expac -H M '\%m \\t\%n' | sort -h} 

        \item The package cache stored in \texttt{/var/cache/pacman/pkg/} keeps old or uninstalled versions of packages automatically. This is helpful since it also keeps older versions of packages in the cache, and you can manually downgrade in case some packages break.  
        \begin{itemize}
          \item We can delete all cached versions of installed and uninstalled packages, except for the most recent 3, by running \texttt{paccache -r} (provided by the \texttt{pacman-contrib} package). 
          \item To remove all cached packages not currently installed, run \texttt{pacman -Sc}
          \item To remove all cached aggressively, run \texttt{pacman -Scc}
          \item To downgrade, you go into the package cache directory and say you want to see which versions of neovim you have installed. You can \texttt{ls} the directory to see the following. 
          
            \begin{cverbatim}
              neovim-0.9.5-1-x86_64.pkg.tar.zst
              neovim-0.9.5-1-x86_64.pkg.tar.zst.sig
              neovim-0.9.5-2-x86_64.pkg.tar.zst
              neovim-0.9.5-2-x86_64.pkg.tar.zst.sig
            \end{cverbatim}

            We have an older version of neovim installed, and to roll it back we can use 
            \begin{cverbatim} 
              pacman -U neovim-0.9.5-1-x86_64.pkg.tar.zst
            \end{cverbatim}
        \end{itemize} 
      \end{enumerate}

      The pacman log (\texttt{/var/log/pacman.log}) is also useful since it logs all pacman outputs when you do anything with pacman. So if you are looking for the packages that have been installed in the latest \texttt{pacman -Syu}, then you can use this to individually see each package that has been upgraded. 


    \subsubsection{Yay}

      Yay is used to install from the Arch User repository and must be updated separately. To run this, you can either run \texttt{yay -Syu} or you can just run \texttt{yay}. Since this is not officially maintained, these packages are more likely to break something. The yay logs are not stored separately can can be accessed in the pacman logs. 

    \subsubsection{Apt}  
  
  \subsection{Display Servers}

    X11, Xorg, Wayland.

  \subsection{Windows Managers and Desktop Environments}

  These days, the terms window managers (WMs) and Desktop Environments (DEs) are used interchangeably, but they mean slightly different things. A window manager is the display software that determines how the pixels for each window overlaps with other and their movement. This is generally divided into two paradigms with the most familiar being \textbf{floating WMs} and the other being \textbf{tiling WMs}. Even before I knew about tiling WMs, I found myself manually tiling windows on floating WMs, so the move to tiling WMs was a no-brainer. 
  
  Some DEs and WMs are: 
  \begin{enumerate}
    \item GNOME 
    \item KDE Plasma
    \item Qtile
  \end{enumerate}

  \subsection{File Tree of Linux Systems}

    The root director contains the following directories. Let's briefly go over what each of them do: 
    \begin{enumerate}
      \item \textbf{bin}: Contains all the binaries (i.e. executables) and is usually included in the PATH environment variable. Elementary commands like \texttt{ls} or \texttt{cd} reside in this directory. If you pay attention, you'll see that \textbf{/bin} is a symlink to \textbf{/usr/bin}. What about \textbf{/usr/local/bin}? 
      \item \textbf{sbin}: Also a symlink to \textbf{/usr/bin}.   
      \item \textbf{tmp}: A temporary folder for storing caches, local configurations, and a place to download packages to build and install. 
      \item \textbf{boot}: Booting files. 
      \item \textbf{home}: Contains all users. 
    \end{enumerate}
  
  \subsection{Shells and Terminals}

    Beginners may think of the shell and the terminal to be the same thing, but they are different. The \textbf{shell} is a command line interpreter, a layer that sits on top of the kernel in which the user can interact with. It is essentially the only API to the kernel where the user can input commands and processes them. The \textbf{terminal emulator} is a wrapper program that runs a shell and allows us to access the API. It may be useful to think of the shell as like a programming language and the terminal as a text editor like VSCode. 

    The three most common shells are the following: 
    \begin{enumerate}
      \item \textbf{Bash}: 
      \item \textbf{Zsh}: 
      \item \textbf{Fish}:  
    \end{enumerate}

    Some common terminal emulators (most of which comes as a part of the desktop environment) are the following: 
    \begin{enumerate}
      \item \textbf{Kitty}: 
      \item \textbf{Alacritty}: 
      \item \textbf{Gnome-Terminal}: 
    \end{enumerate}

  \subsection{Boot Configuration and Automatic Scripts}

    Find which file you need to put commands in to load stuff up on boot (and specify which part of the boot process). Also talk about crontab. 

\section{Booting}

  Let us go through the steps of a booting (bootstrapping) process. Administrators have little direct, interactive control over most of the steps required to boot a system, but they can modify bootstrap configurations by editing config files or system startup scripts. 

  \begin{enumerate}
    \item \textbf{Power On}: You power on the machine. 
    \item \textbf{Load firmware from NVRAM}: You want to be able to identify the specific piece of hardware to load your operating system in. The firmware is a permanent piece of software that does this. 
    \item \textbf{Probe for hardware}: We look for hardware that is on the computer. 
    \item \textbf{Select boot device (disk, network, etc.)}: We select the storage device that we want to load the operating system on. 
    \item \textbf{Identify EFI system partition}: 
    \item \textbf{Load boot loader (e.g. GRUB)}: A software that allows you to identify and load the proper OS kernel is provided. 
    \item \textbf{Determine which kernel to boot}: You choose which kernel you want to load.  
    \item \textbf{Load kernel}: The OS kernel is identified and loaded into the boot device. 
    \item \textbf{Instantiate kernel data structure}: 
    \item \textbf{Start init/systemd as PID 1}: 
    \item \textbf{Exectute startup scripts}:
    \item \textbf{Running system}: You now have a running system! 
  \end{enumerate}

  
  \subsection{Hardware}


  \subsection{System Firmware}

  Right above the hardware, the \textbf{system firmware}, is a piece of software that is executed whenever the computer boots up. When the machine is powered on, the CPU is hardwired to execute this firmware stored in ROM. \textbf{Read Only Memory} is simply another type of computer memory that stores permanent data and instructions for the device to start up. \textbf{NVRAM} is also non-volatile but it can be edited. It is clearly non-volatile and cannot be altered or accidentally changed. In video games, \textit{ROM hacking}, done through a \textit{hex editor}, can be done to modify a ROM image to alter the game's graphics, dialogue, levels, or gameplay. 

  Most firmware offers a user interface which can be accessed by pressing the F2, F11, F12, or some combination of magic keys at the instant the system first powers on. This firmware probes for hardware and disks, runs a simple set of health checks, and then looks for the next stage of bootstrapping code. The firmware UI lets you designate a boot device, usually by prioritizing a list of available options (e.g. try to boot from a DVD drive, then a USB, then the hard disk). 

  The \textbf{BIOS}, which stands for \textbf{Basic Input/Output System}, has been used traditionally. A more formalized and modern standard called \textbf{EFI} (\textbf{Extensible Firmware Interface}) has replaced it, and it has been revised to the \textbf{UEFI} (\textbf{Unified Extensible Firmware Interface}) standard, but we can treat EFI and UEFI as equivalent in most cases. Fortunately, most UEFI systems can fall back to a legacy BIOS impelmentation if the operating system they're booting doesn't support UEFI. Since we're likely to encounter boot firmware systems, it's worthwhile to go into both of them. 

  You can directly examine and modify UEFI variables on a running system with the \texttt{efibootmgr} command. You get a following summary of the configuration: 
  \begin{cverbatim}
    BootCurrent: 0005
    Timeout: 0 seconds
    BootOrder: 0005,0001,0002,0000,0003,0004
    Boot0000* UEFI PM9A1 NVMe Samsung 1024GB S65VNE0R318841 1	...
    Boot0001* ubuntu	HD(1,GPT,ede98b7e-75ad-452e-ab47-3411dd6026c1,0x800,0x780...
    Boot0002* Windows Boot Manager	HD(1,GPT,ede98b7e-75ad-452e-ab47-3411dd60...
    Boot0003* Linux Firmware Updater	HD(1,GPT,ede98b7e-75ad-452e-ab47-...
    Boot0004* UEFI PM9A1 NVMe Samsung 1024GB S65VNE0R318841 1 2	PciRoot(0x0)/...
    Boot0005* Linux Boot Manager	HD(7,GPT,2d28b70f-725b-4ca3-98d4-25f5c83fc00e...
  \end{cverbatim}

  It shows you which disk you are currently booted into, the boot order that is currently configured, and information about each of the disks. 

  \subsection{Bootloaders}

    The \textbf{bootloader} is another critical piece of software that allows you to identify and load the proper operating system kernel. If it also provides an interactive menu with multiple boot choices, then it is often called a \textbf{boot manager}. The way that these kernels can be loaded can be configured through the bootloader, and the most popular boot manager is \textbf{GRUB}, the \textbf{Grand Unified Bootloader}. 

    GRUB, developed by the GNU project, is the default loader on most Linux distributions. There is an old version called GRUB legacy and the more modern GRUB 2. Most people refer to GRUB 2 and simply GRUB. FreeBSD, which is another complete (non-Linux) OS, have their own boot loader, but GRUB is compatible with it. Therefore, for dual-boot or triple-boot systems that have multiple kernels, GRUB is the go-to bootloader for loading any of them. 

    As a critical piece of software, we would expect its configuration files to be in the NVRAM, but GRUB understands most of the filesystems in common use and can find its way into the root filesystem on its own. Therefore, we can read its configuration from a regular text file, kept in \texttt{/boot/grub/grub.cfg}. Changing the boot configuration is as simple as updating the \texttt{grub.cfg} file. 


  \subsection{System Management Daemons and Systemd}

    A \textbf{process} is really any program that is running on your computer. A \textbf{daemon} is a background process that runs continuously, performing specific tasks even when no user is logged in. 

    Once the kernel has been loaded and completed its initialization process, it creates a collection of \textit{spontaneous} (as in the kernel starts them automatically) processes in user space. They're really part of the kernel implementation and don't necessarily correspond to programs in the filesystem. They're not configurable and they don't require administrative attention. These processes can be monitored with the commands \texttt{ps}, \texttt{top}, or \texttt{htop}.

    The most important process is the init process, with a system PID of 1 and with special privileges. It is used to get the system running and for starting other processes. 

    \begin{enumerate}
      \item Setting the name of the computer 
      \item Setting the time sone 
      \item Checking disks with \texttt{fsck} 
      \item Mounting filesystems 
      \item Removing old files from the \texttt{/tmp} directory 
      \item Configuring network interfaces
      \item Configuring packet filter 
      \item Starting up other daemons and network services, along with killing zombie processes or parenting orphaned processes. 
    \end{enumerate}

    There are three flavors of system management processes in widespread use: 
    \begin{enumerate}
      \item Historically, SysVinit was a series of plaintext files that ran as scripts to start processes, but due to some problems, Linux now uses systemd.
      \item An init variant that derives from the BSD UNIX, used on most BSD-based systems. 
      \item A more recent contender called \textbf{systemd} which aims to cover the init processes and much more. This significant increase in control causes some controversy. 
      \item Other flavors include Apple MacOS's \textbf{launchd} before it adopted systemd. Ubuntu also used \textbf{Upstart} before migrating to systemd. 
    \end{enumerate}

    Systemd is essentially a collection of smaller programs, services, and libraries such as systemctl, journalctl, init, process management, network management, login management, logs, etc. Some processes may depend on other processes, and with hundreds of them, it's very hard to do manually, which is why systemd does it all for you. A post on the systemd blog notes that a full build of the project generates 69 different binaries (subject to change). 

    \begin{definition}
      A \textbf{unit} is anything that is managed by systemd. It can be ``a service, a socket, a device, a mount point, an automount point, a swap file or partition, a startup carget, a watched filesystem path, a time controlled and supervised by systemd, a resource management slice, or a group of externally created processes." Within systemd, the behavior of each unit is defined and configured by a \textbf{unit file}. Within systemd, the behavior of each unit is defined and configured by a \textbf{unit file}. 

      The files are all over the place: 
        \begin{enumerate}
          \item \texttt{/lib/systemd/system} contains standard systemd unit files 
          \item \texttt{/usr/lib/systemd/system} are from locally installed packages, e.g. if I installed a pacman package that contained unit files, then those would go here. 
          \item \texttt{/etc/systemd/system} is where you put your custom files. etc also has the highest priority, so it overwrites the other files.  
          \item \texttt{/run/systemd/system} is a scratch area for transient units. 
        \end{enumerate}

      By convention, unit files are named with a suffix that varies according to the type of unit being configured. For example, service units have a \texttt{.service} suffix and timers user \texttt{.timer}. Within the unit file, some sections e.g. (\texttt{[Unit]}) apply generically to all kinds of units, but others (e.g. \texttt{[Service]}) can appear only in the context of a particular unit type. 

    \end{definition}

    \begin{example}[Service Unit File]
      If we go into one of these unit files, which have the prefix \texttt{.service}, they are usually formatted as such: 

      \begin{cverbatim}
        # comments are just the same as in bash Scripts
        # the headers are important! 

        [Unit]        #  
        Description=Description of the unit file 
        Documentation=man:something 
        After=network.target

        [Service]
        Type=forking  # tells that the process may exit and is not permanent
        PIDFile=      # 
        ExecStartPre= # scripts to run before you start 
        ExecStart=    # scripts to run when starting 
        ExecReload=   # script to run when you try to reload the process
        ExecStop=     # script to run to stop the process 

        [Install]   # Tells at what point should this be running
        WantedBy=multi-user.target 

      \end{cverbatim} 
    \end{example}
    
    \subsubsection{systemctl: Managing systemd} 

      \textbf{systemctl} is an all-purpose command for investigating the status of systemd and making changes to its configuration. Running \texttt{systemctl} without any arguments invokes the default \texttt{list-units} subcommand, which shows all loaded and activive services, sockets, targets, mounts, and devices. To show only services, use \texttt{--type=service}. 

      The two main commands that you will use to interact with systemd is \texttt{systemctl} and \texttt{journalctl}. 
      
      \begin{enumerate}
        \item \texttt{systemctl status unit} checks the status, ouputting the description, whether it's enabled/disabled, and whether it's active/inactive. 
        \item \texttt{systemctl enable unit} enables it, which means that it will start when booting the computer. It does this by creating a symlink to the unit file. This is different from start. 
        \item \texttt{systemctl disable unit} disables it. 
        \item \texttt{systemctl start unit} starts it now and runs it immediately. 
        \item \texttt{systemctl stop unit} makes it inactive. 
        \item \texttt{systemctl reload} will run whatever is in the \texttt{ExecReload} in the unit file. 
        \item \texttt{systemctl restart} runs ExecStop and then ExecStart. 
        \item \texttt{systemctl kill unit} kills the process. 
      \end{enumerate}

      Some of the statuses that you may see are inactive (deactivated, exited), active (activating, running), failed, static (not started, frozen by systemd), bad (broken, probably due to bad unit files), masked (ignored by systemd), indirect (disabled, but another unit file references it so it could be activated). 

      To troubleshoot, you should run \texttt{systemctl --failed} to see if there are any failed processes, which can be a problem, and then you can use \texttt{journalctl --since=today} to view your systemd logs. This log is important for diagnosing fundamental problems with your system. To view only entries logged at the error level or above, you can set the priorities with \texttt{-p err -b}. 

    \subsubsection{Targets}

      
    \subsubsection{Systemd Logging}

      The \textbf{journald} daemon allows you to capture log messages produced by the kernel and services. These system messages are stored in the \texttt{/run} directory, but we can access them directly with the \texttt{journalctl}  command. 

      \begin{example}
        
      \end{example}

      You can configure \textbf{journald} to retain messages from prior boots. To do this, edit the following file and configure the \texttt{Storage} attribute: 
      \begin{cverbatim}
      #/etc/systemd/journald.conf
        [Journal]
        Storage=persistent
      \end{cverbatim}

      Then, you can obtain a list of prior boots with \texttt{journalctl --list-boots} and you can access messages from a prior boot by referring to its index or by naming its long-form ID: \texttt{journalctl --b -1}. 

\section{LaTeX and VimTex} 

  Latex is a great way to take notes. One can go to Overleaf and have everything preconfigured, but in here I set it up on my local desktop. I will already assume you have a PDF viewer installed. I use zathura, which is lightweight and also comes with vim motions for navigation. 

  First install the VimTex plugin in \texttt{plugins.lua} with \texttt{use lervag/vimtex}. Then, you want to install TexLive, which is needed to compile tex files and to manage packages. The directions for TexLive installation is available [here](https://tug.org/texlive/quickinstall.html). Once I downloaded the install files, I like to run \texttt{sudo perl ./install-tl --scheme=small}. Be careful with the server location (which can be set with the \texttt{--location} parameter), as I have gotten some errors. I set \texttt{--scheme=small}, which installs about 350 packages compared to the default scheme, which installs about 5000 packages (~7GB). I also did not set \texttt{--no-interaction} since I want to slightly modify the \texttt{--texuserdir} to some other path rather than just my home directory. 

  Once you installed everything, make sure to add the binaries to PATH, which will allow you to access the \textbf{tlmgr} package manager, which pulls from the CTAN (Comprehensive TeX Archive Network) and gives VimTex access to these executables. Unfortunately, the small scheme installation does not also install the \textbf{latexmk} compiler, which is recommended by VimTex. We can simply install this by running 
  ```
  sudo tlmgr install latexmk
  ```
  Now run `:checkhealth` in Neovim and make sure that everything is OK, and install whatever else is needed. 


  To install other Latex packages (and even document classes), we can use tlmgr. All the binaries and packages are located in \texttt{/usr/loca/texlive/202*/} and since we're modifying this, we should run it with root privileges. The binaries can also be found here. Let's go through some basic commands: 
  \begin{enumerate}
    \item List all available packages: \texttt{tlmgr list}
    \item List installed packages: \texttt{tlmgr list --only-installed} (the packages with the `i` next to them are installed)
    \item Install a package and dependencies: \texttt{sudo tlmgr install amsmath tikz} 
    \item Reinstall a package: \texttt{sudo tlmgr install amsmath --reinstall}
    \item Remove a package: \texttt{sudo tlmgr remove amsmath} 
  More commands can be found \href{http://tug.ctan.org/info/tlmgrbasics/doc/tlmgr.pdf}{here} for future reference.  
  \end{enumerate}

  After this, you can install Inkscape, which is free vector-based graphics editor (like Adobe Illustrator). It is great for drawing diagrams, and you can generate custom keymaps that automatically open Inkscape for drawing diagrams within LaTeX, allowing for an seamless note-taking experience.  
    
\section{Networking}

  Networking is a large field in itself, but in here I go over the most useful and practical applications of it in my everyday use. Some ways that I personally benefit from this is:

  \begin{enumerate}
    \item Connecting to WiFi and diagnosing problems.  
    \item Connecting to WiFi and diagnosing problems. 
    \item Connecting to other networks such as computing clusters or third-party blockchains.  
    \item Seeing how more abstract schemes such as APIs work. 
    \item Ethical hacking. 
  \end{enumerate}
  I introduce these concepts and how to do some basic implementation a Unix operating system.

  I like to learn about networking as if I am designing it from scratch. Some big questions to ask when designing network schemes are:

  \begin{enumerate}
    \item How do we uniquely identify computers? 
    \item How should we establish a connection between them? Through hardware or signals? 
    \item What protocols should we use, like a common language, so that all computers understand what each other are saying? 
    \item Can we implement security measures to prevent unwanted visitors into our computer? 
  \end{enumerate} 

  \subsection{Computer Networks and the Internet}

    Let us first define a computer network, some of its architecture, and then move onto the Internet. 

    \begin{definition}[Computer Network]
      A \textbf{computer network} is a group of computers (i.e. computing devices) that use a set of common \textit{communication protocols} over digital interconnections for the purpose of sharing resources located on or provided by the \textit{network nodes}, which may include personal computers, servers, networking hardware, or other specialised or general-purpose hosts. 

    \end{definition}

    These network nodes may be able to communicate to certain neighboring nodes, and this graph architecture determines the \textbf{network topology}. A computer network can be visualized as a connected graph of nodes 

    \begin{example}[Network Topologies]
      Common layouts are: 

      \begin{enumerate}
        \item \textbf{Line Network}: All nodes are connected in a line. 

        \begin{center}\resizebox{8cm}{0.64cm}{%
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}, scale=0.7]
            \node[main node] (A) {A};
            \node[main node] (B) [right of=A] {B};
            \node[main node] (C) [right of=B] {C};
            \node[main node] (D) [right of=C] {D};
            \path[every node/.style={font=\sffamily\small}]
            (A) edge node {} (B)
            (B) edge node {} (C)
            (C) edge node {} (D);
        \end{tikzpicture}}
        \end{center}

          \item \textbf{Bus Network}: All nodes are connected to a common medium along this medium. 

        \item \textbf{Star Network}: all nodes are connected to a special central node.
          \begin{center}
          \resizebox{3cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (F) [left of=A] {F};
              \node[main node] (G) [above left of=A] {G};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (I) [above right of=A] {I};
              \path[every node/.style={font=\sffamily\small}]
              (A) edge node {} (B)
              (A) edge node {} (C)
              (A) edge node {} (D)
              (A) edge node {} (E)
              (A) edge node {} (F)
              (A) edge node {} (G)
              (A) edge node {} (H)
              (A) edge node {} (I);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Ring Network}: Each node is connected to its left and right neighbour node, such that all nodes are connected and that each node can reach each other node by traversing nodes left- or rightwards.
          \begin{center}
          \resizebox{3cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \draw[white, fill=white] (-1,-1) rectangle (1,1);
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (F) [left of=A] {F};
              \node[main node] (G) [above left of=A] {G};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (I) [above right of=A] {I};
              \path[every node/.style={font=\sffamily\small}]
              (B) edge node {} (C)
              (C) edge node {} (D)
              (D) edge node {} (E)
              (E) edge node {} (F)
              (F) edge node {} (G)
              (G) edge node {} (H)
              (H) edge node {} (I)
              (I) edge node {} (B);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Mesh Network}: each node is connected to an arbitrary number of neighbours in such a way that there is at least one traversal from any node to any other. 
          \begin{center}
          \resizebox{3.5cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \draw[white, fill=white] (-1,-1) rectangle (1,1);
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (F) [right of=C] {F};
              \path[every node/.style={font=\sffamily\small}]
              (B) edge node {} (C)
              (B) edge node {} (H)
              (D) edge node {} (C)
              (D) edge node {} (E)
              (C) edge node {} (F)
              (E) edge node {} (H)
              (H) edge node {} (D);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Fully Connected Network}: each node is connected to every other node in the network.
          \begin{center}
          \resizebox{3cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \draw[white, fill=white] (-1,-1) rectangle (1,1);
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (F) [left of=A] {F};
              \node[main node] (G) [above left of=A] {G};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (I) [above right of=A] {I};
              \path[every node/.style={font=\sffamily\small}]
              (B) edge node {} (C)
              (B) edge node {} (D)
              (B) edge node {} (E)
              (B) edge node {} (F)
              (B) edge node {} (G)
              (B) edge node {} (H)
              (B) edge node {} (I)
              (C) edge node {} (D)
              (C) edge node {} (E)
              (C) edge node {} (F)
              (C) edge node {} (G)
              (C) edge node {} (H)
              (C) edge node {} (I)
              (D) edge node {} (E)
              (D) edge node {} (F)
              (D) edge node {} (G)
              (D) edge node {} (H)
              (D) edge node {} (I)
              (E) edge node {} (F)
              (E) edge node {} (G)
              (E) edge node {} (H)
              (E) edge node {} (I)
              (F) edge node {} (G)
              (F) edge node {} (H)
              (F) edge node {} (I)
              (G) edge node {} (H)
              (G) edge node {} (I)
              (H) edge node {} (I);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Tree Network}: nodes are arranged hierarchically.
          \begin{center}
          \resizebox{5cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \node[main node] (B) [above right of=A] {B};
              \node[main node] (C) [above left of=A] {C};
              \node[main node] (D) [above left of=C] {D};
              \node[main node] (E) [above right of=B] {E};
              \node[main node] (F) [above left of=B] {F};
              \path[every node/.style={font=\sffamily\small}]
              (A) edge node {} (B)
              (A) edge node {} (C)
              (B) edge node {} (F)
              (B) edge node {} (E)
              (C) edge node {} (D);
          \end{tikzpicture}}
          \end{center}
      \end{enumerate} 
    \end{example}

    Notice how many of these networks have \textbf{redundancy}: having multiple ways to get from one node to another. That is, when a network path is no longer available, data is still able to reach its destination through another path. Usually, we would like to avoid a \textbf{single point of failure} and construct a \textbf{fault-tolerant} system that can experience failure in its components but still continue operating properly. However, building more connections may be expensive. 

    Because there are multiple paths that a piece of data takes to get from point X to point Y, \textit{routing strategies} are implemented in order to determine the most optimal path. Now in order for network nodes to communicate with each other, they should have some sort of universal method of communicating with each other. 

    \begin{definition}[Communication Protocol]
      A \textbf{communication protocol} is a system of rules that allow multiple entities of a communications to transmit information via any kind variation of a physical quantity. The protocol defines the rules, syntax, semantics and synchronization of communication and possible error recovery methods. A protocol can have many jobs, such as: 
      
      \begin{enumerate} 
        \item Determining how nodes will communicate with each other . 
        \item Making sure that these modes of communication is compatible with hardware .
        \item Implementing security protocols such as encryption schemes. 
      \end{enumerate}
    \end{definition}

    Computers can connect through \textbf{physical} (e.g. cables) or \textbf{wireless} connections. 

    \begin{enumerate}
      \item The \textbf{CAT5 cable} is a \textit{twisted pair (copper) cable} that's designed for use in computer networks. It consists of four twisted pairs of copper wires. These twisted pair cables send data through a network by transmitting pulses of electricity that represent binary data. The information transmission follow the \textbf{Ethernet} standards, which is why twisted pair cables are commonly known as Ethernet cables. Use for both LANs and WANs. They can carry up to 1 Gbps across hundreds of feet, but are susceptible to interference. 

      \item \textbf{Fiber-optic cables} carry light instead of electricity in a fiber coated with plastic layers. The pulses of light represent binary data and also follow the Ethernet standards. They are also capable of transmitting much more data per second that copper cables, and they have the advantage of low transmission loss and immunity to electrical interference. Often used to connect networks across oceans so that data can travel quickly around the world. They can carry up to 26 Tbps acorss 50 miles (but are expensive)

      \item A wireless card inside a computer turns binary data into \textbf{radio waves} and transmits them through the air. However, they do not travel very far (~100 ft in office buildings or up to 1000 ft in an open field). The waves are picked up by a \textit{wireless access point} which converts them from radio waves back into binary data. These access points would be connected to the rest of the network using physical wiring. They can carry up to 1.3 Gbps. 

      \item \textbf{Infrared signals} and \textbf{microwaves} are sometimes used. 
    \end{enumerate}


    In order for the computers to send data into binary, they must convert this data into binary and send them as streams of 1s and 0s in a process called \textbf{line coding}. Furthermore, computers can raise efficiency of each wire by sending changing electric currents through a single wire. For example, rather than using three wires to encode $\texttt{101}$ as 

    \begin{center}
      \begin{tikzpicture}[scale=0.6]
        \draw[thick, red] (0,1)--(9,1);
        \draw[thick] (0,0)--(9,0);
        \draw[thick, red] (0,-1)--(9,-1);
        \node[right] at (9,1) {1};
        \node[right] at (9,0) {0}; 
        \node[right] at (9,-1) {1};
      \end{tikzpicture}
    \end{center}

    they send it through a single wire with intervals of $\frac{1}{3}$ seconds

    \begin{center}
      \begin{tikzpicture}[scale=0.6]
        \draw[thick, red] (0,0)--(3,0);
        \draw[thick] (3,0)--(6,0);
        \draw[thick, red] (6,0)--(9,0);
        \node[right] at (9,0) {1 0 1};
      \end{tikzpicture}
    \end{center}

    or even better, at a rate of 1 megabit per second (interval of $0.000001$ seconds)

    \begin{center}
      \begin{tikzpicture}[scale=0.8]
        \draw[thick, red] (0,0)--(3,0);
        \draw[thick] (3,0)--(6,0);
        \draw[thick, red] (6,0)--(9,0);
        \draw[fill] (0,0) circle (0.05);
        \draw[fill] (3,0) circle (0.05);
        \draw[fill] (6,0) circle (0.05);
        \draw[fill] (9,0) circle (0.05);
        \node[below] at (0,0) {.000000s};
        \node[below] at (3,0) {.000001s};
        \node[below] at (6,0) {.000002s};
        \node[below] at (9,0) {.000003s};
      \end{tikzpicture}
    \end{center}

    As long as two computers agree on the time period in which the electricity intervals are being sent, they can communicate much more efficiently. In an electrical connection (such as Ethernet), the signal would be a voltage or current. In an optical connection (such as a fiber-optic cable), the signal would be the intensity of light. 

    \begin{definition}
      There are many properties about line coding that are relevant, but ultimately the speed of a connection is a combination of the bandwidth and latency. 

      \begin{enumerate}
        \item The \textbf{bit rate} describes the data transfer rate of a connection. It measures the number of bit states that a channel can \textit{transmit} per unit time. It is measured in \textit{bits per second}. We can interpret it as the amount of water flowing through a pipe. 
        
        Bit rate is typically seen in terms of the actual data rate. But for most transmissions, the data represents part of a more complex protocol, which includes bits representing source address, destination address, error detection/correction codes, and other information. This data is called the \textbf{overhead}, while the actual data transferred is called the \textbf{payload}. At times, the overhead may be substantial (up to 20\% to 50\%). 

        \item The \textbf{throughput} is the number of bit states of usable information, that can be successfully \textit{received} over a channel per unit time. Without any channel noise, it is really just the payload. Note that this is an \textit{observed, dynamic parameter} with a fixed and variable loss. It is also known as \textbf{consumed bandwidth} and is measured in \textit{bits per second}. 
        
        \item The \textbf{bandwidth} describes the \textit{maximum} data transfer rate of a connection; that is, the maximum throughput of a communication. It is measured in \textit{bits per second}. We can interpret it as how thick the pipe is (i.e. how much water can flow through it at max). Note that this is different from the bandwidth used in signal processing. 
        
        Data often flows over multiple network connections, which means the connection with the smallest bandwidth (most likely your local connection) acts as a bottleneck. 
        
        \item The \textbf{latency}, or \textbf{ping-rate}, measures the round trip time between the sending of a data message to a computer and the receiving of that message, measured in \textit{milliseconds}. We can interpret it as the speed at which the water is flowing through a pipe. We can check latency by doing
        \begin{cverbatim}
          >>>ping www.google.com
          64 bytes: icmp_seq=0 ttl=115 time=37.868 ms
        \end{cverbatim}

        which outputs a latency time of 37.868ms (to get to $\texttt{www.google.com}$ and back) for sending a data packet of 64 bytes. Note that there is an intrinsic limiting factor to latency: the speed of light, which is approximately 1 foot per nanosecond. In addition to distance, another limiting factor is the congestion in the network and the type of connection. 
      \end{enumerate}
    \end{definition}

    \begin{example}
    Given two computers connected by a wire that is configured to transfer 1000 bits per second, the bit rate would be 1 Kbps. However, if the channel has noise and demands retransmission of 10 bits out of every 1000 of the original transmission, then the throughput would be 990 bps. 

    Furthermore, the Ethernet frame can have as many as 1542 bytes. Say that there are 1500 bytes of payload and an overhead of 42 bytes. Then, the \textbf{protocol efficiency} would would be 
    \[\frac{\text{payload}}{\text{frame size}} = \frac{1500}{1542} = 0.9727 = 97.3\%\]
    \end{example}

    Typically, the actual line rate is stepped up by a factor influenced by the overhead to achieve an actual target net data rate. In One Gigabit Ethernet, the actual line rate is 1.25 Gbits/s to achieve a net payload throughput of 1 Gbit/s. In a 10-Gbit/s Ethernet system, gross data rate equals 10.3125 Gbits/s to achieve a true data rate of 10 Gbits/s. The net data rate also is referred to as the throughput, or payload rate, of effective data rate.

  \subsection{History of the Internet}

    IETF, ICANN, IANA, ISPs.  

    \begin{example}[ARPANET]
      The ARPANET was the precursor to the Internet, the network where Internet technology was first tested out. It was started in 1969 with four computers connected to each other. 

        \begin{center}\resizebox{5cm}{3cm}{%
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
            \node[main node] (UCLA) {UCLA};
            \node[main node] (UCSB) [left of=UCLA] {UCSB};
            \node[main node] (SRI) [above left of=UCLA] {SRI};
            \node[main node] (UTAH) [above right of=UCLA] {UTAH};
            \path[every node/.style={font=\sffamily\small}]
            (UCLA) edge node {} (UCSB)
            (UCLA) edge node {} (SRI)
            (UCSB) edge node {} (SRI)
            (SRI) edge node {} (UTAH);
        \end{tikzpicture}}
        \end{center}

      For example, even if the path between SRI and UCSB is gone, the connections between SRI and UCSB is not lost (since IP packets can travel through UCLA's router). 
    \end{example}


    Now we can see an implementation of these networks in the internet. 

    \begin{definition}[Internet]
      The \textbf{Internet} is a global network of computing devices communicating with each other in some way, whether they're sending emails, downloading files, or sharing websites. The Internet is an \textbf{open network}, which means that any computing device can join as long as they follow the protocols. The internet is powered by many layers of protocols, and to create a global network of computing devices, we need: 

      \begin{enumerate}
        \item \textbf{Wires \& Wireless}: Physical connections between devices, plus protocols for converting electromagnetic signals into binary data. 
        \item \textbf{IP}: A protocol that uniquely identifies devices using IP addresses and provides a routing strategy to send data to a destination IP address. 
        \item \textbf{TCP/UDP}: Protocols that can transport packets of data from one device to another and check for errors along the way. 
        \item \textbf{TLS}: A secure protocol for sending encrypted data so that attackers can't view private information. 
        \item \textbf{HTTP \& DNS}: The protocols powering the World Wide Web
      \end{enumerate}        
    \end{definition}

    An \textbf{ISP (Internet Service Provider)} provides internet to its region. These ISPs are managed by certain continental autonomous systems (\textbf{AS}). The \textbf{Regional Internet Registry (RIR)} is divided into their regions: AFRNIC (Africa), ARIN (American), APNIC (Asia-Pacific), LACNIC (Latin America and Carribean), and RIPE NCC (European). 

    The main protocol suite used by the internet is \textbf{TCP/IP}, which is a collection of protocols that the internet uses. The bulk of this chapter will describe this protocol. 

    \begin{figure}[hbt!]
      \centering
      \includegraphics[scale=0.7]{img/tcp_ip_model.png}
      \caption{TCP/IP layering model. }
      \label{fig:tcp_ip_model}
    \end{figure}

  \subsection{Network Interfaces}

    Before we even start talking about IP addresses or protocols, we should mention that there are several interfaces from which computers can send and receive data. For example, if you are connected to both wired ethernet and WiFi, there are two paths, or interfaces, that data can travel. To see all your interfaces, use the \texttt{ip -c a} command. 

    \begin{cverbatim} 
      1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default  
          link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
          inet 127.0.0.1/8 scope host lo
             valid_lft forever preferred_lft forever
          inet6 ::1/128 scope host noprefixroute 
             valid_lft forever preferred_lft forever
      2: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group 
          link/ether 64:bc:58:11:c0:24 brd ff:ff:ff:ff:ff:ff
          inet 10.197.221.245/16 brd 10.197.255.255 scope global dynamic noprefixroute 
             valid_lft 597085sec preferred_lft 597085sec
          inet6 fe80::b9e9:2f85:ded7:eaaf/64 scope link noprefixroute 
             valid_lft forever preferred_lft forever
    \end{cverbatim}

    The following lists out all the interfaces. We can see that we're connected to two interfaces, but there are a lot more. Usually, these interfaces also have a number following them that indexes different instances of the same type of interface. 

    \begin{enumerate} 
      \item \textbf{lo}: This is the loopback interface. 
      \item \textbf{wlan0}: For wireless connections 
      \item \textbf{tun}: When you are connected to VPN. 
      \item \textbf{en}: 
      \item \textbf{gif}: 
      \item \textbf{awd}: 
      \item \textbf{llw}: 
      \item \textbf{bridge}: 
      \item \textbf{utun}: 
    \end{enumerate}

    For each interface, there is a set of protocols that must be set for data to transfer. 

  \subsection{Addresses}

    Every computer needs some address that determines its unique identity. The version of TCP/IP that has been in widespread use is IPv4, which uses 4-byte IP addresses. A modernized version, IPv6, expands the IP address space to 16 bytes and incorporates several additional features, making it faster and easier to implement. 

    \begin{definition}[IP Address]
      The protocol describes the use of \textbf{IP addresses} to uniquely identify Internet-connected devices (for transmission of data). That is, when a computer sends a message to another computer, it must specify the recipient's IP address and also include its own IP address so that the second computer can reply. There are two versions of the Internet Protocol in use today: 
      \begin{enumerate}
          \item \textbf{IPv4}: The first version ever used on the Internet and having the form of 4 \textit{octets} split by periods in between. 

            \[[0-255].[0-255].[0-255].[0-255]\]

          Even though it presented in decimal, computers store them in binary 

            \[74.125.20.113 \iff 01001011.01111101.00010100.01110001\]

          IPv4 addresses can take $2^{32}$ values, but IPv6 was created for more space.

          \item \textbf{IPv6}: The newer standard (introduced in June 2012) is in the form 

            \[\text{FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF}\]

          with hexadecimal digits (total of ~$3.4 \times 10^{39}$ possible IPv6 values). 
      \end{enumerate}
    \end{definition}


    \begin{definition}[CIDR Notation]
      Sometimes, a set of IP addresses are specified using \textbf{CIDR notation}. An address of the form 

        \[145.201.67.4/16\]

      represents all addresses of form $145.201.\ast.\ast$. 
    \end{definition}

    Operating systems and network devices have supported IPv6 for a long time, and the motivation behind the deployment of IPv6 was due to the concern that devices were running out of IPv4 addresses. Asia ran out first in 2011, followed by every other continent ever since then. 

    But we've learned to make more efficient use of the IPv4 addresses that we have. For example, \textbf{Network Address Translation} (or \textbf{NAT}) lets entire networks of machines hide behind single IPv4 addresses. \textbf{Classless Inter-Domain Routing} (\textbf{CIDR}) subdivides networks and promotes efficient backbone routing as well. Ultimately, IPv6, with better security and engineering, is going to take over, but not for a while since it's not fundamentally different from IPv4 and the drawbacks of IPv4 haven't been bad enough to spark migration. 

    \begin{definition}[Hierarchy of IP Addresses] 
      The IP addresses are formatted in an \textit{hierarchical way}. The IPv4 address hierarchy is structured as such: The first few numbers (may or may not be divided by octets) could identify a \textbf{network} administered by an Internet Service Provider. The last numbers, which can also represent \textbf{subnetworks} (subnets), identifies a home computer on that network. 
    \end{definition}

    \begin{example}[University of Michigan]
      For example, if we represent the IP address 141.213.127.13 in binary (of 32 bits)

        \[10001101.11010101.01111111.00001101\]

      the first 16 bits could route to all of UMich, the next two bits could route to a specific UMich department, and the final 14 bits could route to individual computers. 
      \begin{center}
      \begin{tabular}{l|l|l}
          1000110111010101 & 01 & 11111100001101  \\
          \hline
          UMich Network & Medicine department & Lab computer 
      \end{tabular}
      \end{center}
      This hierarchy gives UMich the ability to differentiate between $2^2$ departments and $2^{14} = 16,384$ computers within each department. In general, the ability to create hierarchical levels at any point in the IP address allows for greater flexibility in the size of each level of the hierarchy. 
    \end{example}
    
    \begin{example}[Duke]
      Duke's IP addresses are of the form $153.3.\_.\_$, with the DUKE-INTERCHANGE ISP provider.  
    \end{example} 

    \begin{definition}[Hostname]
      IP addresses can be quite cumbersome to memorize, which is why they are often addressed with their \textbf{hostname}. Operating systems allow one or more hostnames to be associated with an IP address so that users can type \texttt{rfc-editor.org} rather than $4.31.198.49$. This mapping can be set up  in multiple days, e.g. with the \texttt{/etc/hosts} file or the LDAP database system to DNS the world-wide \textbf{Domain Name System}. 
    \end{definition}

    \subsubsection{LAN Addresses and NAT} 

      We've talked about how entire networks of machines can hide behind a single IPv4 address. Let's elaborate on this. In fact, your computer is not connected to the internet directly. It is actually in a \textbf{private network}, or a \textit{LAN network}, which uses a private IP address space (supported by both IPv4 and v6). Anything on the inside of your private network is not on the Internet; it is on your LAN, an entirely separate network, with its own address space. Anything on your LAN must have a unique (within the LAN) IP address to participate properly with your local network. Therefore, anyone else who has a LAN is also not part of the internet. So if you are only on your LAN network, how do you actually connect to the internet? 

      \begin{definition}[Router] 
        The \textbf{router} is a device that forms a connection between your LAN network and the internet. It has both a private local address, called a \textbf{gateway address}, and a public address. It is responsible for forwarding data between the local server computers and the internet. Therefore, to the outside world, all devices identify the network internet activity by the one public IP address assigned to the router. 

        The gateway address can be found with \texttt{ip route} and the public address, of course, can be found with the commands previously mentioned. 
      \end{definition}

      \begin{definition}[Modem]
        A \textbf{modem}, short for \textbf{modulator/demodulator} is a device that converts a signal from your computer to some kind of signal to talk to other computers. The main difference between the router and the modem is that 
        \begin{enumerate} 
           \item The router crates a network between the computers in your home and routes network traffic between them (through Ethernet cables or wireless connection). Your home router has one connection to the Internet and connections to your private local network. 

          \item The modem serves as a bridge between your local network and the Internet.  
        \end{enumerate}
      \end{definition}

      To access our IP address, we can do the following: 
      \begin{enumerate} 
        \item To access local ip address, we can either run the command \texttt{hostname -i}, \texttt{ip -c a}, or \texttt{ifconfig}.
          
        \item To access the public ip address, we can either google it or run \texttt{curl ifconfig.me}. Since this is public, any device connected to the same network/router should have the same IP address. 
      \end{enumerate}

      \begin{definition}[NAT]
        In order for LAN devices to connect to the Internet, their outgoing traffic has the source address changed to match that of the internet/WAN IP address of the router. The router keeps track of this, and makes sure any response traffic gets sent to the right internal machine. This is called \textbf{Network Address Translation (NAT)}. There are generally two types of NAT: 

        \begin{enumerate}
          \item \textbf{Basic, one-to-one NAT}: The simplest type of NAT provides a one-to-one translation of IP addresses. In this type of NAT, only the IP addresses, IP header checksum, and any higher-level checksums that include the IP address are changed. Basic NAT can be used to interconnect two IP networks that have incompatible addressing. 

          \item \textbf{One-to-many NAT}: The majority of network address translators map multiple private hosts to one publicly exposed IP address. In a typical configuration, a local network uses one of the designated private IP address subnets. A router in that network has a private address of that address pace. The router it also connected to the Internet with a \textit{public} address assigned by the ISP. As traffic passes from the local network to the Internet, the source address in each packet is translated on the fly from a private address to the public address. The router tracks basic data about each active connection (particularly the destination address and port). When a reply returns to the router, it uses the connection tracking data it stored during the outbound phase to determine the private address on the internal network to which to forward the reply. 
        \end{enumerate}
      \end{definition}

      \begin{definition}
        The IP addresses that are in the private network's space are usually divided up into 3 categories. But as of now, the categories don't mean anything. 

        \begin{enumerate}
          \item \textbf{Class A private range addresses}: 10.0.0.0 - 10.255.255.255 (16,777,216 IPs)
          \item \textbf{Class B private range addresses}: 172.16.0.0 – 172.31.255.255 (1,048,576 IPs)
          \item \textbf{Class C private range addresses}: 192.168.0.0 – 192.168.255.255 (65,536 IPs)
        \end{enumerate}

        Since the private IPv4 address space is relatively small, many private IPv4 networks unavoidably use the same address ranges. This can create a problem when merging such networks, as some addresses may be duplicated for multiple devices. In this case, networks or hosts must be renumbered, often a time-consuming task, or a network address translator must be placed between the networks to translate or masquerade one of the address ranges. 
      \end{definition}


    \subsubsection{Ports}

      IP addresses identify a machine's network interfaces, but they aren't specific enough to address individual processes or services, many of which might be actively using the network at once. TCP and UDP extend IP addresses with a concept known as a port, which is a 16-bit number that supplements an IP address to a particular communication channel. Valid ports range from $1$ to $65,535$. A port, combined with an IP address, results in a \textbf{socket address} that is used to establish a connection between a client and a server. 

      UNIX systems restrict programs from binding to port numbers under 1024 unless they are run as root or have an appropriate Linux capability. Anyone can communicate with a server running on a low port number; the restriction only applies to the program listening on the port.

    \subsubsection{Hardware (MAC) Addresses}

      The lowest level of addressing is the network hardware. Many devices are assigned a unique 6-byte hardware address at the time of manufacture. The first 3 bytes identify the manufacturer, and the last 3 bytes are a unique serial number that the manufacturer assigns. Sysadmins can sometimes identify the brand of machine that is trashing a network by looking up the 3-byte identifier in a table of vendor IDs. In theory, ethernet hardware addresses are permanently assigned and immutable, but many network interfaces let you override the hardware address and set one of your own choosing. 

  \subsection{TCP Packets and Encapsulation}

  \subsection{OSI and Internet Protocols}
  

  \subsection{HTTP and HTTPS} 

    HTTP stands for hypertext transfer protocol, implemented in Layer 7, which transfers data between your computer and the server over the internet through \textbf{clear text}. This may not be the most ideal way since any interceptors can read the transferred data. This isn't a problem for regular internet browsing, but if you are inputting sensitive data, then HTTP should not be used. This is why HTTPS (which stands for secure HTTP) was invented, which  is implemented in Layer 4 and encrypts the data being transferred, and every website where you input sensitive data should be using HTTPS (indicated by the \texttt{https://} prefix in the URL and a padlock symbol for modern browsers). Due to the extra security measures, HTTPS is less lightweight than HTTP, and its respective default ports are HTTP (80) and HTTPS (443).  

    A natural question to ask would be: which encryption scheme does HTTPS use? Both Secure Sockets Layer (SSL) and Transport Layer Security (TLS) is used in the modern web. 

    SSL certificate. 

    
  \subsection{UDP and TCP}

    TCP handshake can be seen with curl. 

  \subsection{SSH}


\section{Driver and Hardware Configuration}

  \subsection{Audio Drivers} 


  \subsection{Bluetooth}
    Blueman. 

  \subsection{Synaptics}


  \subsection{Video Drivers}


  \subsection{Monitor}


  \subsection{Nvidia GPU Drivers} 


\section{Development}

  \subsection{Git} 
    


  \subsection{Python and Conda}

    Make sure to add conda path to PATH. 

\end{document}


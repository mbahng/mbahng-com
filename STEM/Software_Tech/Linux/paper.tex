\documentclass{article}
  % preamble
  \usepackage[letterpaper, top=1in, bottom=1in, left=1in, right=1in]{geometry}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{amsmath, amssymb, amsthm, mathtools} % necessary
  \usepackage{lastpage} % insert last page number
  \usepackage{centernot} % for not slash

  \usepackage{circuitikz}
  \usepackage{tikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{positioning,calc}

  \usepackage{pgfplots}
  \pgfplotsset{compat=1.18}
  \usepackage{hyperref} % hyperlinks
  \usepackage{fancyhdr} % fancy headers
  \usepackage{fancyvrb} % verbatim
  \usepackage{parskip}

  \usepackage{subcaption} % captions for figures
  \definecolor{cverbbg}{gray}{0.93}

  \setlength{\parindent}{0pt} % set no indent
  \hfuzz=5.002pt % ignore overfull hbox badness warnings below this limit

  \DeclareMathOperator{\Tr}{Tr}
  \DeclareMathOperator{\Sym}{Sym}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\std}{std}
  \DeclareMathOperator{\Cov}{Cov}
  \DeclareMathOperator{\Var}{Var}
  \DeclareMathOperator{\Corr}{Corr}
  \DeclareMathOperator*{\argmin}{\arg\!\min}
  \DeclareMathOperator*{\argmax}{\arg\!\max}
  \newenvironment{question}{\color{blue}}{\ignorespacesafterend}

  \newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
  \newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
  \newcommand{\bracket}[2]{\langle #1 | #2 \rangle}

  \theoremstyle{definition}
  \newtheorem{theorem}{Theorem}[section]
  \newtheorem{proposition}[theorem]{Proposition}
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{example}{Example}[section]
  \newtheorem{exercise}{Exercise}[section]
  \newtheorem{corollary}{Corollary}[theorem]
  \newtheorem{definition}{Definition}[section]
  \renewcommand{\qed}{\hfill$\blacksquare$}
  \renewcommand{\footrulewidth}{0.4pt}% default is 0pt

  \newenvironment{solution}{\noindent \textit{Solution.}}{}
  \newenvironment{cverbatim}
    {\SaveVerbatim{cverb}}
    {\endSaveVerbatim
    \flushleft\fboxrule=0pt\fboxsep=.5em
    \colorbox{cverbbg}{%
      \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
    }
    \endflushleft
  }

  \renewcommand{\thispagestyle}[1]{} % needed for including header in title page

\begin{document}
\pagestyle{fancy}

\lhead{Linux}
\chead{Muchang Bahng}
\rhead{\date{Summer 2023}}
\cfoot{\thepage / \pageref{LastPage}}

\title{Linux}
\author{Muchang Bahng}
\date{January 2024}

\maketitle

\tableofcontents

\pagebreak 

The following set of notes describes the everyday use of a Linux operating system. I refer to it for mainly my personal desktop, but it is also useful for working in computing clusters. Some of the commands are specific to the Arch Linux distribution (since that is what I work with), but I occasionally include those from Ubuntu and Red Hat, since I run into these distributions often in servers. 

I try to organize this in a way so that one who wishes to get started in Linux can go through these notes chronologically. For now, we will assume that you have a Linux distribution installed. There are many resources beyond this book that helps you do that. 
 
\section{Hardware} 

  \subsection{Von Neumann Architecture}

    It is essential to have an initial model of a computer. For this, we will first use the \textbf{von Neumann architecture}, which is the basis for most computers today. It consists of a \textbf{central processing unit} (CPU), \textbf{memory}, and an \textbf{input/output} (I/O) system.

    \begin{definition}[Memory]
      The memory is where the computer stores data and instructions, which can be though of as a giant array of memory addresses, with each containing a byte. This data consists of graphical things or even instructions to manipulate other data.
    \end{definition}

    \begin{definition}[Central Processing Unit]
      The CPU is responsible for taking instructions (data) from memory and executing them. 
      \begin{enumerate} 
        \item The CPU is composed of \textbf{registers} (different from the cache), which are small, fast storage locations. These registers can either be \textbf{general purpose} (can be used with most instructions) or \textbf{special purpose} (can be accessed through special instructions, or have special meanings/uses, or are simply faster when used in a specific way).
        \item The CPU also has an \textbf{arithmetic unit} and \textbf{logic unit}, which is responsible for performing arithmetic and logical operations. 
        \item The CPU also has a \textbf{control unit}, which is responsible for fetching instructions from memory through the \textbf{databus}, which is literally a wire connecting the CPU and RAM, and executing them. 
      \end{enumerate}
      It executes instructions from memory one at a time and executes them, known as the \textbf{fetch-execute cycle}. It consists of 4 main operations. 
      \begin{enumerate} 
        \item \textbf{Fetch}: The \textbf{program counter}, which holds the memory address of the next instruction to be executed, tells the control unit to fetch the instruction from memory through the databus. 
        \item \textbf{Decode}: The fetched data is passed to the \textbf{instruction decoder}, which figures out what the instruction is and what it does and stores them in the registers.
        \item \textbf{Execute}: The arithmetic and logic unit then carries out these operations. 
        \item \textbf{Store}: Then it puts the results back on the databus, and stores them back into memory.
      \end{enumerate} 
      The CPU's \textbf{clock cycle} is the time it takes for the CPU to execute one instruction. More specifically, the clock cycle refers to a single oscillation of the clock signal that synchronizes the operations of the processor and the memory (e.g. fetch, decode, execute, store), and decent computers have clock cycles of at least $2.60$GHz (2.6 billion clock cycles per second). 
    \end{definition}

    To clarify, let us compare registers and memory. Memory is addressed by an unsigned integer while registers have names like \texttt{\%rsi}. Memory is much bigger at several GB, while the total register space is much smaller at around 128 bytes (may differ depending on the architecture). The memory is much slower than registers, which is usually on a sub-nanosecond timescale. The memory is dynamic and can grow as needed while the registers are static and cannot grow.


    \begin{definition}[Input/Output Device]
      The input device can read/load/write/store data from the outside world. The output device, which has \textbf{direct memory address}, can display data to the outside world. 
    \end{definition}

    Putting this all together, we have Figure \ref{fig:von_neumann_arch}. 

    \begin{figure}[hbt!]
      \centering 
      \includegraphics[scale=0.4]{img/von_neumann_arch.png}
      \caption{von Neumann Architecture} 
      \label{fig:von_neumann_arch}
    \end{figure}

  \subsection{Instruction Set Architectures} 

    \begin{definition}[Instruction Set Architecture]
      The \textbf{ISA} or just \textbf{architecture} of a CPU is a high level description of what it can do. Some differences are listed here: 
      \begin{enumerate} 
        \item What instructions it can execute. 
        \item The instruction length and decoding, along with its complexity. 
        \item The performance vs power efficiency. 
      \end{enumerate}
    \end{definition}

    
    \begin{definition}
      ISAs can be classified into two types. 
      \begin{enumerate} 
        \item The \textbf{complex instruction set computer} (CISC) is characterized by a large set of complex instructions, which can execute a variety of low-level operations. This approach aims to reduce the number of instructions per program, attempting to achieve higher efficiency by performing more operations with fewer instructions.
        \item The \textbf{reduced instruction set computer} (RISC) emphasizes simplicity and efficiency with a smaller number of instructions that are generally simpler and more uniform in size and format. This approach facilitates faster instruction execution and easier pipelining, with the philosophy that simpler instructions can provide greater performance when optimized.
      \end{enumerate}
    \end{definition}

    \begin{example}[x86 Architecture]
      The x86 architecture is a CISC architecture, which is the most common architecture for personal computers. Here are important properties: 
      \begin{enumerate} 
        \item It is a complex instruction set computer (CISC) architecture, which means that it has a large set of complex instructions\footnote{https://en.wikipedia.org/wiki/X86\_instruction\_listings}. 
        \item Byte-addressing is enabled and words are stored in little-endian format.
        \item In the x86\_64 architecture, registers are 8 bytes long (and 4 bytes in x86\_32) and there are 16 total general purpose registers, for a total of only 128 bytes (very small compared to many GB of memory). Other special purpose registers are also documented in the wikipedia page, but it is not fully documented. The registers are listed below\footnote{Older x86\_32 architecture has 8 general purpose registers with the \texttt{r} replaced by a \texttt{e}, e.g. \texttt{eax} instead of \texttt{rax}.}: 
        \begin{cverbatim} 
          %rax        # return value 
          %rbx        # callee saved 
          %rcx        # 4th argument 
          %rdx        # 3rd argument 
          %rsi        # 2nd argument
          %rdi        # 1st argument 
          %rbp        # callee saved  
          %rsp        # stack pointer 
          %r8         # 5th argument 
          %r9         # 6th argument 
          %r10        # scratch register  
          %r11        # scratch register 
          %r12        # callee saved  
          %r13        # callee saved 
          %r14        # callee saved
          %r15        # callee saved
        \end{cverbatim}
        

      \end{enumerate}

    \end{example}

    \begin{example}[ARM Archiecture]
      Mainly in phones, tablets, laptops. 
    \end{example}

    \begin{example}[MIPS Architecture]
      MIPS is a RISC architecture, which is used in embedded systems such as digital home and networking equipment. 
    \end{example}

    This is a large overview of the different architectures, but Arch Linux states on their website that they have \textit{official packages optimized for the x86-64 architecture}.\footnote{https://archlinux.org/} 

    Furthermore, by running \textbf{cat /proc/cpuinfo}, you can see the specs of each CPU core you have. This includes the \textbf{model name} (clock cycle), \textbf{cache size}, \textbf{flags}, and \textbf{microcode}. The flags are the most important, since they tell you what features your CPU has.\footnote{The entire list of flags and what they can do is mentioned in the Arch kernel source code, which is a good reference: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/include/asm/cpufeatures.h} 
    \begin{enumerate} 
      \item \textbf{lm}: 64 bit architecture. 
      \item \textbf{vmx} (Intel) or \textbf{svm} (AMD): Hardware virtualization . 
      \item \textbf{aes}: Accelerate AES encryption. 
      \item \textbf{fpu}: Floating Point Unit, which is used for floating point operations. 
      \item \textbf{vme}: Virtual 8086 mode enhancements, which is used for virtualization. 
      \item \textbf{de}: Debugging extensions, which is used for debugging. 
      \item \textbf{pse}: Page Size Extensions, which is used for larger page sizes. 
      \item \textbf{tsc}: Time Stamp Counter, which is used for timing. 
      \item \textbf{msr}: Model Specific Registers, which is used for model specific operations. 
      \item \textbf{mce}: Machine Check Exception, which is used for error checking. 
      \item \textbf{pae}: Physical Address Extensions, which is used for larger memory. 
      \item \textbf{mce}: Machine Check Exception, which is used for error checking. 

    \end{enumerate}

  \subsection{Assembly in x86\_64} 

    \begin{definition}[Instruction]
      An instruction is a single line of assembly code. It consists of some instruction followed by its (one or more) operands. The instruction is a mnemonic for a machine language operation (e.g. \texttt{mov}, \texttt{add}, \texttt{sub}, \texttt{jmp}, etc.). The \textbf{size specifier} can be appended to this instruction mnemonic to specify the size of the operands. 
      \begin{enumerate} 
        \item \textbf{b} (byte) for 1 byte 
        \item \textbf{w} (word) for 2 bytes
        \item \textbf{l} (long) for 4 bytes 
        \item \textbf{q} (quad word) for 8 bytes
      \end{enumerate}
      Note that due to backwards compatibility, word means 2 bytes in instruction names. Furthermore, the maximum size is 8 bytes since that is the size of each register in x86\_64. An operand can be of 3 types, determined by their \textbf{mode of access}:
      \begin{enumerate} 
        \item \textbf{Immediate addressing} is denoted with a \texttt{\$} sign, e.g. a constant integer data \texttt{\$1}. 
        \item \textbf{Register addressing} is denoted with a \texttt{\%} sign with the following register name, e.g. \texttt{\%rax}.
        \item \textbf{Memory addressing} is denoted with the hexadecimal address in memory, e.g. \texttt{0x034AB}.
      \end{enumerate}
    \end{definition}

    Like higher level programming languages, we can perform operations, do comparisons, and jump to different parts of the code. Instructions can be generally categorized into three types: 
    \begin{enumerate} 
      \item \textbf{Data Movement}: These instructions move data between memory and registers or between the registery and registery. Memory to memory transfer cannot be done with a single instruction. 
        \begin{cverbatim} 
          %reg = Mem[address]     # load data from memory into register
          Mem[address] = %reg     # store register data into memory
        \end{cverbatim}
      \item \textbf{Arithmetic Operation}: Perform arithmetic operation on register or memory data. 
        \begin{cverbatim} 
          %reg = %reg + Mem[address]     # add memory data to register
          %reg = %reg - Mem[address]     # subtract memory data from register
          %reg = %reg * Mem[address]     # multiply memory data to register
          %reg = %reg / Mem[address]     # divide memory data from register
        \end{cverbatim}
      \item \textbf{Control Flow}: What instruction to execute next. 
        \begin{cverbatim} 
          jmp label     # jump to label
          je label      # jump to label if equal
          jne label     # jump to label if not equal
          jg label      # jump to label if greater
          jl label      # jump to label if less
          call label    # call a function
          ret           # return from a function
        \end{cverbatim}
    \end{enumerate}

    Now unlike compiled languages, which are translated into machine code by a compiler, assembly code is translated into machine code through a two-step process. First, we \textbf{assemble} the assembly code into an \textbf{object file} by an \textbf{assembler}, and then we \textbf{link} the object file into an executable by a \textbf{linker}. Some common assemblers are \textbf{NASM} (Netwide Assembler) and \textbf{GAS/AS} (GNU Assembler), and common linkers are \textbf{ld} (GNU Linker) and \textbf{lld} (LLVM Linker), both installable with \textbf{sudo pacman -S nasm ld}. 

    \begin{definition}[mov]
      Let's talk about the \texttt{mov} instruction. A good diagram to see is the following: \begin{center}  
        \includegraphics[scale=0.5]{img/movq.png}
      \end{center} 
      Parantheses indicate that we are using a pointer dereference. 
    \end{definition}

    \begin{definition}[int]
      The \texttt{int} instruction is used to generate a software interrupt. It is often used to invoke a system call.
    \end{definition}

    \begin{definition}[ret]
      The \texttt{ret} instruction is used to return from a function. It returns the value in the \texttt{\%rax} register. 
    \end{definition}

    \begin{example}[Swap Function]
      In \textbf{gdb}, we may have a function that swaps two integers. 
      \begin{cverbatim} 
        swap:
          movq (%rdi), %rax
          movq (%rsi), %rdx
          movq %rdx, (%rdi)
          movq %rax, (%rsi)
          ret
      \end{cverbatim}
    which is the assembly code for the following C code.
      \begin{cverbatim} 
        void swap(long *xp, long *yp) {
          long t0 = *xp;
          long t1 = *yp;
          *xp = t1;
          *yp = t0;
        }
      \end{cverbatim}
    \end{example}

  \subsection{Graphics Drivers}
    
    Note that one type of data we must store on memory is the individual pixels in a computer screen. Say that in a $1920 \times 1080$ resolution computer, there are about $1920 \times 1080 \times 3 \approx 2$ million bytes of data that we have to store. This isn't that much data (only 2MB), but we must update it quite fast since our screens are always updating. This is why all computer which have a GUI comes with a built-in graphics driver. To see the GPU hardware specifications, install \textbf{lshw}. 

    \begin{definition}[Graphics Processing Unit]
      The \textbf{GPU} is a specialized processing unit that is designed to handle the rendering of images and videos. It is designed to handle the rendering of images and videos, and is optimized for parallel processing. Like the CPU, it has some common metrics: 
      \begin{enumerate} 
        \item \textbf{Clock Speed}: The speed at which the GPU can execute instructions. This is usually measured in MHz or GHz. 
        \item \textbf{Memory}: The amount of memory that the GPU has. This is usually measured in GB. 
        \item \textbf{Memory Bandwidth}: The speed at which the GPU can read and write to its memory. This is usually measured in GB/s. 
        \item \textbf{Cores}: The number of cores that the GPU has. This is usually measured in thousands, which allows for parallel processing. 
      \end{enumerate}
      You can check which GPUs you have by running \texttt{lspci | grep VGA} or \texttt{neofetch}. There are generally two types of GPUs: 
      \begin{enumerate} 
        \item \textbf{Integrated GPU}: This type of GPU is built into the same chip as the CPU (Central Processing Unit). It shares resources with the CPU, including memory, which can lead to reduced performance for graphics-intensive tasks. However, its integrated nature makes it more power-efficient and cost-effective. 
        \item \textbf{Discrete GPU}: This is a separate component from the CPU and comes with its own RAM (usually called VRAM or Video RAM). It is typically installed in a dedicated slot on the motherboard. Because it operates independently of the CPU, a discrete GPU can offer significantly better performance for graphics processing, gaming, or deep learning. 
      \end{enumerate}
    \end{definition}

    \begin{definition}[Monitor]
      Furthermore, your computer monitor, which actually displays these pixels to you, must also have metrics that match the GPU. Some properties: 
      \begin{enumerate} 
        \item The \textbf{resolution} is the number of pixels that the monitor can display, and is usually measured in pixels. 
        \item The \textbf{refresh rate} is the number of times the monitor can refresh the image on the screen per second, and is usually measured in Hz. 
      \end{enumerate}
      To see these metrics for all monitors connected to your computer, run \textbf{xrandr}, which lists all the resolutions and possible refresh rates for each resolution. 
    \end{definition}

    \begin{definition}[Graphics Driver]
      In order for your operating system to communicate with your GPU, you need a \textbf{graphics driver}. This is a piece of software that allows the operating system to communicate with the GPU. There are two main types of graphics drivers:
      \begin{enumerate} 
        \item \textbf{Open Source Drivers}: These are drivers that are developed and maintained by the open source community. They are usually included with the Linux kernel, and are generally stable and reliable. 
        \item \textbf{Proprietary Drivers}: These are drivers that are developed and maintained by the GPU manufacturer. They are usually not included with the Linux kernel, and are generally more feature-rich and performant than open source drivers. 
      \end{enumerate}
    Intel drivers are open source, but Nvidia drivers are proprietary (which is why Linus Torvalds has beef with Nvidia).\footnote{A video of Linus Torvalds saying ``fuck you'' to Nvidia: https://www.youtube.com/watch?v=iYWzMvlj2RQ}
    \end{definition}

    Some popular graphics drivers include \textbf{mesa} for Intel and \textbf{nvidia} drivers for NVIDIA. 

    \subsubsection{Multiple GPUs} 

      Everything is pretty straightforward when you have one graphics card, but when you have multiple graphics cards, you have to specify which one you want to use. If you want to only use one GPU, you can just disable the other one in the BIOS. However, if you have an Intel/Nvidia dual driver and want to use both, install \textbf{Nvidia Optimius} (for Ubuntu, it is supported through \textbf{nvidia-prime}).\footnote{This wiki article (https://github.com/Askannz/optimus-manager/wiki) provides a good overview of this matter. },\footnote{Installation instructions here: https://github.com/Askannz/optimus-manager?tab=readme-ov-file} 

      Now make sure that the systemd daemon is running, and you can call \texttt{optimus-manager --switch hybrid} to enable hybrid graphics. This will log you out. 

    \subsection{Peripheral Devices} 
      
      Peripheral devices refer to other devices outside of the motherboard, including mice, keyboards for input, monitors, printers, network managers, and usb ports. Even the GPU is considered a peripheral device. These must be connected to the motherboard in some way to be managed by the operating system, and similar to the databus connecting the CPU and memory, there are buses that connect the motherboard and these peripheral devices. 

      \begin{definition}[PCI Bus]
        The \textbf{PCI (Peripheral Component Interconnect)} bus is a high-speed bus that connects the motherboard to peripheral devices. It is used to connect devices like network cards, sound cards, and graphics cards to the motherboard. PCI buses operated based on the PCI standard, which is a set of specifications that define the physical and electrical characteristics of the bus. 
      \end{definition}

      The command to use to enumerate all PCI devices is \texttt{sudo lspci} (with \texttt{-v} for verbose). 
      
      \begin{figure}[hbt!]
        \centering 
        \begin{cverbatim} 
00:00.0 Host bridge: Intel Corporation 10th Gen Core Processor 
00:01.0 PCI bridge: Intel Corporation 6th-10th Gen Core Processor 
00:02.0 VGA compatible controller: Intel Corporation CometLake-H 
00:04.0 Signal processing controller: Intel Corporation Xeon 
00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5/v6 
00:12.0 Signal processing controller: Intel Corporation Comet 
00:13.0 Serial controller: Intel Corporation Device 06fc
00:14.0 USB controller: Intel Corporation Comet Lake USB 3.1 
00:14.2 RAM memory: Intel Corporation Comet Lake PCH Shared 
00:14.3 Network controller: Intel Corporation Comet Lake PCH
00:15.0 Serial bus controller: Intel Corporation Comet Lake 
00:15.1 Serial bus controller: Intel Corporation Comet Lake 
00:16.0 Communication controller: Intel Corporation Comet 
00:1c.0 PCI bridge: Intel Corporation Device 06b8 (rev f0)
00:1c.6 PCI bridge: Intel Corporation Device 06be (rev f0)
00:1d.0 PCI bridge: Intel Corporation Comet Lake PCI Express
00:1e.0 Communication controller: Intel Corporation Comet Lake 
00:1f.0 ISA bridge: Intel Corporation Device 068e
00:1f.3 Audio device: Intel Corporation Comet Lake PCH cAVS
00:1f.4 SMBus: Intel Corporation Comet Lake PCH SMBus Controller
00:1f.5 Serial bus controller: Intel Corporation Comet Lake 
01:00.0 3D controller: NVIDIA Corporation TU117M [GeForce GTX 1650 
02:00.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
03:00.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
03:01.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
03:02.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
03:04.0 PCI bridge: Intel Corporation JHL7540 Thunderbolt 3 Bridge
04:00.0 System peripheral: Intel Corporation JHL7540 Thunderbolt 
38:00.0 USB controller: Intel Corporation JHL7540 Thunderbolt 3 
6c:00.0 Unassigned class [ff00]: Realtek Semiconductor Co., Ltd. 
6d:00.0 Non-Volatile memory controller: Samsung Electronics Co 
        \end{cverbatim}
        \caption{This is the following output of lspci on my personal computer. } 
        \label{fig:}
      \end{figure}

  \subsection{Overview of Architecture} 

    


\section{Filesystems}

  Before we get into anything, even the loading of the firmware or the operating system kernel, we must talk about the hardware and how a computer stores data. Data, whether it is in memory or some disk, is just a bunch of sequences of bits. A \textbf{drive} is a physical device that can store data. A \textbf{partition} is a logical division of a drive, and a \textbf{filesystem} is a way to organize data on a drive. For example, if I have a 1TB SSD, I can run it as a single partition, or I can divide it into two partitions, one for a Windows operating system and another for a Linux operating system. A filesystem is a bit more confusing, so here are some examples. 

  \begin{example}[Linux Filesystems]
    Listed. 
    \begin{enumerate}
      \item \textbf{ext4}: The most common filesystem for Linux. 
      \item \textbf{XFS}: Designed for high performance and scalability, often used in enterprise environments for large-scale storage.
      \item \textbf{btrfs}: A modern filesystem that offers advanced features like snapshots, dynamic inode allocation, and integrated device management for better data reliability and performance. 
      \item \textbf{zfs}: Originally developed by Sun Microsystems for Solaris, ZFS is known for its data integrity, support for enormous storage capacities, and features like snapshots, copy-on-write, and built-in data compression.
    \end{enumerate}
  \end{example}

  \begin{example}[Windows Filesystems]
    Listed. 
    \begin{enumerate} 
      \item \textbf{NTFS (New Technology File System)}: The standard filesystem for Windows operating systems, supporting file permissions, encryption, and large file sizes.
      \item \textbf{FAT32 (File Allocation Table 32)}: An older filesystem with wide compatibility across different operating systems, including Windows, macOS, and various Linux distributions, though it has limitations on file and partition sizes.
      \item \textbf{exFAT (Extended File Allocation Table)}: Designed to be a lightweight filesystem similar to FAT32 but without its limitations, exFAT is used for flash drives and external hard drives due to its support for larger files and compatibility.
    \end{enumerate}
  \end{example}

  \begin{example}[MacOS Filesystems]
    Listed. 
    \begin{enumerate}
      \item \textbf{APFS (Apple File System)}: The default filesystem for macOS, iOS, and other Apple operating systems since 2017, designed for SSDs and featuring strong encryption, space sharing, and fast directory sizing.
      \item \textbf{HFS+ (Hierarchical File System Plus)}: Also known as Mac OS Extended, it was the primary filesystem for Mac computers before APFS, supporting journaling for data integrity.
    \end{enumerate}
  \end{example}

  When your computer boots up, it needs to know where to find the operating system kernel. This is done by mounting the filesystems. The \textbf{mount point} is the directory where the filesystem is attached to the system. The \textbf{root filesystem} is the filesystem that contains the operating system kernel.

  Depending on your hardware specs, you may have multiple drives. To list all drives and their partitions, run \textbf{lsblk}. The type determines whether it is a disk or a partitions, and the mountpoints determine where the partitions are mounted. Furthermore, the \texttt{RO} indicates whether this is a HDD (1) or SSD (0). 

\begin{figure}[hbt!]
  \centering 
  \begin{cverbatim} 
  NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
  zram0       254:0    0     4G  0 disk [SWAP]
  nvme0n1     259:0    0 953.9G  0 disk 
    nvme0n1p1 259:1    0   240M  0 part 
    nvme0n1p2 259:2    0   128M  0 part 
    nvme0n1p3 259:3    0 309.4G  0 part 
    nvme0n1p4 259:4    0   990M  0 part 
    nvme0n1p5 259:5    0  16.7G  0 part 
    nvme0n1p6 259:6    0   1.4G  0 part 
    nvme0n1p7 259:7    0   500M  0 part /boot
    nvme0n1p8 259:8    0   4.7G  0 part [SWAP]
    nvme0n1p9 259:9    0 619.9G  0 part /
  \end{cverbatim}
  \caption{This is the following output on my personal computer. } 
  \label{fig:lsblk}
\end{figure}
  
  The \textbf{swap} partition is a special type of partition that is used as a temporary storage area for the operating system. It is used when the system runs out of RAM. 

  For a more detailed view on what the partitions consist of, you can run \textbf{fdisk -l}.
  \begin{cverbatim} 
  Disk /dev/nvme0n1: 953.87 GiB, 1024209543168 bytes, 2000409264 sectors
  Disk model: PM9A1 NVMe Samsung 1024GB               
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: gpt
  Disk identifier: 26D88CE9-B388-4CF1-856C-14D5EEB0C143

  Device              Start        End    Sectors   Size Type
  /dev/nvme0n1p1       2048     493567     491520   240M EFI System
  /dev/nvme0n1p2     493568     755711     262144   128M Microsoft reserved
  /dev/nvme0n1p3     755712  649658367  648902656 309.4G Microsoft basic data
  /dev/nvme0n1p4 1960380416 1962407935    2027520   990M Windows recovery environment
  /dev/nvme0n1p5 1962407936 1997441023   35033088  16.7G Windows recovery environment
  /dev/nvme0n1p6 1997443072 2000377855    2934784   1.4G Windows recovery environment
  /dev/nvme0n1p7  649658368  650682367    1024000   500M EFI System
  /dev/nvme0n1p8  650682368  660447231    9764864   4.7G Linux swap
  /dev/nvme0n1p9  660447232 1960380415 1299933184 619.9G Linux filesystem
  \end{cverbatim}

  As you can see here, my single disk has 9 partitions. 
  \begin{enumerate} 
    \item The first EFI system (1) or the Microsoft reserved (2) partition contains the Windows operating system kernel. 
    \item The Microsoft basic data (3) partition contains the Windows files.
    \item  The Windows recovery environment (4, 5, 6) is a partition that contains the Windows recovery environment, which are partitions set aside by the manufacturer to hold an image of your system before it was shipped from the factory. 
    \item The EFI system (7) partition contains the Linux operating system kernel, which is required to load the operating system. 
    \item The Linux swap (8) partition is a partition that contains the Linux swap. 
    \item The Linux filesystem (9) is a partition that contains the actual Linux operating system itself, along with all your files.
  \end{enumerate}


  \subsection{Mounting} 

    You can further go into the \texttt{/dev} directory to see the devices that are mounted, e.g. the \texttt{/dev/nvme0n1p9} is the device that is mounted on the root directory, and most of these files are either device files (which are special files that provide an interface to hardware devices, allowing software and users to interact with them as if they were normal files) or symlinks.

    The \textbf{mount} command is used to attach a filesystem to the system's directory tree. The \textbf{umount} command is used to detach a filesystem from the system's directory tree. 

    \begin{enumerate}
      \item \textbf{Mounting a filesystem}: The general syntax is \texttt{mount -t type device dir}. For example, to mount the \texttt{/dev/nvme0n1p9} to the root directory, you can run \texttt{mount -t ext4 /dev/nvme0n1p9 /mnt}. 
      \item \textbf{Unmounting a filesystem}: The general syntax is \texttt{umount dir}. For example, to unmount the root directory, you can run \texttt{umount /mnt}. 
    \end{enumerate}

    When the computer boots up, it must automatically mount the specific filesystems. This is configured in the \textbf{fstab} file. 

    \begin{definition}[fstab]
      The \textbf{fstab} file is a system configuration file that contains information about filesystems. It is located at \texttt{/etc/fstab}. It is used to define how disk partitions, various other block devices, or remote filesystems should be mounted into the filesystem. 
      Each line in the file contains six fields, separated by whitespace. The fields include: 
      \begin{enumerate} 
        \item \textbf{Filesystem}: The block device or remote filesystem to be mounted. This can be the UUID (Universally Unique Identifier), the label, or the traditional device name (like /dev/sda1) that specifies which device or partition is being referred to.
        \item \textbf{Mount Point}: The directory where the filesystem should be mounted. 
        \item \textbf{Type}: The type of the filesystem, e.g. ext4, vfat, swap, etc.
        \item \textbf{Options}: Mount options for the filesystem, e.g. \texttt{rw} for read-write, \texttt{ro} for read-only, \texttt{noexec} to prevent execution of binaries, etc.
        \item \textbf{Dump}: A number used by the \textbf{dump} command to determine whether the filesystem should be backed up. It is often set to $0$ to disable backups. 
        \item \textbf{Pass}: A number used by the \textbf{fsck} command to determine the order in which filesystems should be checked. Root filesystems should have this set to 1, and other filesystems should either be 2 (to check after the root) or 0 (to disable checking). 
      \end{enumerate}
    \end{definition}
    \begin{figure}[hbt!]
      \centering 
      \begin{cverbatim} 
# Static information about the filesystems.
# See fstab(5) for details.

# <file system> <dir> <type> <options> <dump> <pass>
# /dev/nvme0n1p9
UUID=abcfef03-bfae-4d1f-b463-fd6538f18a41	/ ext4 rw,relatime 0 1
# /dev/nvme0n1p7
UUID=150D-7A67 /boot vfat rw,relatime,fmask=0077,dmask=0077,codepage=437,
    iocharset=ascii,shortname=mixed,utf8,errors=remount-ro	0 2
# /dev/nvme0n1p8
UUID=5c191f65-b016-475d-b04a-5b7c89bda31d	none swap defaults 0 0
      \end{cverbatim}
      \caption{My personal fstab file.} 
      \label{fig:fstab}
    \end{figure}

    \subsubsection{Mounting a Remote Disk} 

      It is actually possible to mount a folder on a server into your local machine. To do this, you use \textbf{sshfs} to mount a remote directory over SSH. The general syntax is \texttt{sshfs user@host:/remote/dir /local/dir} to mount and \texttt{fusermount -u /local/dir} to unmount. 

  \subsection{Maintence} 

    \subsubsection{SSD}

      As soon as your write or delete bits from the SSD (e.g. when you're deleting a file), it degrades the speed of the read/write. To alleviate the effects, you can use TRIM, which is a command that allows the operating system to inform the SSD which blocks of data are no longer considered in use and can be wiped internally. It can be downloaded as a part of the \texttt{util-linux} package, which provides the systemd services \textbf{fstrim.timer} and \textbf{fstrim.service}. It is recommended to use weekly trims rather than continuous trims. 

    \subsubsection{Filesystem} 

      Occasionally, you may have a corrupt partitions, whether it is your boot or root directory. In this case, you should use the \textbf{fsck} command to check and repair a filesystem. The general steps are: 
      \begin{enumerate} 
        \item unmount the specific partition you want (identified with \textbf{lsblk}) using \texttt{sudo umount /dev/partition}. 
        \item run \texttt{sudo fsck -t type device} (or for specific filesystem types like vfat you can be a bit more specific by running \texttt{sudo fsck.vfat /dev/partition}) to check the filesystem and fix any changes. 
        \item mount the specific partition back using \texttt{sudo mount /dev/partition}. 
      \end{enumerate}

  \subsection{Modifying Partitions} 
    
    Modifying partitions require specialized software. Partitioning can be done using two main partitioning schemes \textbf{GPT} (the modern one) and \textbf{MBR} (legacy). The \textbf{parted} utility gives detailed info on your partitions. To see which scheme you have, just run \texttt{sudo parted -l}, where the output can be shown in Figure \ref{fig:parted}. 

    \begin{figure}[hbt!]
      \centering 
      \begin{cverbatim} 
Model: PM9A1 NVMe Samsung 1024GB (nvme)
Disk /dev/nvme0n1: 1024GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system     Name                          Flags
 1      1049kB  253MB   252MB   fat32           EFI system partition          boot, esp
 2      253MB   387MB   134MB                   Microsoft reserved partition  msftres
 3      387MB   333GB   332GB   ntfs            Basic data partition          msftdata
 7      333GB   333GB   524MB   fat32                                         boot, esp
 8      333GB   338GB   5000MB  linux-swap(v1)                                swap
 9      338GB   1004GB  666GB   ext4
 4      1004GB  1005GB  1038MB  ntfs                                          hidden, diag
 5      1005GB  1023GB  17.9GB  ntfs                                          hidden, diag
 6      1023GB  1024GB  1503MB  ntfs                                          hidden, diag


Model: Unknown (unknown)
Disk /dev/zram0: 4295MB
Sector size (logical/physical): 4096B/4096B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system     Flags
 1      0.00B  4295MB  4295MB  linux-swap(v1) 
      \end{cverbatim}
      \caption{Output of \texttt{sudo parted -l} on my own machine. } 
      \label{fig:parted}
    \end{figure}

    It is important to know which partition scheme you should use. 
    \begin{enumerate} 
      \item To dual-boot with Windows (both 32-bit and 64-bit) using Legacy BIOS, the MBR scheme is required.
      \item To dual-boot Windows 64-bit using UEFI mode instead of BIOS, the GPT scheme is required.
      \item If you are installing on older hardware, especially on old laptops, consider choosing MBR because its BIOS might not support GPT.
      \item If you are partitioning a disk that is larger than 2TB, you need to use GPT.
      \item It is recommended to always use GPT for UEFI boot, as some UEFI implementations do not support booting to the MBR while in UEFI mode.
    \end{enumerate}

\section{Firmware} 

  Let us go through the steps of a booting (bootstrapping) process. Administrators have little direct, interactive control over most of the steps required to boot a system, but they can modify bootstrap configurations by editing config files or system startup scripts. 

  \begin{enumerate}
    \item \textbf{Power On}: You power on the machine. 
    \item \textbf{Load firmware from NVRAM}: You want to be able to identify the specific piece of hardware to load your operating system in. The firmware is a permanent piece of software that does this. 
    \item \textbf{Probe for hardware}: We look for hardware that is on the computer. 
    \item \textbf{Select boot device (disk, network, etc.)}: We select the storage device that we want to load the operating system on. 
    \item \textbf{Identify EFI system partition}: 
    \item \textbf{Load boot loader (e.g. GRUB)}: A software that allows you to identify and load the proper OS kernel is provided. 
    \item \textbf{Determine which kernel to boot}: You choose which kernel you want to load.  
    \item \textbf{Load kernel}: The OS kernel is identified and loaded into the boot device. 
    \item \textbf{Instantiate kernel data structure}: 
    \item \textbf{Start init/systemd as PID 1}: 
    \item \textbf{Exectute startup scripts}:
    \item \textbf{Running system}: You now have a running system! 
  \end{enumerate}

  Right above the hardware, the \textbf{system firmware}, is a piece of software that is executed whenever the computer boots up. 
  \begin{enumerate} 
    \item \textbf{Power Supply Activation}: Once the computer is turned on, the power supply begins to provide electricity to the system's components. One of the first signals generated is the "Power Good" signal, indicating that the power supply is stable and at the correct voltages. 
    \item \textbf{CPU Reset}: Upon receiving the "Power Good" signal, the CPU resets and starts its operations. The CPU is designed to start executing instructions from a predefined memory address, which is hardwired into the CPU. This address, stored in ROM, contains the starting point of the firmware.\textbf{Read Only Memory} is simply another type of computer memory that stores permanent data and instructions for the device to start up. 
    \item \textbf{Predefined Memory Address}: For BIOS systems, the CPU begins executing code at the firmware entry point located in the system's ROM (Read-Only Memory). In UEFI systems, the process is similar, but the UEFI firmware provides more functionalities and a more flexible pre-boot environment.
    \item \textbf{POST (Power on Self Test)}: The firmware conducts a series of diagnostic tests to ensure that essential hardware components like RAM, storage devices, and input/output systems are functioning correctly. This stage is critical for verifying system integrity before loading the operating system.
  \end{enumerate}

  To be honest, there is not a lot that the user can control here with just software. The firmware is a permanent piece of software that is executed whenever the computer boots up, which makes it relatively safe from tampering. If your computer fails to boot up, the most fundamental reason may be a firmware problem. However, we're not screwed yet. 

  Most firmware offers a user interface which can be accessed by pressing the F2, F11, F12, or some combination of magic keys at the instant the system first powers on. Depending on what computer model you have, you may have some control of basic functionalities. 
  
  \begin{figure}[hbt!]
    \centering 
    \includegraphics[scale=0.3]{img/xps_firmware.jpg}
    \caption{Firmware of Dell XPS 13 9320} 
    \label{fig:xps_firmware}
  \end{figure}

  Some important functionalities you can do with the firmware are: 
  \begin{enumerate} 
    \item Determine the boot order of the devices, usually by prioritizing a list of available options (e.g. try to boot from a DVD drive, then a USB, then the hard disk). 
    \item 
  \end{enumerate}

  The \textbf{BIOS}, which stands for \textbf{Basic Input/Output System}, has been used traditionally. A more formalized and modern standard called \textbf{EFI} (\textbf{Extensible Firmware Interface}) has replaced it, and it has been revised to the \textbf{UEFI} (\textbf{Unified Extensible Firmware Interface}) standard, but we can treat EFI and UEFI as equivalent in most cases. Fortunately, most UEFI systems can fall back to a legacy BIOS impelmentation if the operating system they're booting doesn't support UEFI. Since we're likely to encounter boot firmware systems, it's worthwhile to go into both of them. 

  \subsection{Updating Firmware}

    The first thing you should do when you're having trouble with firmware is use \textbf{fwupd}, which is a daemon that handles firmware updates. It is a simple daemon to allow session software to update device firmware on your local machine. Upon installation, it creates a systemd agent on \texttt{/lib/systemd/system/fwupd.service}. It does not start automatically. I have used this to update my firmware, which saved a lot of booting errors, with instructions accessed in this \href{https://wiki.archlinux.org/title/fwupd}{link}. 

  \subsection{Modifying UEFI Variables}

    You can directly examine and modify UEFI variables on a running system with the \texttt{efibootmgr} command. You get a following summary of the configuration: 
    \begin{cverbatim}
      BootCurrent: 0005
      Timeout: 0 seconds
      BootOrder: 0005,0001,0002,0000,0003,0004
      Boot0000* UEFI PM9A1 NVMe Samsung 1024GB S65VNE0R318841 1	...
      Boot0001* ubuntu	HD(1,GPT,ede98b7e-75ad-452e-ab47-3411dd6026c1,0x800,0x780...
      Boot0002* Windows Boot Manager	HD(1,GPT,ede98b7e-75ad-452e-ab47-3411dd60...
      Boot0003* Linux Firmware Updater	HD(1,GPT,ede98b7e-75ad-452e-ab47-...
      Boot0004* UEFI PM9A1 NVMe Samsung 1024GB S65VNE0R318841 1 2	PciRoot(0x0)/...
      Boot0005* Linux Boot Manager	HD(7,GPT,2d28b70f-725b-4ca3-98d4-25f5c83fc00e...
    \end{cverbatim}

  It shows you which disk you are currently booted into, the boot order that is currently configured, and information about each of the disks. 

\section{Bootloaders} 

  Once the firmware is loaded, which probes the system to find the hardware, it must load the operating system kernel. This is the job of the boot loader.

  \begin{definition}[Boot Loader, Boot Manager]
    The \textbf{bootloader} is another critical piece of software that allows you to identify and load the proper operating system kernel. If it also provides an interactive menu with multiple boot choices, then it is often called a \textbf{boot manager}. 
  \end{definition}

  In modern systems which support UEFI (not the legacy BIOS), you must configure your partitions so that there exists an EFI partition (at \texttt{/boot}) that contains this bootloader. 

  EFI bootloaders usually have a \texttt{.efi} extension, and it is crucial that you know where the bootloaders are in your system in case they go missing or are corrupt. To see the configuration, you can run \textbf{efibootmgr} (with verbose), which gives you information on several things: 
  \begin{enumerate} 
    \item It scans the entire system for EFI bootloaders and lists them. 
    \item It lists the locations of the EFI bootloaders. It starts off which what partition they are in, and then lists the directory where the bootloader is located. \texttt{BootX64.efi} is the Windows bootloader and \texttt{grubx64.efi} is the GRUB bootloader. For example, you may have a bootloader at \texttt{(partition 7)/boot/efi/EFI/Boot/bootx64.efi}. 
    \item It lists the boot order, which is the order in which the bootloaders are loaded. In case a boot loader fails to load, the next one is loaded. Therefore, if you have an arch linux bootloader that is corrupt, and the next in line is the Windows bootloader, you will automatically boot into Windows. You can also set the boot order in the BIOS. 
  \end{enumerate}

  In case you can't boot in, you can always get an Arch ISO burned in on a thumb drive, boot into it, mount the relevant partitions containing the Arch bootloader and the root directory, and then chroot into the root directory to modify files. 

  \subsection{GRUB}

    The way that these kernels can be loaded can be configured through the bootloader, and the most popular boot manager is \textbf{GRUB}, the \textbf{Grand Unified Bootloader}. 

    GRUB, developed by the GNU project, is the default loader on most Linux distributions. There is an old version called GRUB legacy and the more modern GRUB 2. Most people refer to GRUB 2 and simply GRUB. FreeBSD, which is another complete (non-Linux) OS, have their own boot loader, but GRUB is compatible with it. Therefore, for dual-boot or triple-boot systems that have multiple kernels, GRUB is the go-to bootloader for loading any of them. 

    As a critical piece of software, we would expect its configuration files to be in the NVRAM, but GRUB understands most of the filesystems in common use and can find its way into the root filesystem on its own. Therefore, we can read its configuration from a regular text file, kept in \texttt{/boot/grub/grub.cfg}. Changing the boot configuration is as simple as updating the \texttt{grub.cfg} file. 

\section{Systemd} 

  A \textbf{process} is really any program that is running on your computer. A \textbf{daemon} is a background process that runs continuously, performing specific tasks even when no user is logged in. 

  Once the kernel has been loaded and completed its initialization process, it creates a collection of \textit{spontaneous} (as in the kernel starts them automatically) processes in user space. They're really part of the kernel implementation and don't necessarily correspond to programs in the filesystem. They're not configurable and they don't require administrative attention. These processes can be monitored with the commands \texttt{ps}, \texttt{top}, or \texttt{htop}.

  The most important process is the init process, with a system PID of 1 and with special privileges. It is used to get the system running and for starting other processes. 

  \begin{enumerate}
    \item Setting the name of the computer 
    \item Setting the time sone 
    \item Checking disks with \texttt{fsck} 
    \item Mounting filesystems 
    \item Removing old files from the \texttt{/tmp} directory 
    \item Configuring network interfaces
    \item Configuring packet filter 
    \item Starting up other daemons and network services, along with killing zombie processes or parenting orphaned processes. 
  \end{enumerate}

  There are three flavors of system management processes in widespread use: 
  \begin{enumerate}
    \item Historically, SysVinit was a series of plaintext files that ran as scripts to start processes, but due to some problems, Linux now uses systemd.
    \item An init variant that derives from the BSD UNIX, used on most BSD-based systems. 
    \item A more recent contender called \textbf{systemd} which aims to cover the init processes and much more. This significant increase in control causes some controversy. 
    \item Other flavors include Apple MacOS's \textbf{launchd} before it adopted systemd. Ubuntu also used \textbf{Upstart} before migrating to systemd. 
  \end{enumerate}

  Systemd is essentially a collection of smaller programs, services, and libraries such as systemctl, journalctl, init, process management, network management, login management, logs, etc. Some processes may depend on other processes, and with hundreds of them, it's very hard to do manually, which is why systemd does it all for you. A post on the systemd blog notes that a full build of the project generates 69 different binaries (subject to change). 

  \begin{definition}
    A \textbf{unit} is anything that is managed by systemd. It can be ``a service, a socket, a device, a mount point, an automount point, a swap file or partition, a startup carget, a watched filesystem path, a time controlled and supervised by systemd, a resource management slice, or a group of externally created processes." Within systemd, the behavior of each unit is defined and configured by a \textbf{unit file}. Within systemd, the behavior of each unit is defined and configured by a \textbf{unit file}. 

    The files are all over the place: 
      \begin{enumerate}
        \item \texttt{/lib/systemd/system} contains standard systemd unit files 
        \item \texttt{/usr/lib/systemd/system} are from locally installed packages, e.g. if I installed a pacman package that contained unit files, then those would go here. 
        \item \texttt{/etc/systemd/system} is where you put your custom files. etc also has the highest priority, so it overwrites the other files.  
        \item \texttt{/run/systemd/system} is a scratch area for transient units. 
      \end{enumerate}

    By convention, unit files are named with a suffix that varies according to the type of unit being configured. For example, service units have a \texttt{.service} suffix and timers user \texttt{.timer}. Within the unit file, some sections e.g. (\texttt{[Unit]}) apply generically to all kinds of units, but others (e.g. \texttt{[Service]}) can appear only in the context of a particular unit type. 

  \end{definition}

  \begin{example}[Service Unit File]
    If we go into one of these unit files, which have the prefix \texttt{.service}, they are usually formatted as such: 

    \begin{cverbatim}
      # comments are just the same as in bash Scripts
      # the headers are important! 

      [Unit]        #  
      Description=Description of the unit file 
      Documentation=man:something 
      After=network.target

      [Service]
      Type=forking  # tells that the process may exit and is not permanent
      PIDFile=      # 
      ExecStartPre= # scripts to run before you start 
      ExecStart=    # scripts to run when starting 
      ExecReload=   # script to run when you try to reload the process
      ExecStop=     # script to run to stop the process 

      [Install]   # Tells at what point should this be running
      WantedBy=multi-user.target 

    \end{cverbatim} 
  \end{example}
  
  \subsection{systemctl: Managing systemd} 

    \textbf{systemctl} is an all-purpose command for investigating the status of systemd and making changes to its configuration. Running \texttt{systemctl} without any arguments invokes the default \texttt{list-units} subcommand, which shows all loaded and activive services, sockets, targets, mounts, and devices. To show only services, use \texttt{--type=service}. 

    The two main commands that you will use to interact with systemd is \texttt{systemctl} and \texttt{journalctl}. 
    
    \begin{enumerate}
      \item \texttt{systemctl status unit} checks the status, ouputting the description, whether it's enabled/disabled, and whether it's active/inactive. 
      \item \texttt{systemctl enable unit} enables it, which means that it will start when booting the computer. It does this by creating a symlink to the unit file. This is different from start. 
      \item \texttt{systemctl disable unit} disables it. 
      \item \texttt{systemctl start unit} starts it now and runs it immediately. 
      \item \texttt{systemctl stop unit} makes it inactive. 
      \item \texttt{systemctl reload} will run whatever is in the \texttt{ExecReload} in the unit file. 
      \item \texttt{systemctl restart} runs ExecStop and then ExecStart. 
      \item \texttt{systemctl kill unit} kills the process. 
    \end{enumerate}

    Some of the statuses that you may see are inactive (deactivated, exited), active (activating, running), failed, static (not started, frozen by systemd), bad (broken, probably due to bad unit files), masked (ignored by systemd), indirect (disabled, but another unit file references it so it could be activated). 

    To troubleshoot, you should run \texttt{systemctl --failed} to see if there are any failed processes, which can be a problem, and then you can use \texttt{journalctl --since=today} to view your systemd logs. This log is important for diagnosing fundamental problems with your system. To view only entries logged at the error level or above, you can set the priorities with \texttt{-p err -b}. 

  \subsection{Targets}

    
  \subsection{Systemd Logging}

    The \textbf{journald} daemon allows you to capture log messages produced by the kernel and services. These system messages are stored in the \texttt{/run} directory, but we can access them directly with the \texttt{journalctl}  command. 

    \begin{example}
      
    \end{example}

    You can configure \textbf{journald} to retain messages from prior boots. To do this, edit the following file and configure the \texttt{Storage} attribute: 
    \begin{cverbatim}
    #/etc/systemd/journald.conf
      [Journal]
      Storage=persistent
    \end{cverbatim}

    Then, you can obtain a list of prior boots with \texttt{journalctl --list-boots} and you can access messages from a prior boot by referring to its index or by naming its long-form ID: \texttt{journalctl --b -1}. 

\section{Display Servers}

  When you boot up your computer, you are greeted with a graphical user interface (GUI) that allows you to interact with your computer. This is the job of the display server, which is a program that provides graphical display capabilities for the operating system. 

  \begin{definition}[Display Server]
    A \textbf{display server} is a program that manages the communication between your computer's hardware and graphical software applications. It acts as a bridge for input and output devices; for example, it processes the input from your keyboard and mouse and outputs graphics to the monitor. The display server is responsible for the fundamental task of drawing windows and handling the low-level aspects of input and output, but it doesn't dictate how these windows look or are arranged. For almost every purpose, there are two types of display servers: 
    \begin{enumerate} 
      \item \textbf{X}: The X Window System, which is the older and more established display server. 
      \item \textbf{Wayland}: The newer and more modern display server.
    \end{enumerate}
  \end{definition}

  \begin{definition}[X Window System]
    The \textbf{X Window System} is a windowing protocol for Unix/Linux OSes, similar to the way that Microsoft Windows or Apple Mac OS X can run different apps in separate windows. \textbf{X} defines the protocol for a display server what can render windows on a \textit{display client} (your computer), inside which are running apps.\footnote{Explanation here: https://www.reddit.com/r/linuxquestions/comments/3uh9n9/what\_exactly\_is\_xxorgx11/} 
    \begin{enumerate} 
      \item \textbf{X11} refers to version 11 of the X protocol, while 
      \item \textbf{Xorg} is an open-source implementation of X. 
    \end{enumerate}
  \end{definition}

  \begin{definition}[Wayland]
    X, made in 1984, has developed a lot of cruft over the years, and Wayland is a modern replacement for X. It is a protocol for a compositor to talk to its clients, as well as a C library implementation of that protocol. The compositor can be a standalone display server running on Linux kernel modesetting and evdev input devices, an X application, or a wayland client itself. 
  \end{definition}

\section{Windows Managers and Desktop Environments}

  These days, the terms window managers (WMs) and Desktop Environments (DEs) are used interchangeably, but they mean slightly different things. A window manager is the display software that determines how the pixels for each window overlaps with other and their movement. This is generally divided into two paradigms with the most familiar being \textbf{floating WMs} and the other being \textbf{tiling WMs}. Even before I knew about tiling WMs, I found myself manually tiling windows on floating WMs, so the move to tiling WMs was a no-brainer. 
  
  Some DEs and WMs are: 
  \begin{enumerate}
    \item GNOME 
    \item KDE Plasma
    \item Qtile
  \end{enumerate}

\section{Package Management}
  
  Linux comes in many flavors of distributions. Most beginners look at screenshots of these distributions on the internet and judge them based on their aesthetics (e.g. I like how Kali Linux looks so I'll go with that one). A common feature of all Linux distributions is that they provide the user the power to customize their system however they want, so you can essentially make every linux distribution look like any other. So what are some things you should consider when choosing a distribution? 

  \begin{enumerate}
    \item First is the popularity and how well it is supported. This includes the number of people who use the distribution (e.g. the Ubuntu StackExchange is a very large community) and how good the documentation is overall (e.g. the ArchLinux wiki is very well documented). 
    \item Each linux distribution essentially consists of a kernel and package manager. The architecture, design, and the update scheme of the kernel may be an interest to many linux users.  
    \item Every distribution has its own native package manager, and the availability of certain necessary packages, the ease of installation, and the updating schemes is also something to consider.  
    \item The ideals of the respective communities. The community behind each distribution has a certain set of ideals that they lean more towards. For example, the Ubuntu community likes having programs that are right out of the box, with good GUI support and is more beginner-friendly while Arch has more of a minimal and extremely customizable nature to it with its software being much more CLI dependent. 
  \end{enumerate}

  Let's begin with the package managers. Every application on your system (Firefox, Spotify, pdf readers, VSCode, etc.) is a package, and manually downloading and managing each one is impossible to do. Therefore, each distribution has its own native package manager that automatically takes care of downloading, installing, removing, checking dependency requirements of each package. In order to download a package, a package manager should also know where it is downloading \textit{from}. Essentially, a package manager itself can be downloaded with other package managers, so package managers are packages as well. 
  
  \begin{enumerate}
    \item \textbf{apt} : The advanced packaging tool is the native manager for Ubuntu distributions. 
    \item \textbf{pacman} : Native package manager for Arch Linux. 
    \item \textbf{yay} : The package manager for software in the \textbf{Arch User Repository}. 
    \item \textbf{snap} : 
    \item \textbf{flatpak} : 
    \item \textbf{dpkg} : Package manager for Debian based distributions. 
  \end{enumerate}

  Chances are if you are using one distribution, you would only have to work with a small subset of these package managers. Each package manager has one or more files in the computer that specify a list of \textbf{repositories}. 

  \subsection{Pacman}

    For example, the configuration file for pacman is located at \texttt{/etc/pacman.conf}. In the options section, I can configure stuff like text color, enabling/disabling parallel downloads, choosing specific packages to ignore upgrading, etc. Then, we can specify the servers that we should download from. In the text below, the server variable defines which server we should look at first, and then the Include variable stores the location of the file \texttt{mirrorlist} that defines a list of other servers that we should download from. 
    
    \begin{figure}
      \begin{cverbatim} 
        # The following paths are commented out with their default values listed.
        # If you wish to use different paths, uncomment and update the paths.
        #RootDir     = /
        #DBPath      = /var/lib/pacman/
        #CacheDir    = /var/cache/pacman/pkg/
        #LogFile     = /var/log/pacman.log
        #GPGDir      = /etc/pacman.d/gnupg/
        #HookDir     = /etc/pacman.d/hooks/
        HoldPkg     = pacman glibc
        #XferCommand = /usr/bin/curl -L -C - -f -o %o %u
        #XferCommand = /usr/bin/wget --passive-ftp -c -O %o %u
        #CleanMethod = KeepInstalled
        Architecture = auto

        # Pacman won't upgrade packages listed in IgnorePkg and members of IgnoreGroup
        #IgnorePkg   =
        #IgnoreGroup =

        #NoUpgrade   =
        #NoExtract   =

        # Misc options
        #UseSyslog
        #Color
        #NoProgressBar
        CheckSpace
        #VerbosePkgLists
        ParallelDownloads = 5
        ILoveCandy

      \end{cverbatim}
      \caption{Subset of contents of the \texttt{/etc/pacman.conf} file} \label{fig:pacman.conf}
    \end{figure}
    
    The mirrorlist file stores a list of URLs. Each URL is a \textbf{mirror}, which is a server that contains a physical replica of all the packages that are available to you via \texttt{pacman} (hence the name mirror). You can literally type in the links provided in Figure \ref{fig:mirrorlist} (replacing \texttt{\$repo} with \texttt{core} and \texttt{\$arch} with \texttt{x86\_64}). It contains a tarball of each package ready to be downloaded. Some repos might contain more packages than others, some might have packages that only they supply that others dont, but if you can install the piece of software via your package manager then one of your configured repos is declaring they have it available and therefore should have the file on hand to give to you if asked for it. A list of all available mirrors are available \href{https://archlinux.org/mirrorlist/all/https/}{here} (this only uses HTTPS, but HTTP mirrors are also available).  

    \begin{figure}
      \begin{cverbatim}
        Server = https://archlinux.mailtunnel.eu/$repo/os/$arch
        Server = https://mirror.cyberbits.eu/archlinux/$repo/os/$arch
        Server = https://mirror.theo546.fr/archlinux/$repo/os/$arch
        Server = https://mirror.sunred.org/archlinux/$repo/os/$arch
        Server = https://mirror.f4st.host/archlinux/$repo/os/$arch
        Server = https://md.mirrors.hacktegic.com/archlinux/$repo/os/$arch
        Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch
        Server = https://mirror.moson.org/arch/$repo/os/$arch
        Server = https://archlinux.thaller.ws/$repo/os/$arch
      \end{cverbatim}
      \caption{Contents of the \texttt{/etc/pacman.d/mirrorlist} file}\label{fig:mirrorlist}
    \end{figure}
    
    The mirrors that you download from should be trustworthy and fast. The speed is mainly related to how close you are to that mirror geographically, so if you are moving to another country you should probably update this mirrorlist for faster download speeds. There is a default mirrorlist file that is generated, but you can download and use the \textbf{reflector} package to update it.  

    Here are some common commands: 
    \begin{enumerate}
      \item Install a package: \texttt{sudo pacman -S pkg1} (\texttt{-s} stands for synchronize)

      \item Remove a package: \texttt{sudo pacman -R pkg}
      \begin{itemize}
        \item remove dependencies also: \texttt{-s} (recursive)
        \item also remove configuration files: \texttt{-n} (no save)
        \item also removes children packages: \texttt{-c} (cascade)
      \end{itemize}

      \item Update all packages: \texttt{sudo pacman -Syu}
      \begin{itemize}
        \item synchronize: \texttt{-S}
        \item refresh package databases: \texttt{-y} (completely refresh: \texttt{-yy})
        \item system upgrade: \texttt{-u}
      \end{itemize}

      \item List installed packages: \texttt{pacman -Q}
      \begin{itemize}
        \item List detailed info about a package: \texttt{pacman -Qi pkg}
        \item List all files provided by a package: \texttt{pacman -Ql pkg}
        \item List all orphaned packages: \texttt{pacman -Qdt}
        \item List all packages that have updates available: \texttt{pacman -Qu}
        \item List all explicitly installed packages: \texttt{pacman -Qet}
        \item Display the dependency tree of a package: \texttt{pactree pkg} (from the \texttt{pacman-contrib} package) 
        \item List last 20 installed packages: 
        \begin{cverbatim}
          expac --timefmt='%Y-%m-%d %T' '%l\t%n' | sort | tail -n 20
        \end{cverbatim}
      \end{itemize}

      \item To check size of current packages and dependencies, download \texttt{expac} and run \texttt{expac -H M '\%m \\t\%n' | sort -h} 

      \item The package cache stored in \texttt{/var/cache/pacman/pkg/} keeps old or uninstalled versions of packages automatically. This is helpful since it also keeps older versions of packages in the cache, and you can manually downgrade in case some packages break.  
      \begin{itemize}
        \item We can delete all cached versions of installed and uninstalled packages, except for the most recent 3, by running \texttt{paccache -r} (provided by the \texttt{pacman-contrib} package). 
        \item To remove all cached packages not currently installed, run \texttt{pacman -Sc}
        \item To remove all cached aggressively, run \texttt{pacman -Scc}
        \item To downgrade, you go into the package cache directory and say you want to see which versions of neovim you have installed. You can \texttt{ls} the directory to see the following. 
        
          \begin{cverbatim}
            neovim-0.9.5-1-x86_64.pkg.tar.zst
            neovim-0.9.5-1-x86_64.pkg.tar.zst.sig
            neovim-0.9.5-2-x86_64.pkg.tar.zst
            neovim-0.9.5-2-x86_64.pkg.tar.zst.sig
          \end{cverbatim}

          We have an older version of neovim installed, and to roll it back we can use 
          \begin{cverbatim} 
            pacman -U neovim-0.9.5-1-x86_64.pkg.tar.zst
          \end{cverbatim}
      \end{itemize} 
    \end{enumerate}

    The pacman log (\texttt{/var/log/pacman.log}) is also useful since it logs all pacman outputs when you do anything with pacman. So if you are looking for the packages that have been installed in the latest \texttt{pacman -Syu}, then you can use this to individually see each package that has been upgraded. 


  \subsection{Yay}

    Yay is used to install from the Arch User repository and must be updated separately. To run this, you can either run \texttt{yay -Syu} or you can just run \texttt{yay}. Since this is not officially maintained, these packages are more likely to break something. The yay logs are not stored separately can can be accessed in the pacman logs. 


\section{Vim and Neovim}

  Vim is guaranteed to be on every Linux system, so there is no need to install it. However, you may have to install Neovim (which is just a command away). Vim can be a really big pain in the ass to learn, but I got into it when I was watching some video streams from a senior software engineer at Netflix called The Primeagen. He moved around the code like I've never seen, and I was pretty much at the limit of my typing speed, so I decided to give it a try during the 2023 fall semester. My productivity plummetted during the first 2 days (which was quite scary given that I had homework due), but within a few weeks I was faster than before, so if you have the patience, I would recommend learning it. Here is a summary of reasons why I would recommend learning Vim: 
  \begin{enumerate}
    \item It pushes you to know the ins and outs of your editor. As a mechanic with his tools, a programmer should know exactly how to configure their editor.  
    \item The plugin ecosystem is much more diverse than other editors such as VSCode. You can find plugins/extensions for everything. Here is a summmary of them \href{https://github.com/rockerBOO/awesome-neovim\#neovim-lua-development}{here}. 
    \item You're faster. If you're going to be coding for the next 5 years, then why no t spend a month to master something that will make you faster? You'll increase total productivity. 
    \item Computing clusters and servers will be much easier to navigate since they all run Linux with Vim. 
    \item Vim is lightweight, and you don't have to open up VSCode every time you want to edit a configuration file.  
  \end{enumerate}

  \subsection{Vim vs Neovim}

    Experience wise, Vim and Neovim are very similar, and if you configure things rihght, you may not even be able to tell the difference. But there are 3 differences that I want to mention: 
    
    \begin{enumerate}
      \item Neovim can be configured in Lua, which is much cleaner than Vimscript. 
      \item Neovim provides mouse control right out of the box, which is convenient for me at times and can be easier to transition into, while Vim does not provide any mouse support. 
      \item There are some plugins that are provided in Neovim that are not in Vim. 
    \end{enumerate}

    Either way, the configuration is essentially the same. At startup, the text editor will parse some predetermined configuration file and load those settings. 

    It may be the case that a remote server does not have neovim installed, or you may not have the permissions to install it. In this case, you can use \textbf{sshfs}, which is a file system client based on the SSH File Transfer Protocol. It allows you to mount a remote directory over SSH. 

  \subsection{Vim Configuration File}

    In Vim, your configuration files are located in \texttt{~/.vimrc} and plugins are located in \texttt{~/.vim/}. In here, you can put in whatever options, keymaps, and plugins you want. All the configuration is written in VimScript. 

    \begin{cverbatim} 
      # options 
      filetype plugin indent on 
      syntax on 
      set background=dark
      set expandtab ts=2 sw=2 ai
      set nu
      set linebreak 
      set relativenumber        
      
      # keymaps
      inoremap <C-j> <esc>dvbi
      inoremap jk <esc>
      nnoremap <C-h> ge
      nnoremap <C-l> w 
    \end{cverbatim}
      
  \subsection{Neovim Configuration File}

    In Neovim, I organize it using Lua. It essentially looks for the \texttt{~/.config/nvim/init.lua} file and loads the options from there. We also have the option to import other Lua modules for better file structure with the \texttt{require} keyword. The tree structure of this configuration file should be the following below. The extra \texttt{user} director layer is necessary for isolating configuration files on multiple user environments.  
    
    \begin{cverbatim}
      ... ftplugin
      . ... cpp.lua
      . ... html.lua
      ... init.lua
      ... LICENSE
      ... lua
      . ... user
      .     ... options.lua
      .     ... keymaps.lua
      .     ... plugins.lua
      .     ... telescope.lua
      .     ... toggleterm.lua
      ... plugin
          ... packer_compiled.lua
    \end{cverbatim}

    The init file is the ``main file'' which is parsed first. I generally don't put any explicit options in this file and reserve it only for require statements. It points to the following (group of) files: 
    \begin{enumerate}
      \item \textbf{options.lua}: This is where I store all my options. 
      \item \textbf{keymaps.lua}: All keymaps. 
      \item \textbf{plugins.lua}: First contains a script to automatically install packer if it is not there, and then contains a list of plugins to download. 
      \item \textbf{Plugin Files}: Individual configuration files for each plugin (e.g. if I install a colorscheme plugin, I should choose which specific colorscheme I want from that plugin). 
      \item \textbf{Filetype Configuration Files}: Options/keymaps/plugins to load for a specific filetype. This helps increase convenience and speed since I won't need plugins like VimTex if I am working in JavaScript. 
    \end{enumerate}

    Once you have your basic options and keymaps done, you'll be spending most of your time experimenting with plugins. It is worth to mention some good ones that I use. 
    \begin{enumerate}
      \item \textbf{Packer} as the essential package manager.  
      \item \textbf{Plenary} 
      \item \textbf{Telescope} for quick search and retrieval of files.  
      \item \textbf{Indent-blankline} for folding. 
      \item \textbf{Neoformat} for automatic indent format. 
      \item \textbf{Autopairs} and \textbf{autotag} to automatically close quotation marks and parantheses. 
      \item \textbf{Undotree} to generate and navigate undo history. 
      \item \textbf{Vimtex} for compilation of LaTeX documents. 
      \item \textbf{Onedark} and \textbf{Oceanic Next} for color schemes. 
      \item \textbf{Vim-Startify} for nice looking neovim startup. 
      \item \textbf{Comment} for commenting visual blocks of code. 
    \end{enumerate}

    It is also worthwhile to see how they are actually loaded in the backend. Each plugin is simply a github repo that has been cloned into \texttt{~/.local/share/nvim/site/pack/packer/}, which contains two directories. The packages in \texttt{start/} are loaded up every time Neovim starts, and those in \texttt{opt/} are packages that are loaded up when a command is called in a certain file (known as lazy loading). Therefore, if you have any problems with Neovim, you should probably look into these folders (and possibly delete them and reinstall them using Packer if needed).

  \subsection{Troubleshooting}

    A good test to run is \texttt{:checkhealth}, which checks for any errors or warnings in your Neovim configuration. You should aim to have every (non-optional) warning cleared, which usually involves having to install some package, making it executable and/or adding to \texttt{\$PATH}. 

    If you are getting plugin errors, you can also manually delete the plugin directory in `pack/packer` and run `PackerInstall` to re-pull the repos. This may help. 

\section{Shells and Terminals}

  Beginners may think of the shell and the terminal to be the same thing, but they are different. The \textbf{shell} is a command line interpreter, a layer that sits on top of the kernel in which the user can interact with. It is essentially the only API to the kernel where the user can input commands and processes them. The \textbf{terminal emulator} is a wrapper program that runs a shell and allows us to access the API. It may be useful to think of the shell as like a programming language and the terminal as a text editor like VSCode. 

  The three most common shells are the following: 
  \begin{enumerate}
    \item \textbf{Bash}: 
    \item \textbf{Zsh}: 
    \item \textbf{Fish}:  
  \end{enumerate}

  Some common terminal emulators (most of which comes as a part of the desktop environment) are the following: 
  \begin{enumerate}
    \item \textbf{Kitty}: 
    \item \textbf{Alacritty}: 
    \item \textbf{Gnome-Terminal}: 
  \end{enumerate}

\section{LaTeX and VimTex} 

  Latex is a great way to take notes. One can go to Overleaf and have everything preconfigured, but in here I set it up on my local desktop. I will already assume you have a PDF viewer installed. I use zathura, which is lightweight and also comes with vim motions for navigation. 

  First install the VimTex plugin in \texttt{plugins.lua} with \texttt{use lervag/vimtex}. Then, you want to install TexLive, which is needed to compile tex files and to manage packages. The directions for TexLive installation is available [here](https://tug.org/texlive/quickinstall.html). Once I downloaded the install files, I like to run \texttt{sudo perl ./install-tl --scheme=small}. Be careful with the server location (which can be set with the \texttt{--location} parameter), as I have gotten some errors. I set \texttt{--scheme=small}, which installs about 350 packages compared to the default scheme, which installs about 5000 packages (~7GB). I also did not set \texttt{--no-interaction} since I want to slightly modify the \texttt{--texuserdir} to some other path rather than just my home directory. 

  Once you installed everything, make sure to add the binaries to PATH, which will allow you to access the \textbf{tlmgr} package manager, which pulls from the CTAN (Comprehensive TeX Archive Network) and gives VimTex access to these executables. Unfortunately, the small scheme installation does not also install the \textbf{latexmk} compiler, which is recommended by VimTex. We can simply install this by running 
  ```
  sudo tlmgr install latexmk
  ```
  Now run `:checkhealth` in Neovim and make sure that everything is OK, and install whatever else is needed. 


  To install other Latex packages (and even document classes), we can use tlmgr. All the binaries and packages are located in \texttt{/usr/loca/texlive/202*/} and since we're modifying this, we should run it with root privileges. The binaries can also be found here. Let's go through some basic commands: 
  \begin{enumerate}
    \item List all available packages: \texttt{tlmgr list}
    \item List installed packages: \texttt{tlmgr list --only-installed} (the packages with the `i` next to them are installed)
    \item Install a package and dependencies: \texttt{sudo tlmgr install amsmath tikz} 
    \item Reinstall a package: \texttt{sudo tlmgr install amsmath --reinstall}
    \item Remove a package: \texttt{sudo tlmgr remove amsmath} 
  More commands can be found \href{http://tug.ctan.org/info/tlmgrbasics/doc/tlmgr.pdf}{here} for future reference.  
  \end{enumerate}

  After this, you can install Inkscape, which is free vector-based graphics editor (like Adobe Illustrator). It is great for drawing diagrams, and you can generate custom keymaps that automatically open Inkscape for drawing diagrams within LaTeX, allowing for an seamless note-taking experience.  
    
\section{Networking}

  Networking is a large field in itself, but in here I go over the most useful and practical applications of it in my everyday use. Some ways that I personally benefit from this is:

  \begin{enumerate}
    \item Connecting to WiFi and diagnosing problems.  
    \item Connecting to WiFi and diagnosing problems. 
    \item Connecting to other networks such as computing clusters or third-party blockchains.  
    \item Seeing how more abstract schemes such as APIs work. 
    \item Ethical hacking. 
  \end{enumerate}
  I introduce these concepts and how to do some basic implementation a Unix operating system.

  I like to learn about networking as if I am designing it from scratch. Some big questions to ask when designing network schemes are:

  \begin{enumerate}
    \item How do we uniquely identify computers? 
    \item How should we establish a connection between them? Through hardware or signals? 
    \item What protocols should we use, like a common language, so that all computers understand what each other are saying? 
    \item Can we implement security measures to prevent unwanted visitors into our computer? 
  \end{enumerate} 

  \subsection{Computer Networks and the Internet}

    Let us first define a computer network, some of its architecture, and then move onto the Internet. 

    \begin{definition}[Computer Network]
      A \textbf{computer network} is a group of computers (i.e. computing devices) that use a set of common \textit{communication protocols} over digital interconnections for the purpose of sharing resources located on or provided by the \textit{network nodes}, which may include personal computers, servers, networking hardware, or other specialised or general-purpose hosts. 

    \end{definition}

    These network nodes may be able to communicate to certain neighboring nodes, and this graph architecture determines the \textbf{network topology}. A computer network can be visualized as a connected graph of nodes 

    \begin{example}[Network Topologies]
      Common layouts are: 

      \begin{enumerate}
        \item \textbf{Line Network}: All nodes are connected in a line. 

        \begin{center}\resizebox{8cm}{0.64cm}{%
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}, scale=0.7]
            \node[main node] (A) {A};
            \node[main node] (B) [right of=A] {B};
            \node[main node] (C) [right of=B] {C};
            \node[main node] (D) [right of=C] {D};
            \path[every node/.style={font=\sffamily\small}]
            (A) edge node {} (B)
            (B) edge node {} (C)
            (C) edge node {} (D);
        \end{tikzpicture}}
        \end{center}

          \item \textbf{Bus Network}: All nodes are connected to a common medium along this medium. 

        \item \textbf{Star Network}: all nodes are connected to a special central node.
          \begin{center}
          \resizebox{3cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (F) [left of=A] {F};
              \node[main node] (G) [above left of=A] {G};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (I) [above right of=A] {I};
              \path[every node/.style={font=\sffamily\small}]
              (A) edge node {} (B)
              (A) edge node {} (C)
              (A) edge node {} (D)
              (A) edge node {} (E)
              (A) edge node {} (F)
              (A) edge node {} (G)
              (A) edge node {} (H)
              (A) edge node {} (I);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Ring Network}: Each node is connected to its left and right neighbour node, such that all nodes are connected and that each node can reach each other node by traversing nodes left- or rightwards.
          \begin{center}
          \resizebox{3cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \draw[white, fill=white] (-1,-1) rectangle (1,1);
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (F) [left of=A] {F};
              \node[main node] (G) [above left of=A] {G};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (I) [above right of=A] {I};
              \path[every node/.style={font=\sffamily\small}]
              (B) edge node {} (C)
              (C) edge node {} (D)
              (D) edge node {} (E)
              (E) edge node {} (F)
              (F) edge node {} (G)
              (G) edge node {} (H)
              (H) edge node {} (I)
              (I) edge node {} (B);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Mesh Network}: each node is connected to an arbitrary number of neighbours in such a way that there is at least one traversal from any node to any other. 
          \begin{center}
          \resizebox{3.5cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \draw[white, fill=white] (-1,-1) rectangle (1,1);
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (F) [right of=C] {F};
              \path[every node/.style={font=\sffamily\small}]
              (B) edge node {} (C)
              (B) edge node {} (H)
              (D) edge node {} (C)
              (D) edge node {} (E)
              (C) edge node {} (F)
              (E) edge node {} (H)
              (H) edge node {} (D);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Fully Connected Network}: each node is connected to every other node in the network.
          \begin{center}
          \resizebox{3cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \draw[white, fill=white] (-1,-1) rectangle (1,1);
              \node[main node] (B) [right of=A] {B};
              \node[main node] (C) [below right of=A] {C};
              \node[main node] (D) [below of=A] {D};
              \node[main node] (E) [below left of=A] {E};
              \node[main node] (F) [left of=A] {F};
              \node[main node] (G) [above left of=A] {G};
              \node[main node] (H) [above of=A] {H};
              \node[main node] (I) [above right of=A] {I};
              \path[every node/.style={font=\sffamily\small}]
              (B) edge node {} (C)
              (B) edge node {} (D)
              (B) edge node {} (E)
              (B) edge node {} (F)
              (B) edge node {} (G)
              (B) edge node {} (H)
              (B) edge node {} (I)
              (C) edge node {} (D)
              (C) edge node {} (E)
              (C) edge node {} (F)
              (C) edge node {} (G)
              (C) edge node {} (H)
              (C) edge node {} (I)
              (D) edge node {} (E)
              (D) edge node {} (F)
              (D) edge node {} (G)
              (D) edge node {} (H)
              (D) edge node {} (I)
              (E) edge node {} (F)
              (E) edge node {} (G)
              (E) edge node {} (H)
              (E) edge node {} (I)
              (F) edge node {} (G)
              (F) edge node {} (H)
              (F) edge node {} (I)
              (G) edge node {} (H)
              (G) edge node {} (I)
              (H) edge node {} (I);
          \end{tikzpicture}}
          \end{center}

        \item \textbf{Tree Network}: nodes are arranged hierarchically.
          \begin{center}
          \resizebox{5cm}{3cm}{%
          \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
              \node[main node] (A) {A};
              \node[main node] (B) [above right of=A] {B};
              \node[main node] (C) [above left of=A] {C};
              \node[main node] (D) [above left of=C] {D};
              \node[main node] (E) [above right of=B] {E};
              \node[main node] (F) [above left of=B] {F};
              \path[every node/.style={font=\sffamily\small}]
              (A) edge node {} (B)
              (A) edge node {} (C)
              (B) edge node {} (F)
              (B) edge node {} (E)
              (C) edge node {} (D);
          \end{tikzpicture}}
          \end{center}
      \end{enumerate} 
    \end{example}

    Notice how many of these networks have \textbf{redundancy}: having multiple ways to get from one node to another. That is, when a network path is no longer available, data is still able to reach its destination through another path. Usually, we would like to avoid a \textbf{single point of failure} and construct a \textbf{fault-tolerant} system that can experience failure in its components but still continue operating properly. However, building more connections may be expensive. 

    Because there are multiple paths that a piece of data takes to get from point X to point Y, \textit{routing strategies} are implemented in order to determine the most optimal path. Now in order for network nodes to communicate with each other, they should have some sort of universal method of communicating with each other. 

    \begin{definition}[Communication Protocol]
      A \textbf{communication protocol} is a system of rules that allow multiple entities of a communications to transmit information via any kind variation of a physical quantity. The protocol defines the rules, syntax, semantics and synchronization of communication and possible error recovery methods. A protocol can have many jobs, such as: 
      
      \begin{enumerate} 
        \item Determining how nodes will communicate with each other . 
        \item Making sure that these modes of communication is compatible with hardware .
        \item Implementing security protocols such as encryption schemes. 
      \end{enumerate}
    \end{definition}

    Computers can connect through \textbf{physical} (e.g. cables) or \textbf{wireless} connections. 

    \begin{enumerate}
      \item The \textbf{CAT5 cable} is a \textit{twisted pair (copper) cable} that's designed for use in computer networks. It consists of four twisted pairs of copper wires. These twisted pair cables send data through a network by transmitting pulses of electricity that represent binary data. The information transmission follow the \textbf{Ethernet} standards, which is why twisted pair cables are commonly known as Ethernet cables. Use for both LANs and WANs. They can carry up to 1 Gbps across hundreds of feet, but are susceptible to interference. 

      \item \textbf{Fiber-optic cables} carry light instead of electricity in a fiber coated with plastic layers. The pulses of light represent binary data and also follow the Ethernet standards. They are also capable of transmitting much more data per second that copper cables, and they have the advantage of low transmission loss and immunity to electrical interference. Often used to connect networks across oceans so that data can travel quickly around the world. They can carry up to 26 Tbps acorss 50 miles (but are expensive)

      \item A wireless card inside a computer turns binary data into \textbf{radio waves} and transmits them through the air. However, they do not travel very far (~100 ft in office buildings or up to 1000 ft in an open field). The waves are picked up by a \textit{wireless access point} which converts them from radio waves back into binary data. These access points would be connected to the rest of the network using physical wiring. They can carry up to 1.3 Gbps. 

      \item \textbf{Infrared signals} and \textbf{microwaves} are sometimes used. 
    \end{enumerate}


    In order for the computers to send data into binary, they must convert this data into binary and send them as streams of 1s and 0s in a process called \textbf{line coding}. Furthermore, computers can raise efficiency of each wire by sending changing electric currents through a single wire. For example, rather than using three wires to encode $\texttt{101}$ as 

    \begin{center}
      \begin{tikzpicture}[scale=0.6]
        \draw[thick, red] (0,1)--(9,1);
        \draw[thick] (0,0)--(9,0);
        \draw[thick, red] (0,-1)--(9,-1);
        \node[right] at (9,1) {1};
        \node[right] at (9,0) {0}; 
        \node[right] at (9,-1) {1};
      \end{tikzpicture}
    \end{center}

    they send it through a single wire with intervals of $\frac{1}{3}$ seconds

    \begin{center}
      \begin{tikzpicture}[scale=0.6]
        \draw[thick, red] (0,0)--(3,0);
        \draw[thick] (3,0)--(6,0);
        \draw[thick, red] (6,0)--(9,0);
        \node[right] at (9,0) {1 0 1};
      \end{tikzpicture}
    \end{center}

    or even better, at a rate of 1 megabit per second (interval of $0.000001$ seconds)

    \begin{center}
      \begin{tikzpicture}[scale=0.8]
        \draw[thick, red] (0,0)--(3,0);
        \draw[thick] (3,0)--(6,0);
        \draw[thick, red] (6,0)--(9,0);
        \draw[fill] (0,0) circle (0.05);
        \draw[fill] (3,0) circle (0.05);
        \draw[fill] (6,0) circle (0.05);
        \draw[fill] (9,0) circle (0.05);
        \node[below] at (0,0) {.000000s};
        \node[below] at (3,0) {.000001s};
        \node[below] at (6,0) {.000002s};
        \node[below] at (9,0) {.000003s};
      \end{tikzpicture}
    \end{center}

    As long as two computers agree on the time period in which the electricity intervals are being sent, they can communicate much more efficiently. In an electrical connection (such as Ethernet), the signal would be a voltage or current. In an optical connection (such as a fiber-optic cable), the signal would be the intensity of light. 

    \begin{definition}
      There are many properties about line coding that are relevant, but ultimately the speed of a connection is a combination of the bandwidth and latency. 

      \begin{enumerate}
        \item The \textbf{bit rate} describes the data transfer rate of a connection. It measures the number of bit states that a channel can \textit{transmit} per unit time. It is measured in \textit{bits per second}. We can interpret it as the amount of water flowing through a pipe. 
        
        Bit rate is typically seen in terms of the actual data rate. But for most transmissions, the data represents part of a more complex protocol, which includes bits representing source address, destination address, error detection/correction codes, and other information. This data is called the \textbf{overhead}, while the actual data transferred is called the \textbf{payload}. At times, the overhead may be substantial (up to 20\% to 50\%). 

        \item The \textbf{throughput} is the number of bit states of usable information, that can be successfully \textit{received} over a channel per unit time. Without any channel noise, it is really just the payload. Note that this is an \textit{observed, dynamic parameter} with a fixed and variable loss. It is also known as \textbf{consumed bandwidth} and is measured in \textit{bits per second}. 
        
        \item The \textbf{bandwidth} describes the \textit{maximum} data transfer rate of a connection; that is, the maximum throughput of a communication. It is measured in \textit{bits per second}. We can interpret it as how thick the pipe is (i.e. how much water can flow through it at max). Note that this is different from the bandwidth used in signal processing. 
        
        Data often flows over multiple network connections, which means the connection with the smallest bandwidth (most likely your local connection) acts as a bottleneck. 
        
        \item The \textbf{latency}, or \textbf{ping-rate}, measures the round trip time between the sending of a data message to a computer and the receiving of that message, measured in \textit{milliseconds}. We can interpret it as the speed at which the water is flowing through a pipe. We can check latency by doing
        \begin{cverbatim}
          >>>ping www.google.com
          64 bytes: icmp_seq=0 ttl=115 time=37.868 ms
        \end{cverbatim}

        which outputs a latency time of 37.868ms (to get to $\texttt{www.google.com}$ and back) for sending a data packet of 64 bytes. Note that there is an intrinsic limiting factor to latency: the speed of light, which is approximately 1 foot per nanosecond. In addition to distance, another limiting factor is the congestion in the network and the type of connection. 
      \end{enumerate}
    \end{definition}

    \begin{example}
    Given two computers connected by a wire that is configured to transfer 1000 bits per second, the bit rate would be 1 Kbps. However, if the channel has noise and demands retransmission of 10 bits out of every 1000 of the original transmission, then the throughput would be 990 bps. 

    Furthermore, the Ethernet frame can have as many as 1542 bytes. Say that there are 1500 bytes of payload and an overhead of 42 bytes. Then, the \textbf{protocol efficiency} would would be 
    \[\frac{\text{payload}}{\text{frame size}} = \frac{1500}{1542} = 0.9727 = 97.3\%\]
    \end{example}

    Typically, the actual line rate is stepped up by a factor influenced by the overhead to achieve an actual target net data rate. In One Gigabit Ethernet, the actual line rate is 1.25 Gbits/s to achieve a net payload throughput of 1 Gbit/s. In a 10-Gbit/s Ethernet system, gross data rate equals 10.3125 Gbits/s to achieve a true data rate of 10 Gbits/s. The net data rate also is referred to as the throughput, or payload rate, of effective data rate.

  \subsection{History of the Internet}

    IETF, ICANN, IANA, ISPs.  

    \begin{example}[ARPANET]
      The ARPANET was the precursor to the Internet, the network where Internet technology was first tested out. It was started in 1969 with four computers connected to each other. 

        \begin{center}\resizebox{5cm}{3cm}{%
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm, thick,main node/.style={circle,draw}, every loop/.style={}]
            \node[main node] (UCLA) {UCLA};
            \node[main node] (UCSB) [left of=UCLA] {UCSB};
            \node[main node] (SRI) [above left of=UCLA] {SRI};
            \node[main node] (UTAH) [above right of=UCLA] {UTAH};
            \path[every node/.style={font=\sffamily\small}]
            (UCLA) edge node {} (UCSB)
            (UCLA) edge node {} (SRI)
            (UCSB) edge node {} (SRI)
            (SRI) edge node {} (UTAH);
        \end{tikzpicture}}
        \end{center}

      For example, even if the path between SRI and UCSB is gone, the connections between SRI and UCSB is not lost (since IP packets can travel through UCLA's router). 
    \end{example}


    Now we can see an implementation of these networks in the internet. 

    \begin{definition}[Internet]
      The \textbf{Internet} is a global network of computing devices communicating with each other in some way, whether they're sending emails, downloading files, or sharing websites. The Internet is an \textbf{open network}, which means that any computing device can join as long as they follow the protocols. The internet is powered by many layers of protocols, and to create a global network of computing devices, we need: 

      \begin{enumerate}
        \item \textbf{Wires \& Wireless}: Physical connections between devices, plus protocols for converting electromagnetic signals into binary data. 
        \item \textbf{IP}: A protocol that uniquely identifies devices using IP addresses and provides a routing strategy to send data to a destination IP address. 
        \item \textbf{TCP/UDP}: Protocols that can transport packets of data from one device to another and check for errors along the way. 
        \item \textbf{TLS}: A secure protocol for sending encrypted data so that attackers can't view private information. 
        \item \textbf{HTTP \& DNS}: The protocols powering the World Wide Web
      \end{enumerate}        
    \end{definition}

    An \textbf{ISP (Internet Service Provider)} provides internet to its region. These ISPs are managed by certain continental autonomous systems (\textbf{AS}). The \textbf{Regional Internet Registry (RIR)} is divided into their regions: AFRNIC (Africa), ARIN (American), APNIC (Asia-Pacific), LACNIC (Latin America and Carribean), and RIPE NCC (European). 

    The main protocol suite used by the internet is \textbf{TCP/IP}, which is a collection of protocols that the internet uses. The bulk of this chapter will describe this protocol. 

    \begin{figure}[hbt!]
      \centering
      \includegraphics[scale=0.7]{img/tcp_ip_model.png}
      \caption{TCP/IP layering model. }
      \label{fig:tcp_ip_model}
    \end{figure}

  \subsection{Network Interfaces}

    Before we even start talking about IP addresses or protocols, we should mention that there are several interfaces from which computers can send and receive data. For example, if you are connected to both wired ethernet and WiFi, there are two paths, or interfaces, that data can travel. To see all your interfaces, use the \texttt{ip -c a} command. 

    \begin{cverbatim} 
      1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default  
          link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
          inet 127.0.0.1/8 scope host lo
             valid_lft forever preferred_lft forever
          inet6 ::1/128 scope host noprefixroute 
             valid_lft forever preferred_lft forever
      2: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group 
          link/ether 64:bc:58:11:c0:24 brd ff:ff:ff:ff:ff:ff
          inet 10.197.221.245/16 brd 10.197.255.255 scope global dynamic noprefixroute 
             valid_lft 597085sec preferred_lft 597085sec
          inet6 fe80::b9e9:2f85:ded7:eaaf/64 scope link noprefixroute 
             valid_lft forever preferred_lft forever
    \end{cverbatim}

    The following lists out all the interfaces. We can see that we're connected to two interfaces, but there are a lot more. Usually, these interfaces also have a number following them that indexes different instances of the same type of interface. 

    \begin{enumerate} 
      \item \textbf{lo}: This is the loopback interface. 
      \item \textbf{wlan0}: For wireless connections 
      \item \textbf{tun}: When you are connected to VPN. 
      \item \textbf{en}: 
      \item \textbf{gif}: 
      \item \textbf{awd}: 
      \item \textbf{llw}: 
      \item \textbf{bridge}: 
      \item \textbf{utun}: 
    \end{enumerate}

    For each interface, there is a set of protocols that must be set for data to transfer. 

  \subsection{Addresses}

    Every computer needs some address that determines its unique identity. The version of TCP/IP that has been in widespread use is IPv4, which uses 4-byte IP addresses. A modernized version, IPv6, expands the IP address space to 16 bytes and incorporates several additional features, making it faster and easier to implement. 

    \begin{definition}[IP Address]
      The protocol describes the use of \textbf{IP addresses} to uniquely identify Internet-connected devices (for transmission of data). That is, when a computer sends a message to another computer, it must specify the recipient's IP address and also include its own IP address so that the second computer can reply. There are two versions of the Internet Protocol in use today: 
      \begin{enumerate}
          \item \textbf{IPv4}: The first version ever used on the Internet and having the form of 4 \textit{octets} split by periods in between. 

            \[[0-255].[0-255].[0-255].[0-255]\]

          Even though it presented in decimal, computers store them in binary 

            \[74.125.20.113 \iff 01001011.01111101.00010100.01110001\]

          IPv4 addresses can take $2^{32}$ values, but IPv6 was created for more space.

          \item \textbf{IPv6}: The newer standard (introduced in June 2012) is in the form 

            \[\text{FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF}\]

          with hexadecimal digits (total of ~$3.4 \times 10^{39}$ possible IPv6 values). 
      \end{enumerate}
    \end{definition}


    \begin{definition}[CIDR Notation]
      Sometimes, a set of IP addresses are specified using \textbf{CIDR notation}. An address of the form 

        \[145.201.67.4/16\]

      represents all addresses of form $145.201.\ast.\ast$. 
    \end{definition}

    Operating systems and network devices have supported IPv6 for a long time, and the motivation behind the deployment of IPv6 was due to the concern that devices were running out of IPv4 addresses. Asia ran out first in 2011, followed by every other continent ever since then. 

    But we've learned to make more efficient use of the IPv4 addresses that we have. For example, \textbf{Network Address Translation} (or \textbf{NAT}) lets entire networks of machines hide behind single IPv4 addresses. \textbf{Classless Inter-Domain Routing} (\textbf{CIDR}) subdivides networks and promotes efficient backbone routing as well. Ultimately, IPv6, with better security and engineering, is going to take over, but not for a while since it's not fundamentally different from IPv4 and the drawbacks of IPv4 haven't been bad enough to spark migration. 

    \begin{definition}[Hierarchy of IP Addresses] 
      The IP addresses are formatted in an \textit{hierarchical way}. The IPv4 address hierarchy is structured as such: The first few numbers (may or may not be divided by octets) could identify a \textbf{network} administered by an Internet Service Provider. The last numbers, which can also represent \textbf{subnetworks} (subnets), identifies a home computer on that network. 
    \end{definition}

    \begin{example}[University of Michigan]
      For example, if we represent the IP address 141.213.127.13 in binary (of 32 bits)

        \[10001101.11010101.01111111.00001101\]

      the first 16 bits could route to all of UMich, the next two bits could route to a specific UMich department, and the final 14 bits could route to individual computers. 
      \begin{center}
      \begin{tabular}{l|l|l}
          1000110111010101 & 01 & 11111100001101  \\
          \hline
          UMich Network & Medicine department & Lab computer 
      \end{tabular}
      \end{center}
      This hierarchy gives UMich the ability to differentiate between $2^2$ departments and $2^{14} = 16,384$ computers within each department. In general, the ability to create hierarchical levels at any point in the IP address allows for greater flexibility in the size of each level of the hierarchy. 
    \end{example}
    
    \begin{example}[Duke]
      Duke's IP addresses are of the form $153.3.\_.\_$, with the DUKE-INTERCHANGE ISP provider.  
    \end{example} 

    \begin{definition}[Hostname]
      IP addresses can be quite cumbersome to memorize, which is why they are often addressed with their \textbf{hostname}. Operating systems allow one or more hostnames to be associated with an IP address so that users can type \texttt{rfc-editor.org} rather than $4.31.198.49$. This mapping can be set up  in multiple days, e.g. with the \texttt{/etc/hosts} file or the LDAP database system to DNS the world-wide \textbf{Domain Name System}. 
    \end{definition}

    \subsubsection{LAN Addresses and NAT} 

      We've talked about how entire networks of machines can hide behind a single IPv4 address. Let's elaborate on this. In fact, your computer is not connected to the internet directly. It is actually in a \textbf{private network}, or a \textit{LAN network}, which uses a private IP address space (supported by both IPv4 and v6). Anything on the inside of your private network is not on the Internet; it is on your LAN, an entirely separate network, with its own address space. Anything on your LAN must have a unique (within the LAN) IP address to participate properly with your local network. Therefore, anyone else who has a LAN is also not part of the internet. So if you are only on your LAN network, how do you actually connect to the internet? 

      \begin{definition}[Router] 
        The \textbf{router} is a device that forms a connection between your LAN network and the internet. It has both a private local address, called a \textbf{gateway address}, and a public address. It is responsible for forwarding data between the local server computers and the internet. Therefore, to the outside world, all devices identify the network internet activity by the one public IP address assigned to the router. 

        The gateway address can be found with \texttt{ip route} and the public address, of course, can be found with the commands previously mentioned. 
      \end{definition}

      \begin{definition}[Modem]
        A \textbf{modem}, short for \textbf{modulator/demodulator} is a device that converts a signal from your computer to some kind of signal to talk to other computers. The main difference between the router and the modem is that 
        \begin{enumerate} 
           \item The router crates a network between the computers in your home and routes network traffic between them (through Ethernet cables or wireless connection). Your home router has one connection to the Internet and connections to your private local network. 

          \item The modem serves as a bridge between your local network and the Internet.  
        \end{enumerate}
      \end{definition}

      To access our IP address, we can do the following: 
      \begin{enumerate} 
        \item To access local ip address, we can either run the command \texttt{hostname -i}, \texttt{ip -c a}, or \texttt{ifconfig}.
          
        \item To access the public ip address, we can either google it or run \texttt{curl ifconfig.me}. Since this is public, any device connected to the same network/router should have the same IP address. 
      \end{enumerate}

      \begin{definition}[NAT]
        In order for LAN devices to connect to the Internet, their outgoing traffic has the source address changed to match that of the internet/WAN IP address of the router. The router keeps track of this, and makes sure any response traffic gets sent to the right internal machine. This is called \textbf{Network Address Translation (NAT)}. There are generally two types of NAT: 

        \begin{enumerate}
          \item \textbf{Basic, one-to-one NAT}: The simplest type of NAT provides a one-to-one translation of IP addresses. In this type of NAT, only the IP addresses, IP header checksum, and any higher-level checksums that include the IP address are changed. Basic NAT can be used to interconnect two IP networks that have incompatible addressing. 

          \item \textbf{One-to-many NAT}: The majority of network address translators map multiple private hosts to one publicly exposed IP address. In a typical configuration, a local network uses one of the designated private IP address subnets. A router in that network has a private address of that address pace. The router it also connected to the Internet with a \textit{public} address assigned by the ISP. As traffic passes from the local network to the Internet, the source address in each packet is translated on the fly from a private address to the public address. The router tracks basic data about each active connection (particularly the destination address and port). When a reply returns to the router, it uses the connection tracking data it stored during the outbound phase to determine the private address on the internal network to which to forward the reply. 
        \end{enumerate}
      \end{definition}

      \begin{definition}
        The IP addresses that are in the private network's space are usually divided up into 3 categories. But as of now, the categories don't mean anything. 

        \begin{enumerate}
          \item \textbf{Class A private range addresses}: 10.0.0.0 - 10.255.255.255 (16,777,216 IPs)
          \item \textbf{Class B private range addresses}: 172.16.0.0  172.31.255.255 (1,048,576 IPs)
          \item \textbf{Class C private range addresses}: 192.168.0.0  192.168.255.255 (65,536 IPs)
        \end{enumerate}

        Since the private IPv4 address space is relatively small, many private IPv4 networks unavoidably use the same address ranges. This can create a problem when merging such networks, as some addresses may be duplicated for multiple devices. In this case, networks or hosts must be renumbered, often a time-consuming task, or a network address translator must be placed between the networks to translate or masquerade one of the address ranges. 
      \end{definition}


    \subsubsection{Ports}

      IP addresses identify a machine's network interfaces, but they aren't specific enough to address individual processes or services, many of which might be actively using the network at once. TCP and UDP extend IP addresses with a concept known as a port, which is a 16-bit number that supplements an IP address to a particular communication channel. Valid ports range from $1$ to $65,535$. A port, combined with an IP address, results in a \textbf{socket address} that is used to establish a connection between a client and a server. 

      UNIX systems restrict programs from binding to port numbers under 1024 unless they are run as root or have an appropriate Linux capability. Anyone can communicate with a server running on a low port number; the restriction only applies to the program listening on the port.

    \subsubsection{Hardware (MAC) Addresses}

      The lowest level of addressing is the network hardware. Many devices are assigned a unique 6-byte hardware address at the time of manufacture. The first 3 bytes identify the manufacturer, and the last 3 bytes are a unique serial number that the manufacturer assigns. Sysadmins can sometimes identify the brand of machine that is trashing a network by looking up the 3-byte identifier in a table of vendor IDs. In theory, ethernet hardware addresses are permanently assigned and immutable, but many network interfaces let you override the hardware address and set one of your own choosing. 

  \subsection{TCP Packets and Encapsulation}

  \subsection{OSI and Internet Protocols}
  

  \subsection{HTTP and HTTPS} 

    HTTP stands for hypertext transfer protocol, implemented in Layer 7, which transfers data between your computer and the server over the internet through \textbf{clear text}. This may not be the most ideal way since any interceptors can read the transferred data. This isn't a problem for regular internet browsing, but if you are inputting sensitive data, then HTTP should not be used. This is why HTTPS (which stands for secure HTTP) was invented, which  is implemented in Layer 4 and encrypts the data being transferred, and every website where you input sensitive data should be using HTTPS (indicated by the \texttt{https://} prefix in the URL and a padlock symbol for modern browsers). Due to the extra security measures, HTTPS is less lightweight than HTTP, and its respective default ports are HTTP (80) and HTTPS (443).  

    A natural question to ask would be: which encryption scheme does HTTPS use? Both Secure Sockets Layer (SSL) and Transport Layer Security (TLS) is used in the modern web. 

    SSL certificate. 

    
  \subsection{UDP and TCP}

    TCP handshake can be seen with curl. 

  \subsection{SSH}


\section{Driver and Hardware Configuration}

  \subsection{Audio Drivers} 


  \subsection{Bluetooth}
    Blueman. 

  \subsection{Synaptics}


  \subsection{Video Drivers}


  \subsection{Monitor}


  \subsection{Nvidia GPU Drivers} 


\section{Development}

  \subsection{Git} 
    


  \subsection{Python and Conda}

    Make sure to add conda path to PATH. 

\end{document}

